<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="MISRAMISRA C是由汽车产业软件可靠性协会（MISRA）提出的C语言开发标准。其目的是在增进嵌入式系统的安全性及可移植性。针对C++语言也有对应的标准MISRA C++。 MISRA C一开始主要是针对汽车产业，不过其他产业也逐渐开始使用MISRA C：包括航天、电信、国防、医疗设备、铁路等领域中都已有厂商使用MISRA C。 MISRA C的第一版《Guidelines for the">
<meta property="og:type" content="article">
<meta property="og:title" content="freertos">
<meta property="og:url" content="http://example.com/2024/01/02/freeRTOS/index.html">
<meta property="og:site_name" content="Excerpt">
<meta property="og:description" content="MISRAMISRA C是由汽车产业软件可靠性协会（MISRA）提出的C语言开发标准。其目的是在增进嵌入式系统的安全性及可移植性。针对C++语言也有对应的标准MISRA C++。 MISRA C一开始主要是针对汽车产业，不过其他产业也逐渐开始使用MISRA C：包括航天、电信、国防、医疗设备、铁路等领域中都已有厂商使用MISRA C。 MISRA C的第一版《Guidelines for the">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-01-01T16:00:01.000Z">
<meta property="article:modified_time" content="2024-04-25T06:40:17.311Z">
<meta property="article:author" content="Linkua">
<meta property="article:tag" content="rtos">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2024/01/02/freeRTOS/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>freertos | Excerpt</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Excerpt</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-clock">

    <a href="/clock/" rel="section"><i class="fas fa-clock fa-fw"></i>clock</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/02/freeRTOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Linkua">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Excerpt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          freertos
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-01-02 00:00:01" itemprop="dateCreated datePublished" datetime="2024-01-02T00:00:01+08:00">2024-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-04-25 14:40:17" itemprop="dateModified" datetime="2024-04-25T14:40:17+08:00">2024-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MCU/" itemprop="url" rel="index"><span itemprop="name">MCU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="MISRA"><a href="#MISRA" class="headerlink" title="MISRA"></a>MISRA</h2><p>MISRA C是由汽车产业软件可靠性协会（MISRA）提出的C语言开发标准。其目的是在增进嵌入式系统的安全性及可移植性。针对C++语言也有对应的标准MISRA C++。</p>
<p>MISRA C一开始主要是针对汽车产业，不过其他产业也逐渐开始使用MISRA C：包括航天、电信、国防、医疗设备、铁路等领域中都已有厂商使用MISRA C。</p>
<p>MISRA C的第一版《Guidelines for the use of the C language in vehicle based software》是在1998年发行，一般称为MISRA-C:1998.。MISRA-C:1998有127项规则，规则从1号编号到127号，其中有93项是必需要求，其余的34项是推荐使用的规则。</p>
<p>在2004年时发行了第二版的MISRA C的第一版《Guidelines for the use of the C language in critical systems》（或称作MISRA-C:2004），其中有许多重要建议事项的变更，其规则也重新编号。MISRA-C:2004有141项规则，其中121项是必需要求，其余的20项是推荐使用的规则。规则分为21类，从“开发环境”到“运行期错误”。</p>
<p>2012年发布第三版，为当前最新有效的C语言规范版本，称为MISRAC:2012。 </p>
<p>Misra C不能100%保证程序不出问题，但是能尽可能的预防，总结一下，基本上使用Misra C具有以下五个维度的优势：</p>
<p>提升可靠性 提升可读性 提升可移植性 提升可维护性 提升安全性</p>
<span id="more"></span>

<h2 id="数据类型和编码风格指南"><a href="#数据类型和编码风格指南" class="headerlink" title="数据类型和编码风格指南"></a>数据类型和编码风格指南</h2><p>数据类型<br>FreeRTOS 的每个端口都有一个唯一的 portmacro.h 头文件，其中包含（除其他外）两种端口特定数据类型的定义：TickType_t 和 BaseType_t。这些数据类型在表 2 中进行了描述。<br>变量<br>TickType_t 是用于保存滴答计数值和指定时间的数据类型。<br>TickType_t 可以是无符号 16 位类型，也可以是无符号 32 位类型，具体取决于 FreeRTOSConfig.h 中 configUSE_16_BIT_TICKS 的设置。<br>BaseType_t 这始终被定义为架构中最有效的数据类型。通常，这是 32 位架构上的 32 位类型，16 位架构上的 16 位类型，以及 8 位架构上的 8 位类型。<br>BaseType_t 通常用于只能采用非常有限范围的值的返回类型，以及用于 pdTRUE&#x2F;pdFALSE 类型的布尔值。<br>一些编译器使所有不合格的 char 变量无符号，而另一些编译器使它们有符号。出于这个原因，FreeRTOS 源代码明确地用 ‘signed’ 或 ‘unsigned’ 来限定 char 的每次使用，<br>除非 char 用于保存 ASCII 字符，或者指向 char 的指针用于指向字符串。<br>从不使用普通的 int 类型。</p>
<p>变量名<br>变量以它们的类型为前缀：’c’ 表示 char，’s’ 表示 int16_t（短），’l’ int32_t（长），’x’ 表示 BaseType_t 和任何其他非标准类型（结构、任务句柄、队列把手等）。</p>
<p>如果一个变量是无符号的，它也以’u’为前缀。如果一个变量是一个指针，它也以’p’为前缀。例如，uint8_t 类型的变量将以“uc”为前缀，而指向 char 的指针类型的变量将以“pc”为前缀。</p>
<p>函数名称</p>
<p>函数以它们返回的类型和定义它们的文件作为前缀。例如：</p>
<p>v Task PrioritySet() 返回一个void并在task .c 中定义。</p>
<p>x Queue Receive() 返回一个BaseType_t类型的变量，并在queue .c 中定义。</p>
<p>pv Timer GetTimerID ( ) 返回指向 void 的指针，并在timers .c 中定义。</p>
<p>文件范围（私有）函数以“prv”为前缀。</p>
<p>格式化</p>
<p>一个制表符始终设置为等于四个空格。</p>
<p>宏名称</p>
<p>大多数宏都是大写的，并以小写字母为前缀，指示宏的定义位置。表 3 提供了前缀列表。<br>端口（例如，portMAX_DELAY）        portmacro.h<br>任务（例如，taskENTER_CRITICAL()） task.h<br>配置（例如，configUSE_PREEMPTION） FreeRTOSConfig.h</p>
<p>pdFALSE   0<br>pdPASS    1</p>
<h2 id="创建-FreeRTOS项目"><a href="#创建-FreeRTOS项目" class="headerlink" title="创建 FreeRTOS项目"></a>创建 FreeRTOS项目</h2><p>File                        Location</p>
<p>tasks.c                     FreeRTOS&#x2F;Source</p>
<p>queue.c                     FreeRTOS&#x2F;Source</p>
<p>list.c                      FreeRTOS&#x2F;Source</p>
<p>timers.c                    FreeRTOS&#x2F;Source</p>
<p>event_groups.c              FreeRTOS&#x2F;Source</p>
<p>All C and assembler files   FreeRTOS&#x2F;Source&#x2F;portable&#x2F;[compiler]&#x2F;[architecture]</p>
<p>heap_n.c                    FreeRTOS&#x2F;Source&#x2F;portable&#x2F;MemMang，其中 n 为 1、2、3、4 或 5。此文件从 FreeRTOS V9.0.0 变为可选文件。</p>
<p>使用早于 V9.0.0 的 FreeRTOS 版本的项目必须构建 heap_n.c 文件之一。从 FreeRTOS V9.0.0 开始，只有在 FreeRTOSConfig.h 中的 configSUPPORT_DYNAMIC_ALLOCATION 设置为 1 或 configSUPPORT_DYNAMIC_ALLOCATION 未定义时，才需要 heap_n.c 文件。有关详细信息，请参阅第 2 章，堆内存管理。</p>
<p>以下步骤基于常见的 Bluepill STM32F103C8T6, 也适用于其它 libopencm3 支持的MCU型号</p>
<h3 id="方案一-只复制需要的文件-Keil-or-others"><a href="#方案一-只复制需要的文件-Keil-or-others" class="headerlink" title="方案一: 只复制需要的文件 Keil or others"></a>方案一: 只复制需要的文件 Keil or others</h3><p>在 PlatformIO 中, Board 选择 Bluepill F103C8, Framework 选择 libopencm3, 创建项目<br>在项目的lib下新建目录 FreeRTOS<br>解压缩最新的 FreeRTOS<br>复制 FreeRTOS&#x2F;Source&#x2F; 目录下, 除 portable 目录以外其它全部文件和目录, 至 lib&#x2F;FreeRTOS 下<br>复制 FreeRTOS&#x2F;Source&#x2F;portable&#x2F;GCC&#x2F;ARM_CM3 目录下所有文件(port.c, portmacro.h), 至 lib&#x2F;FreeRTOS 下<br>复制 FreeRTOS&#x2F;Source&#x2F;portable&#x2F;Common 目录下所有文件(mpu_wrappers.c), 至 lib&#x2F;FreeRTOS 下<br>复制 FreeRTOS&#x2F;Source&#x2F;portable&#x2F;MemMang 目录下 heap_4.c, 至 lib&#x2F;FreeRTOS 下<br>复制 FreeRTOSConfig.h, 至 lib&#x2F;FreeRTOS&#x2F;include 下<br>编写 src&#x2F;main.c</p>
<h3 id="方案二-完整的FreeRTOS-使用library-json-PlatformIO-libopencm3-FreeRTOS"><a href="#方案二-完整的FreeRTOS-使用library-json-PlatformIO-libopencm3-FreeRTOS" class="headerlink" title="方案二: 完整的FreeRTOS, 使用library.json  PlatformIO: libopencm3 + FreeRTOS"></a>方案二: 完整的FreeRTOS, 使用library.json  PlatformIO: libopencm3 + FreeRTOS</h3><p>在 PlatformIO 中, Board 选择 Bluepill F103C8, Framework 选择 libopencm3, 创建项目<br>在项目的lib下新建目录 FreeRTOS<br>解压缩最新的 FreeRTOS<br>复制 FreeRTOS&#x2F;Source&#x2F; 目录下所有文件至 lib&#x2F;FreeRTOS 下<br>复制 FreeRTOSConfig.h, 至 lib&#x2F;FreeRTOS 下<br>lib&#x2F;FreeRTOS 下添加 library.json<br>编写 src&#x2F;main.c<br>library.json 内容如下, 只包含需要的 c 文件, 用 flags 包含额外的include路径, issue #4148</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;FreeRTOS&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;10.4.6&quot;,</span><br><span class="line">    &quot;build&quot;: &#123;</span><br><span class="line">        &quot;flags&quot;: [</span><br><span class="line">            &quot;-Iportable/GCC/ARM_CM3&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;srcFilter&quot;: [</span><br><span class="line">            &quot;+&lt;*.c&gt;&quot;,</span><br><span class="line">            &quot;+&lt;portable/GCC/ARM_CM3/port.c&gt;&quot;,</span><br><span class="line">            &quot;+&lt;portable/MemMang/heap_4.c&gt;&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">如果是多核MCU, 需要再包含 mpu_wrappers.c, 对于 F103C8 就不需要了</span><br><span class="line"></span><br><span class="line">&quot;+&lt;portable/Common/mpu_wrappers.c&gt;&quot;,</span><br></pre></td></tr></table></figure>

<h3 id="FreeRTOSConfig-h-函数名适配"><a href="#FreeRTOSConfig-h-函数名适配" class="headerlink" title="FreeRTOSConfig.h 函数名适配"></a>FreeRTOSConfig.h 函数名适配</h3><p>在 libopencm3&#x2F;lib&#x2F;cm3&#x2F;vector.c 中, 定义了 .sv_call,.pend_sv and .systick 的处理函数,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Those are defined only on CM3 or CM4 */</span><br><span class="line">#if defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__)</span><br><span class="line">	.memory_manage_fault = mem_manage_handler,</span><br><span class="line">	.bus_fault = bus_fault_handler,</span><br><span class="line">	.usage_fault = usage_fault_handler,</span><br><span class="line">	.debug_monitor = debug_monitor_handler,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	.sv_call = sv_call_handler,</span><br><span class="line">	.pend_sv = pend_sv_handler,</span><br><span class="line">	.systick = sys_tick_handler,</span><br><span class="line">	.irq = &#123;</span><br><span class="line">		IRQ_HANDLERS</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些函数名与 FreeRTOS 中的函数名不一致, 需要将其关联. 使用宏替换的方式比使用函数转发方式效率更高, 所以在 FreeRTOSConfig.h 中需要增加如下定义, 否则 FreeRTOS 不能正常工作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * In libopencm3/lib/cm3/vector.c, these 3 handlers(right side) are for .sv_call,.pend_sv and .systick</span><br><span class="line"> * These macro will rename the methods in port.c to make it work, more efficient than wrapped by method</span><br><span class="line">*/</span><br><span class="line">#define vPortSVCHandler sv_call_handler</span><br><span class="line">#define xPortPendSVHandler pend_sv_handler</span><br><span class="line">#define xPortSysTickHandler sys_tick_handler</span><br></pre></td></tr></table></figure>

<h2 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h2><h3 id="heap-1-c"><a href="#heap-1-c" class="headerlink" title="heap_1.c"></a>heap_1.c</h3><p>实现了一个非常基本的 pvPortMalloc() 版本，并没有实现 vPortFree()。从不删除任务或其他内核对象的应用程序有可能使用 heap_1<br>一些原本禁止使用动态内存分配的商业关键和安全关键系统也有可能使用 heap_1。由于与非确定性、内存碎片和分配失败相关的不确定性，关键系统通常会禁止动态内存分配——但 Heap_1 始终是确定性的，并且不能对内存进行碎片化。</p>
<h3 id="heap-2-c"><a href="#heap-2-c" class="headerlink" title="heap_2.c"></a>heap_2.c</h3><p>Heap_2 保留在 FreeRTOS 发行版中以实现向后兼容性，但不建议将其用于新设计。考虑使用 heap_4 而不是 heap_2，因为 heap_4 提供了增强的功能。<br>Heap_2.c 还通过细分由 configTOTAL_HEAP_SIZE 标注的数组来工作。它使用最合适的算法来分配内存，并且与 heap_1 不同，它确实允许释放内存。同样，数组是静态声明的，因此即使在分配数组中的任何内存之前，应用程序也会消耗大量 RAM。<br>最佳拟合算法确保 pvPortMalloc() 使用大小最接近请求的字节数的空闲内存块。<br>Heap_2 适用于重复创建和删除任务的应用程序，前提是分配给创建的任务的堆栈大小不变。</p>
<h3 id="heap-3-c"><a href="#heap-3-c" class="headerlink" title="heap_3.c"></a>heap_3.c</h3><p>Heap_3.c 使用标准库 malloc() 和 free() 函数，因此堆的大小由链接器配置定义，configTOTAL_HEAP_SIZE 设置没有影响。<br>Heap_3 通过暂时挂起 FreeRTOS 调度程序使 malloc() 和 free() 线程安全。线程安全和调度程序暂停都是第 7 章资源管理中介绍的主题。</p>
<h3 id="heap-4-c"><a href="#heap-4-c" class="headerlink" title="heap_4.c"></a>heap_4.c</h3><p>与 heap_1 和 heap_2 一样，heap_4 通过将数组细分为更小的块来工作。和以前一样，数组是静态声明的，并由 configTOTAL_HEAP_SIZE 确定尺寸，因此即使在实际从数组中分配任何内存之前，应用程序也会消耗大量 RAM。<br>Heap_4 使用首次拟合算法来分配内存。与 heap_2 不同，heap_4 将相邻的空闲内存块组合（合并）成一个更大的块，从而最大限度地降低内存碎片的风险。<br>Heap_4 不是确定性的，但比 malloc() 和 free() 的大多数标准库实现要快。</p>
<h3 id="heap-5-c"><a href="#heap-5-c" class="headerlink" title="heap_5.c"></a>heap_5.c</h3><p>heap_5 用于分配和释放内存的算法与 heap_4 使用的算法相同。与 heap_4 不同，heap_5 不限于从单个静态声明的数组分配内存；heap_5 可以从多个独立的内存空间分配内存。<br>Heap_5 是当运行 FreeRTOS 的系统提供的 RAM 没有在系统的内存映射中显示为单个连续（没有空间）块时很有用。<br>heap_5 是唯一提供的内存分配方案，必须在调用 pvPortMalloc() 之前显式初始化。Heap_5 使用 vPortDefineHeapRegions() API 函数进行初始化。使用 heap_5 时，<br>必须先调用 vPortDefineHeapRegions()，然后才能创建任何内核对象（任务、队列、信号量等）。<br>vPortDefineHeapRegions() 用于指定每个单独的内存区域的起始地址和大小，这些区域共同构成 heap_5 使用的总内存。</p>
<h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><p>任务被实现为 C 函数。它们唯一的特别之处是它们的原型，它必须返回 void 并采用 void 指针参数。<br>void ATaskFunction( void *pvParameters );<br>每个任务本身就是一个小程序。它有一个入口点，通常会在无限循环中永远运行，并且不会退出。</p>
<p>一个应用程序可以包含许多任务。如果运行应用程序的处理器包含一个内核，那么在任何给定时间只能执行一个任务。这意味着任务可以以两种状态之一存在，运行和未运行。</p>
<h3 id="xTaskCreate-任务创建API函数"><a href="#xTaskCreate-任务创建API函数" class="headerlink" title="xTaskCreate() 任务创建API函数"></a>xTaskCreate() 任务创建API函数</h3><p>FreeRTOS V9.0.0 还包括 xTaskCreateStatic() 函数，该函数在编译时分配静态创建任务所需的内存：任务是使用 FreeRTOS xTaskCreate() API 函数创建的。<br>BaseType_t xTaskCreate(TaskFunction_t pvTaskCode,const char * const pcName, uint16_t usStackDepth, void *pvParameters, UBaseType_t uxPriority,TaskHandle_t *pxCreatedTask );</p>
<p>pvTaskCode 参数只是一个指向实现任务的函数的指针（实际上，只是函数的名称）。<br>pcName 任务的描述性名称。FreeRTOS 不以任何方式使用它。它纯粹是作为调试帮助而包含在内的。通过人类可读的名称识别任务比尝试通过句柄识别任务要简单得多。<br>usStackDepth 每个任务都有自己独特的堆栈，在创建任务时由内核分配给该任务。<br>usStackDepth 值告诉内核使堆栈有多大。该值指定堆栈可以容纳的字数，而不是字节数。例如，如果堆栈是 32 位宽，并且 usStackDepth 作为 100 传入，那么将分配 400 字节的堆栈空间（100 * 4 字节）。堆栈深度乘以堆栈宽度不得超过可包含在 uint16_t 类型变量中的最大值<br>pvParameters 任务函数接受指向 void ( void* ) 的指针类型参数。分配给 pvParameters 的值是传递给任务的值。<br>uxPriority 定义任务执行的优先级。优先级可以从最低优先级 0 分配到最高优先级 (configMAX_PRIORITIES – 1)。configMAX_PRIORITIES 是一个用户定义的常量，<br>pxCreatedTask 可用于传递正在创建的任务的句柄。然后，此句柄可用于引用 API 调用中的任务，例如更改任务优先级或删除任务。<br>如果您的应用程序没有使用任务句柄，则可以将 pxCreatedTask 设置为 NULL。</p>
<p>返回值</p>
<p>有两种可能的返回值：<br>pdPASS 这表明任务已成功创建。<br>pdFAIL 这表明该任务尚未创建，因为 FreeRTOS 没有足够的堆内存来分配足够的 RAM 来保存任务数据结构和堆栈。</p>
<h3 id="在-main-中创建多个任务实例"><a href="#在-main-中创建多个任务实例" class="headerlink" title="在 main() 中创建多个任务实例"></a>在 main() 中创建多个任务实例</h3><p>&#x2F;* 启动调度程序，以便任务开始执行。*&#x2F; vTaskStartScheduler();<br>在启动调度程序之前从 main() 中创建了两个任务。也可以从另一个任务中创建一个任务。</p>
<h3 id="在任务中创建新任务实例"><a href="#在任务中创建新任务实例" class="headerlink" title="在任务中创建新任务实例"></a>在任务中创建新任务实例</h3><p>&#x2F;* 如果此任务代码正在执行，那么调度程序必须已经启动。在进入无限循环之前创建另一个任务。*&#x2F;</p>
<h3 id="同一任务实现创建多个任务实例"><a href="#同一任务实现创建多个任务实例" class="headerlink" title="同一任务实现创建多个任务实例"></a>同一任务实现创建多个任务实例</h3><p>即使现在只有一个任务实现（vTaskFunction），也可以创建多个已定义任务的实例。每个创建的实例都将在 FreeRTOS 调度程序的控制下独立执行<br>利用pvParameters 任务参数实现相同任务程序调用，但不同功能和运行结果。</p>
<h2 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h2><p>xTaskCreate() API 函数的 uxPriority 参数为正在创建的任务分配初始优先级。在调度程序启动后，可以使用 vTaskPrioritySet() API 函数更改优先级。<br>可用优先级的最大数量由 FreeRTOSConfig.h 中应用程序定义的 configMAX_PRIORITIES 编译时配置常量设置。低数值优先级值表示低优先级任务，优先级 0 是可能的最低优先级。<br>因此，可用优先级的范围是 0 到 (configMAX_PRIORITIES – 1)。任意数量的任务可以共享相同的优先级——确保最大的设计灵活性。</p>
<p>FreeRTOS 调度程序可以使用两种方法之一来决定哪个任务将处于运行状态。configMAX_PRIORITIES 可以设置的最大值取决于使用的方法：</p>
<h3 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h3><p>通用方法在 C 中实现，可用于所有 FreeRTOS 架构端口。<br>如果在 FreeRTOSConfig.h 中将 configUSE_PORT_OPTIMISED_TASK_SELECTION 设置为 0，或者如果 configUSE_PORT_OPTIMISED_TASK_SELECTION 未定义，<br>或者如果通用方法是为正在使用的 FreeRTOS 端口提供的唯一方法，则将使用通用方法。</p>
<h3 id="架构优化方法"><a href="#架构优化方法" class="headerlink" title="架构优化方法"></a>架构优化方法</h3><p>架构优化的方法使用少量的汇编代码，并且比泛型方法更快。configMAX_PRIORITIES 设置不影响最坏情况的执行时间。<br>并非所有 FreeRTOS 端口都提供架构优化的方法。</p>
<p>FreeRTOS 调度程序将始终确保能够运行的最高优先级任务是选择进入运行状态的任务。在多个相同优先级的任务能够运行的情况下，调度程序将依次将每个任务转换为运行状态和退出运行状态。</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>实际运行的任务（使用处理时间）处于运行状态。在单核处理器上，在任何给定时间只能有一个任务处于运行状态。<br>实际未运行但既不处于 Blocked 状态也不处于 Suspended 状态的任务处于 Ready 状态。处于Ready 状态的任务可供调度程序选择作为进入Running 状态的任务。调度器会一直选择优先级最高的Ready状态任务进入Running状态。<br>任务可以在 Blocked 状态下等待事件，并在事件发生时自动移回 Ready 状态。时间事件发生在特定时间，例如，当块时间到期时，通常用于实现周期性或超时行为。当任务或中断服务例程使用任务通知、队列、事件组或多种类型的信号量之一发送信息时，会发生同步事件。它们通常用于表示异步活动，例如数据到达外围设备。</p>
<h3 id="配置调度算法"><a href="#配置调度算法" class="headerlink" title="配置调度算法"></a>配置调度算法</h3><p>调度算法是决定哪个就绪状态任务转换到运行状态的软件例程。<br>到目前为止，所有示例都使用了相同的调度算法，但可以使用 configUSE_PREEMPTION 和 configUSE_TIME_SLICING 配置常量更改该算法。这两个常量都在 FreeRTOSConfig.h 中定义。</p>
<p>第三个配置常量 configUSE_TICKLESS_IDLE 也会影响调度算法，因为它的使用会导致滴答中断在很长一段时间内完全关闭。configUSE_TICKLESS_IDLE 是一个高级选项，专门用于必须最小化功耗的应用程序。<br>configUSE_TICKLESS_IDLE 在第 10 章，低功耗支持中进行了描述。本节提供的描述假定 configUSE_TICKLESS_IDLE 设置为 0，如果未定义常量，这是默认设置</p>
<p>在所有可能的配置中，FreeRTOS 调度程序将确保选择共享优先级的任务依次进入运行状态。这种“轮流”政策通常被称为<br>作为“循环调度”。Round Robin调度算法不保证同等优先级的任务之间平均共享时间，只有同等优先级的Ready状态的任务会依次进入Running状态。</p>
<h4 id="带时间片的优先级抢先"><a href="#带时间片的优先级抢先" class="headerlink" title="带时间片的优先级抢先"></a>带时间片的优先级抢先</h4><p>configUSE_PREEMPTION      1<br>configUSE_TIME_SLICING    1<br>如果优先级高于运行状态任务的任务进入就绪状态，抢占式调度算法将立即“抢占”运行状态任务。被抢占意味着非自愿地（没有显式让步或阻塞）移出运行状态并进入就绪状态，以允许不同的任务进入运行状态<br>时间片用于在同等优先级的任务之间共享处理时间，即使这些任务没有明确地让出或进入阻塞状态。</p>
<p>如果存在与运行任务具有相同优先级的其他就绪状态任务，则描述为使用“时间片”的调度算法将在每个时间片结束时选择一个新任务进入运行状态。一次<br>slice 等于两个 RTOS 滴答中断之间的时间。</p>
<p>不使用时间片时的任务上下文切换比使用时间片时少。因此，关闭时间片可以减少调度程序的处理开销。但是，关闭时间片也可能导致同等优先级的任务接收的处理时间量大不相同，图29 展示了这种情况。因此，在没有时间片的情况下运行调度程序被认为是一种高级技术，仅应由以下人员使用有经验的用户。<br>configUSE_PREEMPTION      1<br>configUSE_TIME_SLICING    0</p>
<h4 id="合作调度"><a href="#合作调度" class="headerlink" title="合作调度"></a>合作调度</h4><p>configUSE_PREEMPTION      0<br>configUSE_TIME_SLICING    0&#x2F;1	</p>
<p>使用协同调度器时，只有在运行状态任务进入阻塞状态，或者运行状态任务通过调用taskYIELD()显式让步（手动请求重新调度）时才会发生上下文切换。任务永远不会被抢占，因此不能使用时间切片。</p>
<h3 id="时间片调度"><a href="#时间片调度" class="headerlink" title="时间片调度"></a>时间片调度</h3><p>调度算法，描述了一个称为“时间切片”的可选功能。到目前为止的示例中使用了时间片，并且是在它们产生的输出中观察到的行为。在示例中，两个任务都以相同的优先级创建，并且两个任务始终能够运行。<br>因此，每个任务执行一个“时间片”，在时间片开始时进入运行状态，在时间片结束时退出运行状态。<br>为了能够选择下一个要运行的任务，调度程序本身必须在每个时间片1结束时执行。为此目的使用称为“滴答中断”的周期性中断。时间片的长度由滴答中断频率有效设置，该频率由 FreeRTOSConfig.h 中应用程序定义的 configTICK_RATE_HZ 编译时间配置常量配置。<br>例如，如果 configTICK_RATE_HZ 设置为 100 (Hz)，则时间片将为 10 毫秒。两次滴答中断之间的时间称为“滴答周期”。一个时间片等于一个滴答周期。<br>“滴答计数”值是自调度程序启动以来发生的滴答中断的总数，假设滴答计数没有溢出。用户应用程序在指定延迟周期时不必考虑溢出，因为时间一致性由 FreeRTOS 内部管理。</p>
<p>需要注意的是，时间片的结束并不是调度器可以选择新任务运行的唯一地方；正如本书将展示的那样，调度程序还将在当前执行的任务进入阻塞状态后或当中断将更高优先级的任务移至就绪状态时立即选择一个新任务来运行。</p>
<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>调度程序将始终确保能够运行的最高优先级任务是选择进入运行状态的任务<br>调度程序将始终选择能够运行的最高优先级任务。任务 2 的优先级高于任务 1，并且始终能够运行；因此，任务 2 是唯一进入运行状态的任务。由于任务 1 永远不会进入运行状态，它永远不会打印出它的字符串。任务 1 被称为任务 2 的处理时间“饥饿”。</p>
<p>为了使任务有用，必须将它们重写为事件驱动。事件驱动的任务只有在触发它的事件发生后才能执行工作（处理），并且在该事件发生之前无法进入运行状态。</p>
<h4 id="封锁状态"><a href="#封锁状态" class="headerlink" title="封锁状态"></a>封锁状态</h4><p>正在等待事件的任务被称为处于“阻塞”状态，这是“未运行”状态的子状态。<br>任务可以进入 Blocked 状态以等待两种不同类型的事件：<br>时间（时间相关）事件——事件要么是延迟期到期，要么是达到的绝对时间。例如，一个任务可能会进入 Blocked 状态以等待 10 毫秒通过。<br>同步事件——事件源自另一个任务或中断。例如，任务可能进入阻塞状态以等待数据到达队列。同步事件涵盖了广泛的事件类型。<br>FreeRTOS 队列、二进制信号量、计数信号量、互斥体、递归互斥体、事件组和直接到任务通知都可用于创建同步事件<br>一个任务有可能阻塞一个有超时的同步事件，有效地同时阻塞这两种类型的事件。例如，一个任务可以选择等待一个<br>数据到达队列的最大时间为 10 毫秒。如果任一数据在 10 毫秒内到达，或 10 毫秒过去但没有数据到达，任务将离开阻塞状态。</p>
<h4 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h4><p>“暂停”也是未运行的子状态。处于 Suspended 状态的任务对调度程序不可用。进入挂起状态的唯一方法是调用 vTaskSuspend() API 函数，唯一的出路是调用 vTaskResume() 或 xTaskResumeFromISR() API 函数。大多数应用程序不使用挂起状态。</p>
<h4 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h4><p>处于 Not Running 状态但未被 Blocked 或 Suspended 的任务称为处于 Ready 状态。它们能够运行，因此“准备好”运行，但当前不处于运行状态。</p>
<h4 id="vTaskDelay"><a href="#vTaskDelay" class="headerlink" title="vTaskDelay()"></a>vTaskDelay()</h4><p>vTaskDelay() 将调用任务置于 Blocked 状态以进行固定数量的滴答中断。该任务在处于阻塞状态时不使用任何处理时间，因此该任务仅在实际有工作要做时才使用处理时间。<br>宏 pdMS_TO_TICKS() 可用于将以毫秒为单位的时间转换为以滴答为单位的时间。例如，调用 vTaskDelay(pdMS_TO_TICKS(100)) 将导致调用任务</p>
<p>保持阻塞状态 100 毫秒。</p>
<p>大多数时候没有应用程序任务可以运行（没有应用程序任务处于就绪状态），因此没有应用程序任务可以选择进入运行状态。在这种情况下，空闲任务将运行。分配给空闲的处理时间量是系统中空闲处理能力的量度。使用 RTOS 可以显着增加备用处理能力，只需让应用程序完全由事件驱动即可。</p>
<h4 id="vTaskDelayUntil"><a href="#vTaskDelayUntil" class="headerlink" title="vTaskDelayUntil( )"></a>vTaskDelayUntil( )</h4><p>使用 vTaskDelay() 并不能保证它们运行的​​频率是固定的，因为任务离开阻塞状态的时间与它们调用 vTaskDelay() 的时间有关。将任务转换为使用 vTaskDelayUntil() 而不是 vTaskDelay() 可以解决这个潜在问题。</p>
<p>void vTaskDelayUntil(TickType_t * pxPreviousWakeTime, TickType_t xTimeIncrement);</p>
<p>xLastWakeTime &#x3D; xTaskGetTickCount();<br>&#x2F;* xLastWakeTime 变量需要使用当前滴答计数进行初始化。请注意，这是唯一一次显式写入变量。在此之后 xLastWakeTime 在 vTaskDelayUntil() 中自动更新。*&#x2F;<br>for(;;)<br>{<br>&#x2F;* 这个任务应该每 250 毫秒准确地执行一次。根据 vTaskDelay() 函数，时间以滴答为单位测量，pdMS_TO_TICKS() 宏用于将毫秒转换为滴答。</p>
<p>xLastWakeTime 在 vTaskDelayUntil() 中自动更新，因此任务不会显式更新。*&#x2F;</p>
<p>vTaskDelayUntil(&amp;xLastWakeTime, pdMS_TO_TICKS(250));<br>}</p>
<h3 id="空闲任务和空闲任务挂钩"><a href="#空闲任务和空闲任务挂钩" class="headerlink" title="空闲任务和空闲任务挂钩"></a>空闲任务和空闲任务挂钩</h3><p>必须始终至少有一项任务可以进入运行状态1。为了确保这种情况，调度程序会在调用 vTaskStartScheduler() 时自动创建一个空闲任务。空闲任务只不过是在一个循环中，所以，就像最初的第一个示例中的任务一样，它总是能够运行。</p>
<p>空闲任务具有尽可能低的优先级（优先级为零），以确保它永远不会阻止更高优先级的应用程序任务进入运行状态。</p>
<p>可以通过使用空闲钩子（或空闲回调）函数将特定于应用程序的功能直接添加到空闲任务中，该函数在空闲任务循环的每次迭代中由空闲任务自动调用一次。<br>空闲任务挂钩的常见用途包括：</p>
<p>执行低优先级、后台或连续处理功能。<br>衡量备用处理能力的数量。（只有在所有更高优先级的应用程序任务都没有工作要执行时，空闲任务才会运行；因此，测量分配给空闲任务的处理时间量可以清楚地表明有多少处理时间是空闲的。）<br>将处理器置于低功耗模式，在无需执行应用程序处理时提供一种简单且自动的节能方法（尽管使用此方法可实现的节能低于使用刻度线可实现的节能）少空闲模式在第 10 章，低功耗支持中描述）。</p>
<p>空闲任务挂钩函数绝不能尝试阻塞或挂起。<br>&#x2F;* 声明一个将由钩子函数递增的变量。*&#x2F; volatile uint32_t ulIdleCycleCount &#x3D; 0UL;</p>
<p>&#x2F;* 空闲钩子函数必须调用 vApplicationIdleHook()，不带参数，并返回 void。*&#x2F;<br>void vApplicationIdleHook（void）<br>{<br>&#x2F;* 这个钩子函数只增加一个计数器。*&#x2F; ulIdleCycleCount++;<br>}<br>configUSE_IDLE_HOOK 必须在 FreeRTOSConfig.h 中设置为 1 才能调用空闲挂钩函数</p>
<h3 id="更改任务"><a href="#更改任务" class="headerlink" title="更改任务"></a>更改任务</h3><p>vTaskPrioritySet() API 函数可用于在调度程序启动后更改任何任务的优先级。请注意，仅当 FreeRTOSConfig.h 中的 INCLUDE_vTaskPrioritySet 设置为 1 时，vTaskPrioritySet() API 函数才可用。<br>任务可以通过传递 NULL 代替有效的任务句柄来更改自己的优先级。</p>
<p>uxTaskPriorityGet() API 函数可用于查询任务的优先级。请注意，仅当 FreeRTOSConfig.h 中的 INCLUDE_uxTaskPriorityGet 设置为 1 时，uxTaskPriorityGet() API 函数才可用。<br>任务可以通过传递 NULL 代替有效的任务句柄来查询自己的优先级。</p>
<p>任务可以使用 vTaskDelete() API 函数通过传递 NULL 来删除自身或任何其他任务。请注意，vTaskDelete() API 函数仅在 FreeRTOSConfig.h 中的 INCLUDE_vTaskDelete 设置为 1 时可用。<br>已删除的任务不再存在，无法再次进入运行状态。</p>
<p>空闲任务负责释放分配给已被删除的任务的内存。因此，使用 vTaskDelete() API 函数的应用程序不要完全饿死所有处理时间的空闲任务，这一点很重要。</p>
<p>任务 1 运行并创建任务 2。任务 2 立即开始运行，因为它具有更高的优先级</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>“队列”提供任务到任务、任务到中断和中断到任务的通信机制。<br>FreeRTOS 通过复制方法使用队列。复制排队意味着发送到队列的数据被逐字节复制到队列中。<br>复制队列不会阻止队列也被用于引用队列。例如，当排队数据的大小使得将数据复制到队列中变得不切实际时，可以将指向数据的指针复制到队列中。</p>
<p>队列本身就是对象，任何知道它们存在的任务或 ISR 都可以访问这些对象。任意数量的任务可以写入同一个队列，任意数量的任务可以从同一个队列中读取。</p>
<h3 id="阻塞队列读取-写入"><a href="#阻塞队列读取-写入" class="headerlink" title="阻塞队列读取&#x2F;写入"></a>阻塞队列读取&#x2F;写入</h3><p>当任务尝试从队列中读取时，它可以选择指定一个“阻塞”时间。如果队列已经为空，这是任务将保持在阻塞状态以等待队列中可用数据的时间。处于阻塞状态的任务正在等待队列中的数据可用，当另一个任务或中断将数据放入队列时，它会自动移动到就绪状态。如果指定的阻塞时间在数据可用之前到期，任务也将自动从阻塞状态移动到就绪状态。<br>队列可以有多个读取器，因此单个队列可能会阻止多个任务在其上等待数据。在这种情况下，当数据可用时，只有一个任务会被解除阻塞。未阻塞的任务将始终是等待数据的最高优先级任务。如果阻塞的任务具有相同的优先级，则等待数据时间最长的任务将被解除阻塞。</p>
<p>就像从队列中读取一样，任务在写入队列时可以选择指定阻塞时间。在这种情况下，阻塞时间是任务应该保持在阻塞状态以等待队列上可用空间的最长时间，如果队列已经满的话。<br>队列可以有多个写入者，因此一个完整的队列可能会阻止多个任务在其上等待完成发送操作。在这种情况下，当队列上的空间可用时，只有一个任务会被解除阻塞。未阻塞的任务将始终是等待空间的最高优先级任务。如果阻塞的任务具有相同的优先级，则等待空间时间最长的任务将被解除阻塞。</p>
<h3 id="使用队列"><a href="#使用队列" class="headerlink" title="使用队列"></a>使用队列</h3><p>xQueueCreate() API函数 QueueHandle_t xQueueCreate(UBaseType_t uxQueueLength, UBaseType_t uxItemSize);<br>队列必须先显式创建，然后才能使用。<br>队列由句柄引用，句柄是 QueueHandle_t 类型的变量。xQueueCreate() API 函数创建一个队列并返回一个引用它创建的队列的 QueueHandle_t。</p>
<p>FreeRTOS V9.0.0 还包括 xQueueCreateStatic() 函数，该函数在编译时分配静态创建队列所需的内存：FreeRTOS 在创建队列时从 FreeRTOS 堆分配 RAM。RAM 用于保存队列数据结构和队列中包含的项目。如果没有足够的堆 RAM 可用于创建队列，xQueueCreate() 将返回 NULL。<br>uxQueueLength   正在创建的队列在任何时候可以容纳的最大项目数。<br>uxItemSize      可以存储在队列中的每个数据项的大小（以字节为单位）。<br>返回值          如果返回 NULL，则无法创建队列，因为 FreeRTOS 没有足够的堆内存来分配队列数据结构和存储区域。</p>
<p>创建队列后，可以使用 xQueueReset() API 函数将队列返回到其原始空状态。</p>
<p>第一个参数是数据发送到的队列。队列是在调度程序启动之前创建的，</p>
<h4 id="xQueueSend-API函数"><a href="#xQueueSend-API函数" class="headerlink" title="xQueueSend() API函数"></a>xQueueSend() API函数</h4><p>xQueueSendToBack() 和 xQueueSendToFront() API函数<br>xQueueSendToBack() 用于将数据发送到队列的后端（尾部），而 xQueueSendToFront() 用于将数据发送到队列的前端（头部）。<br>与 xQueueSendToBack() 等价并且完全相同</p>
<p>BaseType_t xQueueSendToBack(QueueHandle_t xQueue, const void * pvItemToQueue, TickType_t xTicksToWait );</p>
<p>xQueue        正在向其发送（写入）数据的队列句柄。队列句柄将从用于创建队列的 xQueueCreate() 调用中返回。<br>pvItemToQueue 指向要复制到队列中的数据的指针。队列可以容纳的每个项目的大小是在队列被设置时设置的创建，所以这么多字节将从 pvItemToQueue 复制到队列存储区。<br>xTicksToWait  如果队列已满，任务应保持在 Blocked 状态以等待队列上可用空间的最长时间。块时间以滴答周期指定，因此它所代表的绝对时间取决于滴答频率。宏 pdMS_TO_TICKS() 可用于将以毫秒为单位的时间转换为以滴答为单位的时间。<br>              将 xTicksToWait 设置为 portMAX_DELAY 将导致任务无限期等待（不会超时），前提是在 FreeRTOSConfig.h 中将 INCLUDE_vTaskSuspend 设置为 1。</p>
<p>返回值 有两种可能的返回值：<br>       仅当数据成功发送到队列时才会返回 pdPASS。<br>       如果指定了阻塞时间（xTicksToWait 不为零），那么调用任务可能被置于阻塞状态，等待队列中的空间可用，然后函数返回，但数据已成功写入在块时间到期之前排队。</p>
<pre><code>   如果由于队列已满而无法将数据写入队列，则将返回 errQUEUE_FULL。如果指定了阻塞时间（xTicksToWait 不为零），则调用任务将被置于阻塞状态以等待另一个任务或中断以在队列中腾出空间，但是指定的块时间在此之前到期。
</code></pre>
<p>注意：切勿从中断服务例程调用 xQueueSendToFront() 或 xQueueSendToBack()。应使用中断安全版本 xQueueSendToFrontFromISR() 和 xQueueSendToBackFromISR() 代替它们。</p>
<h4 id="xQueueReceive-API函数"><a href="#xQueueReceive-API函数" class="headerlink" title="xQueueReceive() API函数"></a>xQueueReceive() API函数</h4><p>xQueueReceive() 用于从队列中接收（读取）项目。收到的项目将从队列中删除。</p>
<p>注意：切勿从中断服务程序调用 xQueueReceive()。第 6 章描述了中断安全的 xQueueReceiveFromISR() API 函数。</p>
<p>BaseType_t    xQueueReceive(QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait );<br>xQueue        从中接收（读取）数据的队列句柄。队列句柄将从用于创建队列的 xQueueCreate() 调用中返回。<br>pvBuffer      指向将接收到的数据复制到其中的内存的指针。队列保存的每个数据项的大小是在创建队列时设置的。pvBuffer 指向的内存必须至少大到足以容纳那么多字节。<br>xTicksToWait  如果队列已经为空，任务应保持在 Blocked 状态以等待队列上可用的数据的最长时间。如果 xTicksToWait 为零，则如果队列已经为空，则 xQueueReceive() 将立即返回。<br>              块时间以滴答周期指定，因此它所代表的绝对时间取决于滴答频率。宏 pdMS_TO_TICKS() 可用于将以毫秒为单位的时间转换为以滴答为单位的时间。<br>              将 xTicksToWait 设置为 portMAX_DELAY 将导致任务等待 如果在 FreeRTOSConfig.h 中将 INCLUDE_vTaskSuspend 设置为 1，则无限期（无超时）。</p>
<p>返回值 有两种可能的返回值：<br>只有从队列中成功读取数据时，才会返回 pdPASS。<br>如果指定了阻塞时间（xTicksToWait 不为零），则调用任务可能被置于阻塞状态，以等待队列中的数据可用，但在阻塞时间之前已成功从队列中读取数据已到期。<br>如果由于队列已经为空而无法从队列中读取数据，则将返回 errQUEUE_EMPTY。<br>如果指定了阻塞时间（xTicksToWait 不为零），则调用任务将被置于阻塞状态以等待另一个任务或中断向队列发送数据，但阻塞时间在此之前已过期。</p>
<h3 id="uxQueueMessagesWaiting-API函数"><a href="#uxQueueMessagesWaiting-API函数" class="headerlink" title="uxQueueMessagesWaiting() API函数"></a>uxQueueMessagesWaiting() API函数</h3><p> 用于查询当前队列中的项目数。</p>
<p>UBaseType_t uxQueueMessagesWaiting(QueueHandle_t xQueue);</p>
<p>返回值 正在查询的队列当前持有的项目数。如果返回零，则队列为空。</p>
<p>接收任务具有最高优先级，因此队列永远不会包含超过一项。这是因为一旦数据被放入队列，接收任务就会抢占发送任务。<br>发送任务具有较高的优先级，因此队列通常会被填满。这是因为，一旦接收任务从队列中删除一个项目，它就会被其中一个发送任务抢占，然后立即重新填充队列。然后发送任务重新进入阻塞状态以等待队列中的空间再次可用。</p>
<h3 id="处理大型或可变大小的数据"><a href="#处理大型或可变大小的数据" class="headerlink" title="处理大型或可变大小的数据"></a>处理大型或可变大小的数据</h3><p>排队指针<br>如果存储在队列中的数据很大，那么最好使用队列来传递指向数据的指针，而不是逐字节地将数据本身复制到队列中和从队列中取出。传输指针在处理时间和创建队列所需的 RAM 量方面都更有效。<br>但是，在对指针进行排队时，必须格外小心以确保：</p>
<ol>
<li>所指向的 RAM 的所有者已明确定义。<br>通过指针在任务之间共享内存时，必须确保两个任务不会同时修改内存内容，或采取任何其他可能导致内存内容无效或不一致的操作。理想情况下，应该只允许发送任务访问内存，直到指向内存的指针被排队，并且在从队列中接收到指针之后，应该只允许接收任务访问内存。</li>
<li>指向的 RAM 仍然有效。<br>如果指向的内存是动态分配的，或者是从预先分配的缓冲区池中获得的，那么只有一个任务应该负责释放内存。在内存被释放后，任何任务都不应尝试访问内存。<br>永远不应使用指针来访问已在任务堆栈上分配的数据。堆栈帧更改后数据将无效</li>
</ol>
<p>两种强大的设计模式；将结构发送到队列，并将指针发送到队列。结合这些技术，任务可以使用单个队列从任何数据源接收任何数据类型。FreeRTOS+TCP TCP&#x2F;IP 堆栈的实现提供了如何实现这一点的实际示例。</p>
<h3 id="多个队列"><a href="#多个队列" class="headerlink" title="多个队列"></a>多个队列</h3><p>通常应用程序设计需要单个任务来接收不同大小的数据、不同含义的数据以及来自不同来源的数据。上一节演示了如何使用接收结构的单个队列以简洁有效的方式实现这一点。但是，有时应用程序的设计者会处理限制其设计选择的约束，<br>因此需要为某些数据源使用单独的队列。例如，集成到设计中的第三方代码可能假定存在专用队列。在这种情况下，可以使用“队列集”。<br>队列集允许任务从多个队列接收数据，而无需任务依次轮询每个队列以确定哪个队列（如果有）包含数据。<br>与使用接收结构的单个队列实现相同功能的设计相比，使用队列集从多个源接收数据的设计不太整洁，效率也较低。出于这个原因，建议仅在设计约束使其绝对必要时才使用队列集。</p>
<p>通过在 FreeRTOSConfig.h 中将 configUSE_QUEUE_SETS 编译时配置常量设置为 1 来启用队列集功能。</p>
<h4 id="xQueueCreateSet-API函数队列集必须在使用前显式创建。"><a href="#xQueueCreateSet-API函数队列集必须在使用前显式创建。" class="headerlink" title="xQueueCreateSet() API函数队列集必须在使用前显式创建。"></a>xQueueCreateSet() API函数队列集必须在使用前显式创建。</h4><p>队列集由句柄引用，句柄是 QueueSetHandle_t 类型的变量。xQueueCreateSet() API 函数创建一个队列集并返回一个引用它创建的队列集的 QueueSetHandle_t。</p>
<p>QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength );</p>
<p>uxEventQueueLength 当作为队列集合成员的队列接收数据时，接收队列的句柄将发送到队列集合。uxEventQueueLength 定义了正在创建的队列集在任何时候可以容纳的最大队列句柄数<br>信号量也可以添加到队列集中。作为另一个示例，如果队列集包含长度为 3 的队列和二进制信号量（长度为 1），则 uxEventQueueLength 必须设置为 4（三加一）。</p>
<p>返回值 如果返回 NULL，则无法创建队列集，因为 FreeRTOS 没有足够的堆内存来分配队列集数据结构和存储区域。<br>返回非 NULL 值表示已成功创建队列集。返回的值应存储为已创建队列集的句柄。</p>
<h4 id="xQueueAddToSet-API函数-将队列或信号量添加到队列集。"><a href="#xQueueAddToSet-API函数-将队列或信号量添加到队列集。" class="headerlink" title="xQueueAddToSet() API函数 将队列或信号量添加到队列集。"></a>xQueueAddToSet() API函数 将队列或信号量添加到队列集。</h4><p>BaseType_t xQueueAddToSet(QueueSetMemberHandle_t xQueueOrSemaphore,QueueSetHandle_t xQueueSet );</p>
<p>xQueueOrSemaphore 正在添加到队列集中的队列或信号量的句柄。 队列句柄和信号量句柄都可以转换为 QueueSetMemberHandle_t 类型。<br>xQueueSet         要添加队列或信号量的队列集的句柄。</p>
<p>返回值 有两种可能的返回值：<br>仅当队列或信号量成功添加到队列集中时，才会返回 pdPASS。<br>如果无法将队列或信号量添加到队列集中，将返回 pdFAIL。<br>队列和二进制信号量只有在它们为空时才能添加到集合中。计数信号量只能在计数为零时添加到集合中。队列和信号量一次只能是一组的成员。</p>
<h4 id="xQueueSelectFromSet-API函数"><a href="#xQueueSelectFromSet-API函数" class="headerlink" title="xQueueSelectFromSet() API函数"></a>xQueueSelectFromSet() API函数</h4><p>xQueueSelectFromSet() 从队列集中读取队列句柄。<br>当作为集合成员的队列或信号量接收数据时，接收队列或信号量的句柄被发送到队列集合，并在任务调用 xQueueSelectFromSet() 时返回。如果从对 xQueueSelectFromSet() 的调用中返回句柄，则该句柄引用的队列或信号量已知包含数据，调用任务必须直接从队列或信号量中读取。<br>注意：不要从作为集合成员的队列或信号量中读取数据，除非队列或信号量的句柄首先从对 xQueueSelectFromSet() 的调用中返回。每次调用 xQueueSelectFromSet() 返回队列句柄或信号量句柄时，仅从队列或信号量中读取一项。</p>
<p>QueueSetMemberHandle_t xQueueSelectFromSet(QueueSetHandle_t xQueueSet,const TickType_t xTicksToWait );<br>xQueueSet    正在接收（读取）队列句柄或信号量句柄的队列集的句柄。队列集句柄将从对用于创建队列集的 xQueueCreateSet() 的调用中返回。<br>xTicksToWait 如果集合中的所有队列和信号量都为空，则调用任务应保持在阻塞状态以等待从队列集中接收队列或信号量句柄的最长时间。<br>返回值       非 NULL 的返回值将是已知包含数据的队列或信号量的句柄。如果指定了阻塞时间（xTicksToWait 不为零），则调用任务可能被置于阻塞状态以等待数据从集合中的队列或信号量中可用，但已成功读取句柄在块时间到期之前设置的队列。<br>句柄作为 QueueSetMemberHandle_t 类型返回，该类型可以转换为 QueueHandle_t 类型或 SemaphoreHandle_t 类型。<br>如果返回值为 NULL，则无法从队列集中读取句柄。如果指定了阻塞时间（xTicksToWait 不为零），则调用任务将被置于阻塞状态以等待另一个任务或中断将数据发送到集合中的队列或信号量，但阻塞时间在此之前到期发生了。</p>
<h3 id="使用队列创建邮箱"><a href="#使用队列创建邮箱" class="headerlink" title="使用队列创建邮箱"></a>使用队列创建邮箱</h3><p>嵌入式社区内的术语没有达成共识，“邮箱”在不同的 RTOS 中意味着不同的东西。在本书中，术语邮箱用于指代长度为 1 的队列。队列可能因其在应用程序中的使用方式而被描述为邮箱，而不是因为它与队列在功能上有所不同：<br>队列用于将数据从一个任务发送到另一个任务，或从中断服务程序发送到任务。发送者将一个项目放入队列，接收者从队列中移除该项目。数据通过队列从发送方传递到接收方。</p>
<p>邮箱用于保存可由任何任务或任何中断服务程序读取的数据。数据不通过邮箱，而是保留在邮箱中，直到被覆盖。发件人覆盖邮箱中的值。接收者从邮箱中读取值，但不从邮箱中删除值。</p>
<p>&#x2F;* 邮箱是一个队列，所以它的句柄存储在一个 QueueHandle_t 类型的变量中。*&#x2F;<br>QueueHandle_t xMailbox；</p>
<p>&#x2F;* 创建将用作邮箱的队列。队列的长度为 1 以允许它与 xQueueOverwrite() API 函数一起使用，如下所述。*&#x2F;<br>xMailbox &#x3D; xQueueCreate(1, sizeof(Example_t));</p>
<h4 id="xQueueOverwrite-API函数"><a href="#xQueueOverwrite-API函数" class="headerlink" title="xQueueOverwrite() API函数"></a>xQueueOverwrite() API函数</h4><p>与 xQueueSendToBack() API 函数一样，xQueueOverwrite() API 函数将数据发送到队列。与 xQueueSendToBack() 不同，如果队列已满，则 xQueueOverwrite() 将覆盖已在队列中的数据。<br>xQueueOverwrite() 只能用于长度为 1 的队列。如果队列已满，该限制避免了函数的实现需要任意决定要覆盖队列中的哪个项目。<br>注意：切勿从中断服务程序调用 xQueueOverwrite()。应使用中断安全版本 xQueueOverwriteFromISR() 代替它。</p>
<p>BaseType_t xQueueOverwrite(QueueHandle_t xQueue, const void * pvItemToQueue);<br>xQueue        正在向其发送（写入）数据的队列句柄。队列句柄将从用于创建队列的 xQueueCreate() 调用中返回。<br>pvItemToQueue 指向要复制到队列中的数据的指针。 队列可以容纳的每个项目的大小是在创建队列时设置的，因此会从 pvItemToQueue 将这么多字节复制到队列存储区中。</p>
<p>返回值        即使队列已满，xQueueOverwrite() 也会写入队列，因此 pdPASS 是唯一可能的返回值。</p>
<h4 id="xQueuePeek-API函数"><a href="#xQueuePeek-API函数" class="headerlink" title="xQueuePeek() API函数"></a>xQueuePeek() API函数</h4><p>xQueuePeek() 用于从队列中接收（读取）项目，而不会从队列中删除该项目。xQueuePeek() 从队列头部接收数据，不修改队列中存储的数据，也不修改队列中数据的存储顺序。<br>注意：切勿从中断服务程序调用 xQueuePeek()。应使用中断安全版本 xQueuePeekFromISR() 代替它。</p>
<p>使用无限阻塞时间，因此无需检查从 xQueuePeek() 返回的值，因为 xQueuePeek() 仅在数据可用时才会返回。*&#x2F; xQueuePeek(xMailbox, pxData, portMAX_DELAY);</p>
<h3 id="软件定时器管理"><a href="#软件定时器管理" class="headerlink" title="软件定时器管理"></a>软件定时器管理</h3><p>软件定时器用于在未来的设定时间安排功能的执行，或以固定的频率定期执行。软件定时器执行的函数称为软件定时器的回调函数。‌<br>软件定时器由 FreeRTOS 内核实现并受其控制。它们不需要硬件支持，并且与硬件定时器或硬件计数器无关。</p>
<p>软件定时器功能是可选的。要包括软件定时器功能：<br>构建 FreeRTOS 源文件 FreeRTOS&#x2F;Source&#x2F;timers.c 作为项目的一部分.<br>在 FreeRTOSConfig.h 中将 configUSE_TIMERS 设置为 1。</p>
<p>RTOS 守护进程（定时器服务）任务<br>所有软件定时器回调函数都在同一个 RTOS 守护进程（或“定时器服务”）任务1的上下文中执行.<br>守护程序任务是在调度程序启动时自动创建的标准 FreeRTOS 任务。它的优先级和堆栈大小分别由 configTIMER_TASK_PRIORITY 和 configTIMER_TASK_STACK_DEPTH 编译时配置常量设置。这两个常量都在 FreeRTOSConfig.h 中定义。<br>软件定时器回调函数不得调用会导致调用任务进入阻塞状态的 FreeRTOS API 函数，否则会导致守护任务进入阻塞状态。</p>
<p>软件计时器 API 函数将命令从调用任务发送到称为“计时器命令队列”的队列上的守护程序任务。如图41 所示。命令示例包括“启动计时器”、“停止计时器”和“重置计时器”。<br>定时器命令队列是一个标准的 FreeRTOS 队列，它在调度程序启动时自动创建。定时器命令队列的长度由 FreeRTOSConfig.h 中的 configTIMER_QUEUE_LENGTH 编译时间配置常量设置。</p>
<p>该任务曾经被称为“定时器服务任务”，因为它最初只用于执行软件定时器回调函数。现在，同样的任务也用于其他目的，因此它以更通用的名称“RTOS 守护程序任务”而闻名。</p>
<p>守护进程任务调度<br>守护程序任务与任何其他 FreeRTOS 任务一样安排；当它是能够运行的最高优先级任务时，它只会处理命令或执行计时器回调函数。</p>
<ol>
<li>调用 xTimerStart() 的任务优先级为高于守护任务的优先级<br>如果命令被发送到定时器命令队列，守护任务将离开阻塞状态，在这种情况下它将处理命令，或者如果软件定时器到期，在这种情况下它将执行软件定时器的回调函数。<br>正在启动的软件计时器将到期的时间是从“启动计时器”命令发送到计时器命令队列的时间计算的-它不是从守护程序任务收到“启动计时器”的时间计算的来自定时器命令队列的命令。</li>
</ol>
<p>2.调用 xTimerStart() 的任务的优先级为低于守护任务的优先级<br>xTimerStart() 向定时器命令队列发送命令，导致守护任务离开阻塞状态。daemon任务的优先级高于Task 1的优先级，所以调度器选择daemon任务作为进入Running状态的任务。</p>
<h4 id="创建和启动软件计时器"><a href="#创建和启动软件计时器" class="headerlink" title="创建和启动软件计时器"></a>创建和启动软件计时器</h4><p>软件计时器必须在使用之前显式创建。<br>软件定时器由 TimerHandle_t 类型的变量引用。xTimerCreate() 用于创建软件定时器并返回 TimerHandle_t 以引用它创建的软件定时器。软件计时器在休眠状态下创建。<br>pvTimerID 每个软件定时器都有一个 ID 值。ID 是一个空指针，应用程序编写者可以将其用于任何目的。当多个软件定时器使用相同的回调函数时，ID 特别有用，因为它可用于提供定时器特定的存储。本章中的示例演示了计时器 ID 的使用。<br>pvTimerID 为正在创建的任务的 ID 设置初始值</p>
<p>xTimerStart() 用于启动处于休眠状态的软件定时器，或复位（重新启动）处于运行状态的软件定时器。xTimerStop() 用于停止处于运行状态的软件定时器。停止软件定时器与将定时器转换为休眠状态相同。<br>BaseType_t    xTimerStart(TimerHandle_t xTimer, TickType_t xTicksToWait);<br>xTicksToWait  如果在调度程序启动之前调用 xTimerStart()，则忽略 xTicksToWait 的值，xTimerStart() 的行为就像xTicksToWait 已设置为零。</p>
<p>每个软件定时器都有一个 ID，它是一个标签值，应用程序编写者可以将其用于任何目的。ID 存储在 void 指针 (void *) 中，因此可以直接存储整数值，指向任何其他对象，或用作函数指针。<br>创建软件定时器时，会为 ID 分配一个初始值，之后可以使用 vTimerSetTimerID() API 函数更新 ID，并使用 pvTimerGetTimerID() API 函数进行查询。<br>与其他软件定时器 API 函数不同，vTimerSetTimerID() 和 pvTimerGetTimerID() 直接访问软件定时器——它们不向定时器命令队列发送命令。</p>
<h4 id="软件定时器回调函数"><a href="#软件定时器回调函数" class="headerlink" title="软件定时器回调函数"></a>软件定时器回调函数</h4><p>软件定时器回调函数作为 C 函数实现。它们的唯一特别之处是它们的原型，它必须返回 void，并将软件计时器的句柄作为其唯一参数。回调函数原型如清单 72 所示。<br>v同一个回调函数可以分配给多个软件定时器。完成后，回调函数参数用于确定哪个软件计时器到期。</p>
<p>void ATimerCallback(TimerHandle_t xTimer);<br>软件定时器回调函数从头到尾执行，并以正常方式退出。它们应该保持简短，并且不得进入 Blocked 状态。</p>
<p>注意：正如将要看到的，软件定时器回调函数在 FreeRTOS 调度程序启动时自动创建的任务的上下文中执行。<br>因此，软件定时器回调函数绝对不能调用 FreeRTOS API 函数，这将导致调用任务进入阻塞状态。</p>
<p>正如将要看到的，软件定时器回调函数在 FreeRTOS 调度程序启动时自动创建的任务的上下文中执行。因此，软件定时器回调函数绝对不能调用 FreeRTOS API 函数，这将导致调用任务进入阻塞状态。<br>可以调用xQueueReceive()等函数，但前提是函数的xTicksToWait参数（指定函数的阻塞时间）设置为0。不可以调用vTaskDelay()等函数，调用vTaskDelay()将始终将调用任务置于阻塞状态。</p>
<p>软件定时器<br>软件定时器的“周期”是软件定时器启动和软件定时器回调函数执行之间的时间。<br>一次性和自动重新加载计时器<br>一次性计时器<br>一旦启动，一次性计时器将只执行一次其回调函数。一次性计时器可以手动重新启动，但不会自行重新启动。<br>自动重新加载计时器<br>一旦启动，自动重载计时器将在每次到期时重新启动，从而定期执行其回调函数。</p>
<h4 id="更改定时器"><a href="#更改定时器" class="headerlink" title="更改定时器"></a>更改定时器</h4><p>使用 xTimerChangePeriod() 函数更改软件定时器的周期。<br>如果 xTimerChangePeriod() 用于更改已经运行的计时器的周期，则计时器将使用新的周期值重新计算其到期时间。重新计算的到期时间与调用 xTimerChangePeriod() 的时间有关，与最初启动计时器的时间无关。<br>切勿从中断服务程序调用 xTimerChangePeriod()。应使用中断安全版本 xTimerChangePeriodFromISR() 代替它。</p>
<p>复位软件定时器意味着重新启动定时器；计时器的到期时间被重新计算为相对于计时器重置的时间，而不是计时器最初启动的时间。<br>使用 xTimerReset() API 函数重置计时器。xTimerReset() 也可用于启动处于休眠状态的计时器。<br>注意：切勿从中断服务程序调用 xTimerReset()。应使用中断安全版本 xTimerResetFromISR() 代替它。</p>
<h3 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h3><p>嵌入式实时系统必须采取行动来响应源自环境的事件。例如，到达以太网外围设备的数据包（事件）可能需要传递到 TCP&#x2F;IP 堆栈进行处理（操作）。重要的系统必须为来自多个源的事件提供服务，所有这些都将具有不同的处理开销和响应时间要求。在每种情况下，都必须对最佳事件处理实施策略做出判断：<br>应该如何检测事件？通常使用中断，但也可以轮询输入。<br>使用中断时，中断服务程序（ISR）内部应该执行多少处理，外部执行多少？通常希望使每个 ISR 尽可能短。<br>事件如何传达给主（非 ISR）代码，以及如何构建此代码以最好地适应潜在异步事件的处理？<br>FreeRTOS 不会对应用程序设计者强加任何特定的事件处理策略，但确实提供了允许以简单且可维护的方式实现所选策略的功能。</p>
<p>虽然是用软件编写的，但中断服务程序是一种硬件功能，因为硬件控制着哪个中断服务程序将运行以及何时运行。任务只有在没有 ISR 运行时才会运行，因此最低优先级的中断会中断最高优先级的任务，任务无法抢占 ISR。<br>注意：切勿从 ISR 调用名称中没有“FromISR”的 FreeRTOS API 函数。</p>
<p>通常认为最好的做法是使 ISR 尽可能短。原因包括：<br>即使任务被分配了非常高的优先级，它们也只会在硬件没有处理中断的情况下运行,中断所需的任何其他处理通常可以在任务中执行，从而允许中断服务程序尽可能快地退出。这称为“延迟中断处理”，因为中断所需的处理从 ISR“延迟”到任务。</p>
<p>如果中断处理对时间要求特别严格，则可以设置延迟处理任务的优先级，以确保该任务始终抢占系统中的其他任务。然后可以实现 ISR 以包括对 portYIELD_FROM_ISR() 的调用，确保 ISR 直接返回到中断处理被推迟到的任务。这具有确保整个事件处理在时间上连续（无中断）执行的效果，就像它已经在 ISR 本身内实现一样。</p>
<h4 id="二进制信号量用于将中断处理“推迟”到任务"><a href="#二进制信号量用于将中断处理“推迟”到任务" class="headerlink" title="二进制信号量用于将中断处理“推迟”到任务"></a>二进制信号量用于将中断处理“推迟”到任务</h4><p>BaseType_t xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore, BaseType_t *pxHigherPriorityTaskWoken );<br>pxHigherPriorityTaskWoken  单个信号量可能会阻止一个或多个任务在其上等待信号量可用。调用 xSemaphoreGiveFromISR() 可以使信号量可用，从而导致等待信号量的任务离开阻塞状态。如果调用 xSemaphoreGiveFromISR() 导致任务离开阻塞状态，并且未阻塞任务的优先级高于当前正在执行的任务（被中断的任务），则在内部，xSemaphoreGiveFromISR() 会将 *pxHigherPriorityTaskWoken 设置为 pdTRUE。<br>如果 xSemaphoreGiveFromISR() 将此值设置为 pdTRUE，则通常应在退出中断之前执行上下文切换。这将确保中断直接返回到最高优先级的就绪状态任务.</p>
<p>如果 portYIELD_FROM_ISR() xHigherPriorityTaskWoken 参数为 pdFALSE（零），则不请求上下文切换，并且宏不起作用。如果 portYIELD_FROM_ISR() xHigherPriorityTaskWoken 参数不是 pdFALSE，则请求上下文切换，并且处于运行状态的任务可能会更改。</p>
<p>static uint32_t ulExampleInterruptHandler( void )<br>{<br>    BaseType_t xHigherPriorityTaskWoken;</p>
<pre><code>xHigherPriorityTaskWoken = pdFALSE;

xSemaphoreGiveFromISR( xBinarySemaphore, &amp;xHigherPriorityTaskWoken );

portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
</code></pre>
<p>}</p>
<p>仅当中断以相对较低的频率发生时，示例中使用的任务结构才足够。<br>实际应用中，中断是由硬件产生的，并且发生在不可预知的时间。因此，为了尽量减少错过中断的机会，延迟中断处理任务的结构必须使其能够处理在每次调用 xSemaphoreTake().</p>
<h4 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h4><p>正如二进制信号量可以被认为是长度为 1 的队列一样，计数信号量也可以被认为是长度大于 1 的队列。任务对存储在队列中的数据不感兴趣——只对队列中的项目数感兴趣。configUSE_COUNTING_SEMAPHORES 必须在 FreeRTOSConfig.h 中设置为 1，以便计数信号量可用。<br>每次“给定”计数信号量时，都会使用其队列中的另一个空间。队列中的项目数是信号量的“计数”值。<br>计数信号量通常用于两件事：<br>1计数事件<br>在这种情况下，事件处理程序将在每次事件发生时“给予”一个信号量——导致信号量的计数值在每次“给予”时递增。每次处理事件时，任务都会“获取”一个信号量——导致信号量的计数值在每次“获取”时递减。计数值是已发生的事件数与已处理的事件数之差。</p>
<p>2资源管理<br>在这种情况下，计数值表示可用资源的数量。为了获得对资源的控制，任务必须首先获得一个信号量——递减信号量的计数值。当计数值达到零时，没有空闲资源。当任务完成资源后，它会“返回”信号量——增加信号量的计数值。</p>
<p>所有各种类型的 FreeRTOS 信号量的句柄都存储在 SemaphoreHandle_t 类型的变量中。<br>在可以使用信号量之前，必须先创建它。要创建计数信号量，请使用 xSemaphoreCreateCounting() API 函数。</p>
<p>SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount );</p>
<p>static uint32_t ulExampleInterruptHandler( void )<br>{<br>    BaseType_t xHigherPriorityTaskWoken;<br>    xHigherPriorityTaskWoken &#x3D; pdFALSE;<br>    xSemaphoreGiveFromISR( xCountingSemaphore, &amp;xHigherPriorityTaskWoken );<br>    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );<br>}</p>
<h4 id="将工作推迟到-RTOS-守护程序任务"><a href="#将工作推迟到-RTOS-守护程序任务" class="headerlink" title="将工作推迟到 RTOS 守护程序任务"></a>将工作推迟到 RTOS 守护程序任务</h4><p>到目前为止所介绍的延迟中断处理示例要求应用程序编写者为每个使用延迟处理技术的中断创建一个任务。也可以使用 xTimerPendFunctionCallFromISR() 1 API 函数将中断处理推迟到 RTOS 守护程序任务——无需为每个中断创建单独的任务。将中断处理延迟到守护程序任务称为“集中延迟中断处理”。<br>守护程序任务的优先级由 FreeRTOSConfig.h 中的 configTIMER_TASK_PRIORITY 编译时间配置常量设置。</p>
<p>不同的中断具有不同的时序约束，因此在同一应用程序中使用两种延迟中断处理的方法很常见。</p>
<p>BaseType_t xTimerPendFunctionCallFromISR(PendedFunction_t xFunctionToPend, void *pvParameter1，uint32_t ulParameter2，BaseType_t *pxHigherPriorityTaskWoken );</p>
<p>void vPendableFunction( void *pvParameter1, uint32_t ulParameter2 );</p>
<p>xFunctionToPend 指向将在守护程序任务中执行的函数的指针（实际上，只是函数名）。<br>pvParameter1 将作为函数的 pvParameter1 参数传递给守护程序任务执行的函数的值。该参数具有 void * 类型以允许它用于传递任何数据类型。例如，整数类型可以直接转换为 void <em>，或者 void * 可用于指向结构<br>ulParameter2 将作为函数的 ulParameter2 参数传递给守护程序任务执行的函数的值。<br>pxHigherPriorityTaskWoken xTimerPendFunctionCallFromISR() 写入定时器命令队列。如果 RTOS 守护任务处于阻塞状态以等待定时器命令队列上的数据可用，那么写入定时器命令队列将导致守护任务离开阻塞状态。<br>如果守护程序任务的优先级高于当前执行任务（被中断的任务）的优先级，则在内部，xTimerPendFunctionCallFromISR() 将设置</em>pxHigherPriorityTaskWoken 为 pdTRUE。<br>如果 xTimerPendFunctionCallFromISR() 将此值设置为 pdTRUE，则必须在中断退出之前执行上下文切换。这将确保中断直接返回到守护任务，因为守护任务将是最高优先级的就绪状态任务。</p>
<p>&#x2F;* 产生软件中断的任务的优先级低于守护任务的优先级。守护程序任务的优先级由 FreeRTOSConfig.h 中的 configTIMER_TASK_PRIORITY 编译时间配置常量设置。*&#x2F;<br>const UBaseType_t ulPeriodicTaskPriority &#x3D; configTIMER_TASK_PRIORITY - 1;</p>
<h4 id="在中断服务例程-使用队列"><a href="#在中断服务例程-使用队列" class="headerlink" title="在中断服务例程 使用队列"></a>在中断服务例程 使用队列</h4><p>二进制和计数信号量用于传达事件。队列用于传递事件和传输数据。</p>
<p>BaseType_t xQueueSendToFrontFromISR( QueueHandle_t xQueue, void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken);</p>
<p>队列提供了一种将数据从中断传递到任务的简单方便的方法，但如果数据到达的频率很高，则使用队列效率不高。<br>适用于生产代码的更有效的技术包括：<br>使用直接内存访问 (DMA) 硬件来接收和缓冲字符。这种方法实际上没有软件开销。然后可以使用直接到任务通知1来解除阻塞仅在检测到传输中断后才处理缓冲区的任务。<br>将每个接收到的字符复制到线程安全的 RAM 缓冲区中2。同样，直接到任务通知可用于在接收到完整消息或检测到传输中断后解除阻塞将处理缓冲区的任务。<br>直接在 ISR 中处理接收到的字符，然后使用队列将处理数据（而不是原始数据）的结果发送给任务。这在之前的图 34 中得到了证明。</p>
<p>xHigherPriorityTaskWoken 用作 portYIELD_FROM_ISR() 的参数。<br>如果发送到 xStringQueue 导致任务离开 Blocked 状态，并且如果离开 Blocked 状态的任务的优先级高于处于 Running 状态的任务的优先级，则 xHigherPriorityTaskWoken 将在 xQueueSendToBackFromISR() 中设置为 pdTRUE .</p>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><p>在多任务系统中，如果一个任务开始访问资源，但在退出运行状态之前未完成其访问，则可能会出错。如果任务使资源处于不一致状态，则任何其他任务或中断对同一资源的访问可能会导致数据损坏或其他类似问题。<br>考虑以下场景，其中两个任务尝试写入液晶显示器 (LCD)。访问外设，读取、修改、写入操作，对变量的非原子访问，函数重入</p>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>为确保始终保持数据一致性，对任务之间或任务与中断之间共享的资源的访问必须使用“互斥”技术进行管理。目标是确保一旦任务开始访问不可重入且非线程安全的共享资源，同一任务对资源具有独占访问权，直到资源返回到一致状态。</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>基本临界区是分别被宏 taskENTER_CRITICAL() 和 taskEXIT_CRITICAL() 调用包围的代码区域。临界区也称为临界区。</p>
<p>taskENTER_CRITICAL() 和 taskEXIT_CRITICAL() 不带任何参数，或返回值1 。清单 114演示了它们的使用。</p>
<p>&#x2F;* 确保对 PORTA 寄存器的访问不会因将其置于临界区而被中断。进入临界区。*&#x2F;<br>taskENTER_CRITICAL();</p>
<p>&#x2F;* 在调用 taskENTER_CRITICAL() 和调用 taskEXIT_CRITICAL() 之间不能切换到另一个任务。中断仍然可以在允许中断嵌套的 FreeRTOS 端口上执行，但仅限于逻辑优先级高于分配给 configMAX_SYSCALL_INTERRUPT_PRIORITY 常量的值的中断——并且不允许这些中断调用 FreeRTOS API 函数。*&#x2F;</p>
<p>&#x2F;* 对 PORTA 的访问已完成，因此可以安全地退出临界区。*&#x2F;<br>taskEXIT_CRITICAL();</p>
<p>以这种方式实现的关键部分是提供互斥的一种非常粗略的方法。它们的工作方式是完全禁用中断，或者禁用中断优先级（由 configMAX_SYSCALL_INTERRUPT_PRIORITY 设置），具体取决于所使用的 FreeRTOS 端口。抢先式上下文切换只能在中断中发生，因此，只要中断保持禁用状态，调用 taskENTER_CRITICAL() 的任务就可以保证保持在运行状态，直到退出临界区。<br>基本临界区必须保持非常短，否则它们会对中断响应时间产生不利影响。对 taskENTER_CRITICAL() 的每次调用都必须与对 taskEXIT_CRITICAL() 的调用紧密配对</p>
<p>基本临界区保护代码区域不被其他任务和中断访问。通过挂起调度程序实现的临界区仅保护代码区域不被其他任务访问，因为中断仍然启用。<br>临界区太长而无法通过简单地禁用中断来实现，相反，可以通过暂停调度程序来实现。但是，调度程序暂停时的中断活动会使恢复（或“取消暂停”）调度程序成为一个相对较长的操作，因此必须考虑在每种情况下使用哪种方法最好。<br>vTaskSuspendAll() API函数<br>调度程序通过调用 vTaskSuspendAll() 被挂起。暂停调度程序可防止发生上下文切换，但会启用中断。如果在调度程序挂起时中断请求上下文切换，则该请求将保持挂起，并且仅在调度程序恢复（未挂起）时执行。<br>调度程序挂起时不得调用 FreeRTOS API 函数。</p>
<h4 id="互斥体（和二进制信号量）"><a href="#互斥体（和二进制信号量）" class="headerlink" title="互斥体（和二进制信号量）"></a>互斥体（和二进制信号量）</h4><p>Mutex 是一种特殊类型的二进制信号量，用于控制对两个或多个任务之间共享的资源的访问。MUTEX 一词源于“互斥”。configUSE_MUTEXES 必须在 FreeRTOSConfig.h 中设置为 1 才能使用互斥锁。</p>
<p>在互斥场景中使用互斥锁时，可以将互斥锁视为与共享资源相关联的令牌。对于合法访问资源的任务，它必须首先成功“获取”令牌（成为令牌持有者）。当令牌持有者用完资源后，它必须“归还”令牌。<br>只有当令牌被返回后，另一个任务才能成功获取令牌，然后安全地访问相同的共享资源。除非任务持有令牌，否则不允许任务访问共享资源。</p>
<p>尽管互斥锁和二进制信号量共享许多特性，必须始终返回用于互斥的信号量。用于同步的信号量通常被丢弃并且不返回。<br>互斥锁是一种信号量。所有各种类型的 FreeRTOS 信号量的句柄都存储在 SemaphoreHandle_t 类型的变量中。<br>在使用互斥体之前，必须先创建它。要创建互斥量类型的信号量，请使用 xSemaphoreCreateMutex() API 函数。</p>
<p>像往常一样， main() 只是创建互斥体，创建任务，然后启动调度程序.<br>&#x2F;* 在使用信号量之前，它必须被显式创建。在本例中，创建了一个互斥类型的信号量。*&#x2F;</p>
<p>xMutex &#x3D; xSemaphoreCreateMutex();</p>
<p>xSemaphoreTake(xMutex, portMAX_DELAY);<br>{<br>&#x2F;&#x2F;TODO<br>}<br>xSemaphoreGive(xMutex);</p>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><p>使用互斥体提供互斥的潜在缺陷之一。所描述的执行顺序显示了较高优先级的任务 2 必须等待较低优先级的任务 1 放弃对互斥体的控制。以这种方式被较低优先级任务延迟的较高优先级任务称为“优先级反转”。<br>如果中等优先级任务开始执行而高优先级任务正在等待信号量（结果将是高优先级任务等待低优先级任务），则这种不良行为将被进一步夸大，而低优先级任务甚至无法执行。</p>
<p>FreeRTOS 互斥体和二进制信号量非常相似——不同之处在于互斥体包含基本的“优先级继承”机制，而二进制信号量则没有。优先级继承是一种将优先级倒置的负面影响降至最低的方案。<br>优先级继承的工作原理是将互斥锁持有者的优先级临时提高到试图获得相同互斥锁的最高优先级任务的优先级。持有互斥锁的低优先级任务“继承”等待互斥锁的任务的优先级。</p>
<p>如前所述，优先级继承功能会影响使用互斥锁的任务的优先级。因此，不能在中断服务例程中使用互斥锁。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>“死锁”是使用互斥锁进行互斥的另一个潜在陷阱。死锁有时也以更具戏剧性的名称“致命拥抱”而闻名。</p>
<p>递归互斥体 （解决自身死锁）<br>任务也可能与自身发生死锁。如果一个任务尝试多次使用同一个互斥锁，而不首先返回互斥锁<br>虽然它已经持有递归互斥锁，但任务再次获取互斥锁。在实际应用程序中，这仅可能发生在此任务调用的子函数内部，因为没有实际理由故意多次使用同一个互斥锁。调用任务已经是互斥锁持有者，所以对 xSemaphoreTakeRecursive() 的第二次调用只是将递归调用计数增加到 2。</p>
<p>如果多个任务在紧密循环中使用互斥锁，并且使用互斥锁的任务具有相同的优先级，则必须注意确保任务接收大致相等的处理时间。</p>
<h4 id="守门人任务"><a href="#守门人任务" class="headerlink" title="守门人任务"></a>守门人任务</h4><p>守门任务提供了一种实现互斥的干净方法，没有优先级反转或死锁的风险。<br>守门人任务是对资源拥有唯一所有权的任务。只有守门任务被允许直接访问资源——任何其他需要访问资源的任务只能通过使用网守的服务间接访问。</p>
<p>守门人任务大部分时间都处于阻塞状态，等待消息到达队列。其他任务或中断可以通过队列发送消息到守门人任务。</p>
<h4 id="事件组"><a href="#事件组" class="headerlink" title="事件组"></a>事件组</h4><p>已经注意到实时嵌入式系统必须采取行动来响应事件。前几章描述了 FreeRTOS 允许将事件传递给任务的功能。此类功能的示例包括信号量和队列，它们都具有以下属性：<br>它们允许任务在 Blocked 状态下等待单个事件的发生。<br>它们在事件发生时解除对单个任务的阻塞——被解除阻塞的任务是等待事件的最高优先级任务。</p>
<p>事件组是 FreeRTOS 的另一个功能，它允许将事件传达给任务。与队列和信号量不同：<br>事件组允许任务在阻塞状态下等待多个事件之一的组合发生。<br>当事件发生时，事件组会解除阻塞等待同一事件或事件组合的所有任务。</p>
<p>事件组的这些独特属性使其可用于同步多个任务、将事件广播到多个任务、允许任务在阻塞状态等待一组事件中的任何一个发生，以及允许任务在完成多个操作的阻塞状态。<br>事件组还提供了减少应用程序使用的 RAM 的机会，因为通常可以用单个事件组替换许多二进制信号量。</p>
<p>事件组、事件标志和事件位</p>
<p>事件“标志”是一个布尔值（1 或 0），用于指示事件是否发生。事件“组”是一组事件标志。</p>
<p>一个事件标志只能为 1 或 0，允许将一个事件标志的状态存储在一个位中，并将一个事件组中所有事件标志的状态存储在一个变量中；事件组中每个事件标志的状态由 EventBits_t 类型变量中的单个位表示。因此，事件标志也称为事件“位”。如果 EventBits_t 变量中的某个位设置为 1，则该位表示的事件已经发生。如果 EventBits_t 变量中的某个位设置为 0，则该位表示的事件尚未发生。</p>
<p>有关 EventBits_t 数据类型<br>事件组中的事件位数取决于 FreeRTOSConfig.h 1中的 configUSE_16_BIT_TICKS 编译时间配置常量：<br>如果 configUSE_16_BIT_TICKS 为 1，则每个事件组包含 8 个可用事件位。<br>如果 configUSE_16_BIT_TICKS 为 0，则每个事件组包含 24 个可用事件位。<br>多任务<br>事件组本身就是对象，任何知道它们存在的任务或 ISR 都可以访问这些对象。任意数量的任务可以设置同一事件组中的位，任意数量的任务可以从同一事件组中读取位。</p>
<h4 id="xEventGroupCreate-API函数"><a href="#xEventGroupCreate-API函数" class="headerlink" title="xEventGroupCreate() API函数"></a>xEventGroupCreate() API函数</h4><p>使用 EventGroupHandle_t 类型的变量引用事件组。xEventGroupCreate() API 函数用于创建事件组，并返回一个 EventGroupHandle_t 以引用它创建的事件组。<br>返回非 NULL 值表示事件组已成功创建。返回值应存储为句柄到创建的事件组。</p>
<h4 id="xEventGroupSetBits"><a href="#xEventGroupSetBits" class="headerlink" title="xEventGroupSetBits()"></a>xEventGroupSetBits()</h4><p>xEventGroupSetBits() API 函数设置事件组中的一个或多个位，通常用于通知任务已发生由正在设置的一个或多个位表示的事件。</p>
<p>xEventGroupSetBits() API 函数设置事件组中的一个或多个位，通常用于通知任务已发生由正在设置的一个或多个位表示的事件。<br>注意：切勿从中断服务例程中调用 xEventGroupSetBits()。应使用中断安全版本 xEventGroupSetBitsFromISR() 代替它。</p>
<p>给予信号量是一种确定性操作，因为事先知道给予信号量最多可以导致一个任务离开阻塞状态。当在事件组中设置位时，事先不知道有多少任务将离开阻塞状态，因此在事件组中设置位不是确定性操作。<br>FreeRTOS 设计和实施标准不允许在中断服务例程内或在禁用中断时执行非确定性操作。因此，xEventGroupSetBitsFromISR() 不会直接在中断服务例程中设置事件位，而是将操作推迟到 RTOS 守护程序任务。</p>
<p>BaseType_t xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken );</p>
<p>xEventGroup 正在设置位的事件组的句柄。事件组句柄将从对用于创建事件组的 xEventGroupCreate() 的调用中返回。<br>uxBitsToSet 一个位掩码，指定要在事件组中设置为 1 的事件位或事件位。事件组的值通过将事件组的现有值与 uxBitsToSet 中传递的值进行按位或运算来更新。<br>            例如，将 uxBitsToSet 设置为 0x05（二进制 0101）将导致事件组中的事件位 3 和事件位 0 被设置（如果尚未设置），同时保留所有事件组中的其他事件位不变。<br>pxHigherPriorityTaskWoken  xEventGroupSetBitsFromISR() 不会直接在中断服务例程中设置事件位，而是通过在定时器命令队列上发送命令将操作推迟到 RTOS 守护程序任务。<br>如果守护任务处于阻塞状态以等待定时器命令队列上的数据可用，那么写入定时器命令队列将导致守护任务离开阻塞状态。如果守护任务的优先级高于当前执行任务（被中断的任务）的优先级，那么在内部，<br>xEventGroupSetBitsFromISR() 将设置  *pxHigherPriorityTaskWoken 为 pdTRUE。</p>
<p>如果 xEventGroupSetBitsFromISR() 将此值设置为 pdTRUE，则应在退出中断之前执行上下文切换。这将确保中断直接返回到守护任务，因为守护任务将是最高优先级的就绪状态任务。</p>
<h4 id="xEventGroupWaitBits-API函数"><a href="#xEventGroupWaitBits-API函数" class="headerlink" title="xEventGroupWaitBits() API函数"></a>xEventGroupWaitBits() API函数</h4><p>xEventGroupWaitBits() API 函数允许任务读取事件组的值，如果尚未设置事件位，则可选择在阻塞状态等待事件组中的一个或多个事件位被设置。<br>EventBits_t xEventGroupWaitBits( const EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait);</p>
<p>调度程序用来确定任务是否进入阻塞状态以及任务何时离开阻塞状态的条件称为“解除阻塞条件”。<br>解锁条件由 uxBitsToWaitFor 和 xWaitForAllBits 参数值的组合指定：<br>uxBitsToWaitFor 指定要测试事件组中的哪些事件位<br>xWaitForAllBits 指定是使用按位 OR 测试还是按位 AND 测试<br>如果在调用 xEventGroupWaitBits() 时满足解除阻塞条件，则任务不会进入阻塞状态。</p>
<p>调用任务使用 uxBitsToWaitFor 参数指定要测试的位，并且调用任务可能需要在满足其解除阻塞条件后将这些位清零。可以使用 xEventGroupClearBits() API 函数清除事件位，但在以下情况下，使用该函数手动清除事件位将导致应用程序代码出现竞争条件：<br>有多个任务使用同一个事件组。<br>由不同的任务或中断服务程序在事件组中设置位。<br>调用任务使用 uxBitsToWaitFor 参数指定要测试的位，并且调用任务可能需要在满足其解除阻塞条件后将这些位清零。可以使用 xEventGroupClearBits() API 函数清除事件位，但在以下情况下，使用该函数手动清除事件位将导致应用程序代码出现竞争条件：<br>有多个任务使用同一个事件组。<br>由不同的任务或中断服务程序在事件组中设置位。</p>
<p>提供 xClearOnExit 参数是为了避免这些潜在的竞争条件。如果 xClearOnExit 设置为 pdTRUE，那么事件位的测试和清除对调用任务来说是一个原子操作（不会被其他任务或中断中断）。<br>xClearOnExit 如果调用任务的解除阻塞条件已经满足，并且 xClearOnExit 设置为 pdTRUE，则在调用任务退出 xEventGroupWaitBits() API 函数之前，事件组中由 uxBitsToWaitFor 指定的事件位将被清除回 0。<br>如果 xClearOnExit 设置为 pdFALSE，则事件组中事件位的状态不会被 xEventGroupWaitBits() API 函数修改。</p>
<h4 id="使用事件组同步"><a href="#使用事件组同步" class="headerlink" title="使用事件组同步"></a>使用事件组同步</h4><p>向多个任务广播，可用于一次向多个任务发送事件。<br>事件组可用于创建同步点：<br>每个必须参与同步的任务都在事件组中分配了一个唯一的事件位。<br>每个任务在到达同步点时都会设置自己的事件位。<br>设置了自己的事件位后，事件组上的每个任务都会阻塞以等待代表所有其他同步任务的事件位也被设置。</p>
<p>xEventGroupSync() API函数<br>提供 xEventGroupSync() 以允许两个或多个任务使用事件组相互同步。该功能允许任务设置一个或多个事件位作为一个单一的不间断的操作。</p>
<p>EventBits_t xEventGroupSync(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait);<br>xEventGroup 要在其中设置事件位并进行测试的事件组的句柄。事件组句柄将从对用于创建事件组的 xEventGroupCreate() 的调用中返回。<br>uxBitsToSet 一个位掩码，指定要在事件组中设置为 1 的事件位或事件位。事件组的值通过将事件组的现有值与 uxBitsToSet 中传递的值进行按位或运算来更新。<br>uxBitsToWaitFor 一个位掩码，指定要在事件组中测试的一个或多个事件位。例如，如果调用任务想要等待事件组中的事件位 0、1 和 2 被设置，则将 uxBitsToWaitFor 设置为 0x07（二进制 111）。<br>                例如，将 uxBitsToSet 设置为 0x04（二进制 0100）将导致设置事件位 3（如果尚未设置），同时保持事件组中的所有其他事件位不变。<br>xTicksToWait 任务应保持在阻塞状态以等待满足其解除阻塞条件的最长时间。</p>
<h3 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h3><p>已经看到，使用 FreeRTOS 的应用程序被构建为一组独立的任务，并且这些自主任务很可能必须相互通信，以便它们共同提供有用的系统功<br>通过中介对象进行</p>
<p>任务通知功能是可选的。要包含任务通知功能，请将 FreeRTOSConfig.h 中的 configUSE_TASK_NOTIFICATIONS 设置为 1。<br>当 configUSE_TASK_NOTIFICATIONS 设置为 1 时，每个任务都有一个“通知状态”，可以是“待处理”或“未待处理”，以及一个“通知值”，它是一个 32 位无符号整数。当任务收到通知时，其通知状态设置为待处理。当任务读取其通知值时，其通知状态设置为未挂起。<br>一个任务可以在 Blocked 状态下等待它的通知状态变为未决状态，并且可以选择超时。</p>
<p>这本书已经描述了任务可以相互通信的各种方式。到目前为止所描述的方法都需要创建一个通信对象。通信对象的示例包括队列、事件组和各种不同类型的信号量。<br>当使用通信对象时，事件和数据不会直接发送到接收任务或接收 ISR，而是发送到通信对象。同样，任务和 ISR 从通信对象接收事件和数据，而不是直接从发送事件或数据的任务或 ISR。<br>“任务通知”允许任务与其他任务交互，并与 ISR 同步，而不需要单独的通信对象。通过使用任务通知，任务或 ISR 可以直接向接收任务发送事件。<br>任务通知功能是可选的。要包含任务通知功能，请将 FreeRTOSConfig.h 中的 configUSE_TASK_NOTIFICATIONS 设置为 1。</p>
<p>同样，使用任务通知向任务发送事件或数据所需的 RAM 比使用队列、信号量或事件组执行等效操作要少得多。这是因为必须先创建每个通信对象（队列、信号量或事件组）才能使用它，而启用任务通知功能的固定开销仅为每个任务的 8 字节 RAM。<br>任务通知比通​​信对象更快，使用更少的 RAM，但任务通知不能在所有场景中使用。本节记录了无法使用任务通知的场景：<br>向 ISR 发送事件或数据<br>启用多个接收任务<br>缓冲多个数据项<br>向多个任务广播<br>在阻塞状态等待发送完成</p>
<p>任务通知是一个非常强大的功能，通常可以用来代替二进制信号量、计数信号量、事件组，有时甚至是队列。这种广泛的使用场景可以通过使用xTaskNotify() API 函数发送任务通知和xTaskNotifyWait() API 函数接收任务通知来实现。<br>提供 xTaskNotifyGive() API 函数作为 xTaskNotify() 的更简单但不太灵活的替代方案，而提供 ulTask​​NotifyTake() API 函数作为 xTaskNotifyWait() 的更简单但不太灵活的替代方案。</p>
<p>本节演示如何使用 xTaskNotifyFromISR() 通过任务通知事件发送数据。清单 157 中显示的伪代码演示了该技术，它提供了用于模数转换器 (ADC) 的 RTOS 感知中断服务例程的概要</p>
<h2 id="RTOS-任务间通信机制-同步事件-信号量、互斥锁、自旋锁、事件、邮箱、消息队列-、工作队列"><a href="#RTOS-任务间通信机制-同步事件-信号量、互斥锁、自旋锁、事件、邮箱、消息队列-、工作队列" class="headerlink" title="RTOS 任务间通信机制&#x2F;同步事件 (信号量、互斥锁、自旋锁、事件、邮箱、消息队列 、工作队列)"></a>RTOS 任务间通信机制&#x2F;同步事件 (信号量、互斥锁、自旋锁、事件、邮箱、消息队列 、工作队列)</h2><ol>
<li>RTOS的常见功能<br>信号量<br>互斥<br>自旋锁<br>事件<br>邮箱<br>消息队列<br>工作队列</li>
<li>将这些功能划分成两类<br>可以简单划分一下上面这些功能的使用场合，我们分成两类，第一类是以访问控制为主，第二类是以消息的传递为主。<br>第一类是信号量、互斥锁、自旋锁、事件。第二类就是消息队列、工作队列、邮箱。</li>
</ol>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>由消息队列控制块+消息存储buffer组成，是全局变量，任务主控发送接收导致对端唤醒，还有一种方式是延时时间到了由tick中断来唤醒</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量结构<br>信号量借用的消息队列数据结构，用uxMessagesWaiting来代指资源个数，二值信号量就是这个值只能是0和1，且没有后面的buffer，如下，所以发送接收和队列基本相同</p>
<p>二值信号量存在优先级翻转问题，就是高优先级任务因为低优先级任务占用了资源且低优先级任务被高于他优先级任务抢占导致不能运行，这样高优先级就一直阻塞住了，为了解决此问题（减小影响）设计了互斥量</p>
<h3 id="互斥量（锁）"><a href="#互斥量（锁）" class="headerlink" title="互斥量（锁）"></a>互斥量（锁）</h3><p>互斥量结构<br>互斥量就是二值信号量+优先级继承，xMutexHolder保存拿到此资源的TCB，TCB中还有一个uxBasePriority用于保存此任务创建时的优先级</p>
<p>FreeRTOS没有实现谁take谁give的限制，所以一个task take，另一个task give在代码上是能跑通的，要注意这点<br>还有死锁问题，一个任务先take后再次take，此任务就被阻塞了，无法唤醒，自我死锁，此时需要用递归互斥量</p>
<p>如果两个不同优先级的任务使用同一个互斥锁，那么 FreeRTOS 调度策略会明确任务执行的顺序；能够运行的优先级最高的任务将被选为进入运行状态的任务。例如，如果一个高优先级任务处于阻塞状态以等待一个低优先级任务持有的互斥锁，那么一旦低优先级任务返回互斥锁，高优先级任务就会抢占低优先级任务. 然后，高优先级任务将成为互斥锁持有者。</p>
<p>然而，当任务具有相同优先级时，通常会错误地假设任务将执行的顺序。如果任务 1 和任务 2 具有相同的优先级，并且任务 1 处于阻塞状态以等待任务 2 持有的互斥锁，那么当任务 2“给予”互斥锁时，任务 1 不会抢占任务 2。相反，任务 2 将保持在运行状态，而任务 1 将简单地从阻塞状态移动到就绪状态。</p>
<h3 id="递归互斥量（递归锁）"><a href="#递归互斥量（递归锁）" class="headerlink" title="递归互斥量（递归锁）"></a>递归互斥量（递归锁）</h3><p>递归互斥量和临界区嵌套设计方式一样，uxRecursiveCallCount来记录递归次数，且递归互斥量实现了谁take谁give的限制。</p>
<h3 id="自旋锁-（原地等待锁）"><a href="#自旋锁-（原地等待锁）" class="headerlink" title="自旋锁 （原地等待锁）"></a>自旋锁 （原地等待锁）</h3><p>在有些场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。</p>
<p>如果机器有多个CPU核心，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
<p>缺点<br>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。</p>
<p>如果锁被占用的时间很短，自旋等待的效果就会非常好；<br>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。<br>所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程。（这个次数默认是10次，可以配置）</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/rtos/" rel="tag"><i class="fa fa-tag"></i> rtos</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/17/pac/" rel="prev" title="clash config">
      <i class="fa fa-chevron-left"></i> clash config
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/03/08/f1c100s%E5%BC%80%E5%8F%91/" rel="next" title="F1C100s 启动">
      F1C100s 启动 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MISRA"><span class="nav-text">MISRA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97"><span class="nav-text">数据类型和编码风格指南</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-FreeRTOS%E9%A1%B9%E7%9B%AE"><span class="nav-text">创建 FreeRTOS项目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80-%E5%8F%AA%E5%A4%8D%E5%88%B6%E9%9C%80%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6-Keil-or-others"><span class="nav-text">方案一: 只复制需要的文件 Keil or others</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C-%E5%AE%8C%E6%95%B4%E7%9A%84FreeRTOS-%E4%BD%BF%E7%94%A8library-json-PlatformIO-libopencm3-FreeRTOS"><span class="nav-text">方案二: 完整的FreeRTOS, 使用library.json  PlatformIO: libopencm3 + FreeRTOS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOSConfig-h-%E5%87%BD%E6%95%B0%E5%90%8D%E9%80%82%E9%85%8D"><span class="nav-text">FreeRTOSConfig.h 函数名适配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">堆内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-1-c"><span class="nav-text">heap_1.c</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-2-c"><span class="nav-text">heap_2.c</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-3-c"><span class="nav-text">heap_3.c</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-4-c"><span class="nav-text">heap_4.c</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-5-c"><span class="nav-text">heap_5.c</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-text">任务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#xTaskCreate-%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BAAPI%E5%87%BD%E6%95%B0"><span class="nav-text">xTaskCreate() 任务创建API函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-main-%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%AE%9E%E4%BE%8B"><span class="nav-text">在 main() 中创建多个任务实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%BB%BB%E5%8A%A1%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%B0%E4%BB%BB%E5%8A%A1%E5%AE%9E%E4%BE%8B"><span class="nav-text">在任务中创建新任务实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E4%B8%80%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%AE%9E%E4%BE%8B"><span class="nav-text">同一任务实现创建多个任务实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">任务优先级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">通用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-text">架构优化方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">配置调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%8A%A2%E5%85%88"><span class="nav-text">带时间片的优先级抢先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E4%BD%9C%E8%B0%83%E5%BA%A6"><span class="nav-text">合作调度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6"><span class="nav-text">时间片调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-text">优先级调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E9%94%81%E7%8A%B6%E6%80%81"><span class="nav-text">封锁状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9A%82%E5%81%9C%E7%8A%B6%E6%80%81"><span class="nav-text">暂停状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81"><span class="nav-text">就绪状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vTaskDelay"><span class="nav-text">vTaskDelay()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vTaskDelayUntil"><span class="nav-text">vTaskDelayUntil( )</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E5%92%8C%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E6%8C%82%E9%92%A9"><span class="nav-text">空闲任务和空闲任务挂钩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E4%BB%BB%E5%8A%A1"><span class="nav-text">更改任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E8%AF%BB%E5%8F%96-%E5%86%99%E5%85%A5"><span class="nav-text">阻塞队列读取&#x2F;写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97"><span class="nav-text">使用队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xQueueSend-API%E5%87%BD%E6%95%B0"><span class="nav-text">xQueueSend() API函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xQueueReceive-API%E5%87%BD%E6%95%B0"><span class="nav-text">xQueueReceive() API函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uxQueueMessagesWaiting-API%E5%87%BD%E6%95%B0"><span class="nav-text">uxQueueMessagesWaiting() API函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%A4%A7%E5%9E%8B%E6%88%96%E5%8F%AF%E5%8F%98%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-text">处理大型或可变大小的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E9%98%9F%E5%88%97"><span class="nav-text">多个队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xQueueCreateSet-API%E5%87%BD%E6%95%B0%E9%98%9F%E5%88%97%E9%9B%86%E5%BF%85%E9%A1%BB%E5%9C%A8%E4%BD%BF%E7%94%A8%E5%89%8D%E6%98%BE%E5%BC%8F%E5%88%9B%E5%BB%BA%E3%80%82"><span class="nav-text">xQueueCreateSet() API函数队列集必须在使用前显式创建。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xQueueAddToSet-API%E5%87%BD%E6%95%B0-%E5%B0%86%E9%98%9F%E5%88%97%E6%88%96%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%98%9F%E5%88%97%E9%9B%86%E3%80%82"><span class="nav-text">xQueueAddToSet() API函数 将队列或信号量添加到队列集。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xQueueSelectFromSet-API%E5%87%BD%E6%95%B0"><span class="nav-text">xQueueSelectFromSet() API函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E5%88%9B%E5%BB%BA%E9%82%AE%E7%AE%B1"><span class="nav-text">使用队列创建邮箱</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xQueueOverwrite-API%E5%87%BD%E6%95%B0"><span class="nav-text">xQueueOverwrite() API函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xQueuePeek-API%E5%87%BD%E6%95%B0"><span class="nav-text">xQueuePeek() API函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%A1%E7%90%86"><span class="nav-text">软件定时器管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E8%BD%AF%E4%BB%B6%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="nav-text">创建和启动软件计时器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-text">软件定时器回调函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-text">更改定时器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="nav-text">中断管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%94%A8%E4%BA%8E%E5%B0%86%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E2%80%9C%E6%8E%A8%E8%BF%9F%E2%80%9D%E5%88%B0%E4%BB%BB%E5%8A%A1"><span class="nav-text">二进制信号量用于将中断处理“推迟”到任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">计数信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E5%B7%A5%E4%BD%9C%E6%8E%A8%E8%BF%9F%E5%88%B0-RTOS-%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F%E4%BB%BB%E5%8A%A1"><span class="nav-text">将工作推迟到 RTOS 守护程序任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E4%BE%8B%E7%A8%8B-%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97"><span class="nav-text">在中断服务例程 使用队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-text">资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5"><span class="nav-text">互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-text">临界区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93%EF%BC%88%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%89"><span class="nav-text">互斥体（和二进制信号量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC"><span class="nav-text">优先级反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%88%E9%97%A8%E4%BA%BA%E4%BB%BB%E5%8A%A1"><span class="nav-text">守门人任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%84"><span class="nav-text">事件组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xEventGroupCreate-API%E5%87%BD%E6%95%B0"><span class="nav-text">xEventGroupCreate() API函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xEventGroupSetBits"><span class="nav-text">xEventGroupSetBits()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xEventGroupWaitBits-API%E5%87%BD%E6%95%B0"><span class="nav-text">xEventGroupWaitBits() API函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%BB%84%E5%90%8C%E6%AD%A5"><span class="nav-text">使用事件组同步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5"><span class="nav-text">任务通知</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RTOS-%E4%BB%BB%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6-%E5%90%8C%E6%AD%A5%E4%BA%8B%E4%BB%B6-%E4%BF%A1%E5%8F%B7%E9%87%8F%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E4%BA%8B%E4%BB%B6%E3%80%81%E9%82%AE%E7%AE%B1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E3%80%81%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">RTOS 任务间通信机制&#x2F;同步事件 (信号量、互斥锁、自旋锁、事件、邮箱、消息队列 、工作队列)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%EF%BC%88%E9%94%81%EF%BC%89"><span class="nav-text">互斥量（锁）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%E9%87%8F%EF%BC%88%E9%80%92%E5%BD%92%E9%94%81%EF%BC%89"><span class="nav-text">递归互斥量（递归锁）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-%EF%BC%88%E5%8E%9F%E5%9C%B0%E7%AD%89%E5%BE%85%E9%94%81%EF%BC%89"><span class="nav-text">自旋锁 （原地等待锁）</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Linkua</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Linkua</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

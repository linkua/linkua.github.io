<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LETV IR code</title>
    <url>/2022/03/03/LETV%20IR%20code/</url>
    <content><![CDATA[<h1 id="LETV-IR-code"><a href="#LETV-IR-code" class="headerlink" title="LETV IR code"></a>LETV IR code</h1><p>乐视超级电视曲面x55 Cured的红外解码</p>
<span id="more"></span>
<h2 id="with-MQTT-Topic"><a href="#with-MQTT-Topic" class="headerlink" title="with MQTT Topic"></a>with MQTT Topic</h2><p><code>cmnd/tasmota_781CD6/IRSend</code></p>
<h2 id="with-Web-Requests"><a href="#with-Web-Requests" class="headerlink" title="with Web Requests"></a>with Web Requests</h2><p><code>http://192.168.1.37/cm?cmnd=IRSend</code></p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="power"><a href="#power" class="headerlink" title="power"></a>power</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A650AF&quot;,&quot;DataLSB&quot;:&quot;0x4C650AF5&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="soud-off"><a href="#soud-off" class="headerlink" title="soud off"></a>soud off</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A6F00F&quot;,&quot;DataLSB&quot;:&quot;0x4C650FF0&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="123"><a href="#123" class="headerlink" title="123"></a>123</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A68679&quot;,&quot;DataLSB&quot;:&quot;0x4C65619E&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="setting"><a href="#setting" class="headerlink" title="setting"></a>setting</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A600FF&quot;,&quot;DataLSB&quot;:&quot;0x4C6500FF&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="shubiao"><a href="#shubiao" class="headerlink" title="shubiao"></a>shubiao</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A646B9&quot;,&quot;DataLSB&quot;:&quot;0x4C65629D&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="vol"><a href="#vol" class="headerlink" title="vol+"></a>vol+</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A6A857&quot;,&quot;DataLSB&quot;:&quot;0x4C6515EA&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="vol-1"><a href="#vol-1" class="headerlink" title="vol-"></a>vol-</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A638C7&quot;,&quot;DataLSB&quot;:&quot;0x4C651CE3&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="ch"><a href="#ch" class="headerlink" title="ch+"></a>ch+</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A6F807&quot;,&quot;DataLSB&quot;:&quot;0x4C651FE0&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="ch-1"><a href="#ch-1" class="headerlink" title="ch-"></a>ch-</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A67887&quot;,&quot;DataLSB&quot;:&quot;0x4C651EE1&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A6D02F&quot;,&quot;DataLSB&quot;:&quot;0x4C650BF4&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A6708F&quot;,&quot;DataLSB&quot;:&quot;0x4C650EF1&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="left"><a href="#left" class="headerlink" title="left"></a>left</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A608F7&quot;,&quot;DataLSB&quot;:&quot;0x4C6510EF&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="right"><a href="#right" class="headerlink" title="right"></a>right</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A608F7&quot;,&quot;DataLSB&quot;:&quot;0x4C6510EF&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="ok"><a href="#ok" class="headerlink" title="ok"></a>ok</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A6B04F&quot;,&quot;DataLSB&quot;:&quot;0x4C650DF2&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="menu"><a href="#menu" class="headerlink" title="menu"></a>menu</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A6EC13&quot;,&quot;DataLSB&quot;:&quot;0x4C6537C8&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="home"><a href="#home" class="headerlink" title="home"></a>home</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A66897&quot;,&quot;DataLSB&quot;:&quot;0x4C6516E9&quot;,&quot;Repeat&quot;:0&#125;</code></p>
<h3 id="back"><a href="#back" class="headerlink" title="back"></a>back</h3><p><code>&#123;&quot;Protocol&quot;:&quot;NEC&quot;,&quot;Bits&quot;:32,&quot;Data&quot;:&quot;0x32A6B847&quot;,&quot;DataLSB&quot;:&quot;0x4C651DE2&quot;,&quot;Repeat&quot;:0&#125;</code></p>
]]></content>
      <categories>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>hass</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP协议栈</title>
    <url>/2024/03/11/TCPIP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="SSL-TLS-协议是什么"><a href="#SSL-TLS-协议是什么" class="headerlink" title="SSL&#x2F;TLS 协议是什么"></a>SSL&#x2F;TLS 协议是什么</h3><p>SSL 协议（Secure Sockets Layer，安全套接字层），是由网景 (Netscape) 公司在 1990 年推出的一种标准安全协议，用于在网络通信中建立 Web 浏览器和 Web 服务器之间的加密链接。</p>
<p>TLS（Transport Layer Security，传输层安全）是 IETF 组织 （工程任务组）在 1999 年将 SSL3.0 协议规范进行了标准化。</p>
<p>SSL(Secure Sockets Layer) 和 TLS(Transport Layer Security) 的关系就像 windows XP 和 windows 7 的关系，升级后改了个名字而已。</p>
<span id="more"></span>

<p>HTTPS&#x3D;HTTP+TLS</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP 开发</title>
    <url>/2024/04/16/esp32%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="ESP32-简介"><a href="#ESP32-简介" class="headerlink" title="ESP32 简介"></a>ESP32 简介</h3><p>ESP32芯片具有以下特性：</p>
<ul>
<li>处理器和内存：双核32位LX6微处理器，主频最高可达240MHz，520KB SRAM，448KB ROM，同时支持外部4MB SPI Flash和外部8MB PSRAM，为数据的处理和存储提供强大的支持。</li>
<li>WiFi：支持802.11 b&#x2F;g&#x2F;n（2.4GHz）标准，支持STA&#x2F;AP&#x2F;STA+AP工作模式，最大传输速率可达150Mbps，并支持WPA&#x2F;WPA2&#x2F;WPA3安全模式，提供稳定、安全的无线网络连接。</li>
<li>蓝牙：支持蓝牙4.2（包括BR&#x2F;EDR和BLE），支持蓝牙音频传输（A2DP&#x2F;AVRCP&#x2F;SPP），使得无线音频传输和远程控制更加便捷。</li>
<li>外设和接口：ESP32提供了丰富的外设和接口，包括最多34个可编程GPIO引脚，支持UART、SPI、I2C、I2S、PWM等多种通信协议。此外，还集成了12位ADC、8位DAC、触摸传感器、霍尔传感器等，为各种应用场景提供了强大的支持。</li>
<li>电源管理：具有多种低功耗工作模式，电源电压范围2.2V-3.6V，内置低压稳压器（LDO）和开关电源管理单元（SMU），实现高效的电源管理<span id="more"></span></li>
</ul>
<h4 id="主核（Main-Core）："><a href="#主核（Main-Core）：" class="headerlink" title="主核（Main Core）："></a>主核（Main Core）：</h4><ul>
<li>特点：主核是ESP32的主要处理器核心，采用Tensilica Xtensa LX6架构，主频高达240MHz。它具有较高的性能，可执行大多数应用程序任务。</li>
<li>应用：主核通常用于执行主要的应用逻辑、用户界面、Wi-Fi和蓝牙通信以及其他需要高性能处理的任务。</li>
</ul>
<h4 id="协处理器核心（Pro-Co-Processor）："><a href="#协处理器核心（Pro-Co-Processor）：" class="headerlink" title="协处理器核心（Pro Co-Processor）："></a>协处理器核心（Pro Co-Processor）：</h4><ul>
<li>特点：协处理器核心也采用Tensilica Xtensa LX6架构，主频高达160MHz。它专门用于处理Wi-Fi和蓝牙通信协议，以及其他低功耗任务。</li>
<li>应用：协处理器核心负责Wi-Fi和蓝牙通信堆栈，以减少对主核的干扰，从而实现低功耗通信。</li>
</ul>
<h4 id="双核协同工作："><a href="#双核协同工作：" class="headerlink" title="双核协同工作："></a>双核协同工作：</h4><ul>
<li>特点：ESP32的双核设计允许主核和协处理器核心协同工作，以提高系统性能和效率。它们可以在不同的任务上并行运行，也可以相互通信和同步。</li>
<li>应用：双核协同工作非常适用于需要同时执行多个任务的应用，例如实时操作系统（RTOS）和并发通信。</li>
</ul>
<h4 id="内存："><a href="#内存：" class="headerlink" title="内存："></a>内存：</h4><ul>
<li>特点：主核和协处理器核心都共享相同的存储器空间，包括闪存、RAM和其他存储器。这使得数据和代码在两个核心之间共享，简化了多任务编程。</li>
<li>应用：共享内存使得数据在两个核心之间的传递更加高效，有助于提高系统性能。</li>
</ul>
<h3 id="VScode-开发环境搭建"><a href="#VScode-开发环境搭建" class="headerlink" title="VScode 开发环境搭建"></a>VScode 开发环境搭建</h3><h4 id="安装-ESP-IDF"><a href="#安装-ESP-IDF" class="headerlink" title="安装 ESP-IDF"></a>安装 ESP-IDF</h4><p>Windows 安装离线版IDF <a href="https://dl.espressif.cn/dl/esp-idf/?idf=5.2">https://dl.espressif.cn/dl/esp-idf/?idf=5.2</a></p>
<h4 id="安装-ESP-IDF-插件"><a href="#安装-ESP-IDF-插件" class="headerlink" title="安装 ESP-IDF 插件"></a>安装 ESP-IDF 插件</h4><ol>
<li>打开 VSCode, 使用快捷键 Shift+Ctrl+X，进入插件管理器</li>
<li>在搜索栏中，输入 Espressif IDF，选择对应的插件点击 install 即可</li>
</ol>
<h4 id="新建基于例程的工程"><a href="#新建基于例程的工程" class="headerlink" title="新建基于例程的工程"></a>新建基于例程的工程</h4><ol>
<li>按下 F1 打开命令行，输入 ESP-IDF: Show Examples Projects,或者 vscode 上方输入框填入<code>&gt;</code>,再输入命令</li>
<li>点击 ESP-IDF: Show Examples Projects</li>
<li>点击 Use current ESP-IDF 使用当前 ESP-IDF</li>
<li>在列表中选择 hello_world,然后点击 Create project using example hello world</li>
<li>点击左下角图标选择 COM， 选择目标芯片，点击齿轮图标配置项目</li>
<li>打开 esp-idf terminal 输入 idf 命令 idf.py menuconifg配置例程引脚，例如LED GPIO pin2。</li>
</ol>
<p>在配置窗口中选择 Serial flasher config，将 Falsh 的大小改为 4MB：<br>Save</p>
<p>编译项目</p>
<h3 id="esptool-单独下载固件"><a href="#esptool-单独下载固件" class="headerlink" title="esptool 单独下载固件"></a>esptool 单独下载固件</h3><p><code>pip install esptool</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">esptool --port /dev/ttyACM0 --baud 115200 write_flash --flash_size=detect 0 &#x27;/home/link/Downloads/WLED_0.13.3_ESP01.bin&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>esp32</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 使用 clangd 构建 Linux开发环境</title>
    <url>/2024/04/12/VSCode%20%E4%BD%BF%E7%94%A8%20clangd%20%E6%9E%84%E5%BB%BA%20Linux%20%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最初在使用 <a href="https://so.csdn.net/so/search?q=Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81&spm=1001.2101.3001.7020">Linux 内核源码</a>进行驱动开发时，由于没有代码补全、自动提示等功能写起来十分不方便，虽然有人使用 Source Insight 来阅读源码，但是我用起来还是感觉怪怪的，有时间同一个函数会找到很多的定义，不便判断。在调用层次方面，还是 clangd 更好用。</p>
<span id="more"></span>

<h3 id="VSCode-安装-clangd-插件并搭建环境"><a href="#VSCode-安装-clangd-插件并搭建环境" class="headerlink" title="VSCode 安装 clangd 插件并搭建环境"></a>VSCode 安装 clangd 插件并搭建环境</h3><hr>
<p><a href="https://clangd.llvm.org/">Clangd</a> 是一个基于 Clang 的语言服务器，它提供了代码智能感知和导航功能。通过与 VSCode 集成，可以实现以下功能：</p>
<ul>
<li><strong>代码补全和自动提示</strong>：Clangd 可以根据代码上下文提供准确的补全建议和自动提示，帮助开发者快速编写代码。</li>
<li><strong>代码跳转和导航</strong>：Clangd 可以识别代码中的符号引用、函数调用等，并支持跳转到定义、查看声明等操作，便于阅读和理解复杂的内核源代码。</li>
<li><strong>实时错误和警告检查</strong>：Clangd 可以实时检查代码中的语法错误、潜在问题和警告信息，帮助开发者及早发现和修复问题。</li>
<li><strong>重构支持</strong>：Clangd 提供了一些重构功能，如重命名变量、提取函数等，可以简化代码重构的过程。</li>
</ul>
<h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p><img src="https://img-blog.csdnimg.cn/3645c01972db45698f4e2b7b0d4eff5a.png"></p>
<h4 id="禁用或卸载-Microsoft-C-C-Intelligence"><a href="#禁用或卸载-Microsoft-C-C-Intelligence" class="headerlink" title="禁用或卸载 Microsoft C&#x2F;C++ Intelligence"></a>禁用或卸载 Microsoft C&#x2F;C++ Intelligence</h4><p>因为和 clangd 有冲突，这种语法高亮的插件往往只能二者存其一。<br><img src="https://img-blog.csdnimg.cn/36eb417493f94996835539cf10b8e3cd.png"></p>
<h4 id="安装-clangd-安装包"><a href="#安装-clangd-安装包" class="headerlink" title="安装 clangd 安装包"></a>安装 clangd 安装包</h4><p>VSCode clangd 插件本身是不能运行的，它还需要 clangd 的环境，所以接下来安装 clangd。</p>
<p><a href="https://github.com/clangd/clangd/releases/latest">下载地址</a><br>在 Ubuntu 中最好不要使用 apt 安装，因为版本比较旧，建议下载后手动安装。<br><img src="https://img-blog.csdnimg.cn/28b3ab937dfc4024abef258f34eba220.png"><br>解压后，<br>将 bin 文件夹下的 <strong>clangd</strong> 移动到 <strong>&#x2F;usr&#x2F;bin</strong> 目录下，<br>将 lib 文件夹下的所有移动到 <strong>&#x2F;usr&#x2F;local&#x2F;lib</strong> 目录下。<br>之后打开终端，键入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clangd --version</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/aceff70a905e43e3a921aae0c1a06098.png"><br>就算成功。</p>
<h4 id="修改拓展设置"><a href="#修改拓展设置" class="headerlink" title="修改拓展设置"></a>修改拓展设置</h4><p>修改正确 clangd 路径：<br><img src="https://img-blog.csdnimg.cn/8ebbfb7a970b4da6b97471110ce7276d.png"></p>
<h3 id="使用-bear-构建源码的-compile-commands-json-文件"><a href="#使用-bear-构建源码的-compile-commands-json-文件" class="headerlink" title="使用 bear 构建源码的 compile_commands.json 文件"></a>使用 bear 构建源码的 compile_commands.json 文件</h3><hr>
<p>如果没有 bear 的话就安装一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install bear</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我使用的是韦东山的 imx6ull-qemu 模拟开发板的内核源码，内核编译命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ml@ml-virtual-machine:~$ cd linux-4.9.88</span><br><span class="line">ml@ml-virtual-machine:~$ make mrproper</span><br><span class="line">ml@ml-virtual-machine:~$ make 100ask_imx6ull_qemu_defconfig</span><br><span class="line">ml@ml-virtual-machine:~$ bear make zImage -j4 //编译zImage 内核</span><br><span class="line">ml@ml-virtual-machine:~$ make clean  // 清除生成文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>倒数第二条带有 bear 的指令就是生成 compile_commands.json 文件的。</p>
<p>compile_commands.json 文件记录了你的工程是如何构建的，使用到了哪些源码文件，源码文件之间的包含关系，引用路径之类的，这些可以帮助 clangd 构建符号关系索引库。<br><img src="https://img-blog.csdnimg.cn/859edafd67b34550b056f7a85a334c5c.png"><br><img src="https://img-blog.csdnimg.cn/1914d74580404f5793b3dc34c8367ce1.png"></p>
<h3 id="修改-compile-commands-json-文件"><a href="#修改-compile-commands-json-文件" class="headerlink" title="修改 compile_commands.json 文件"></a>修改 compile_commands.json 文件</h3><hr>
<p>目前，这个文件还不能用，需要修改编译工具链成对应的工具链，比如我这里需要全局替换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;cc&quot;  --&gt;  &quot;arm-linux-gnueabihf-gcc&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/1b82ad3c042f4fa493307cfbcd6221b0.png"></p>
<p>保存后关闭 VSCode，如果有. cache 文件夹的话，删除掉它。之后重新用 VSCode 打开源码目录，随便打开一个. c 文件，clangd 便自动开始索引文件了，索引文件会保存在 .cache 目录下。<br><img src="https://img-blog.csdnimg.cn/f78bfc99488b433a9bc813564f2adabb.png"></p>
<p>如果这个过程特别快，只有几秒钟的话，那就是上述步骤有错误。正常来说，这个索引过程会有几分钟。</p>
<p><img src="https://img-blog.csdnimg.cn/07dcacac63d243a2947c9be06f014b51.png"></p>
<h3 id="驱动程序和应用程序的编写"><a href="#驱动程序和应用程序的编写" class="headerlink" title="驱动程序和应用程序的编写"></a>驱动程序和应用程序的编写</h3><hr>
<p>对于驱动程序来说，我的方法是在当前源码目录下新建一个文件夹，在这个文件夹下进行驱动程序的编写，这样跳转、补全之类的都比较方便。<br><img src="https://img-blog.csdnimg.cn/64d9619c518d431881ce96769a89ad42.png"></p>
<p>然后保存工作区，方便下次打开：<br><img src="https://img-blog.csdnimg.cn/b4135d44825a4ebb9c70f91e386e6026.png"></p>
<p>对应用程序来说，不便放在源码工作区当中，可以像这样单独打开一个用于编写应用程序：<br><img src="https://img-blog.csdnimg.cn/b09fbda05d304b3a9210a78606fb75d9.png"></p>
<p>驱动程序写完后，拷贝到应用程序所在目录的驱动程序文件中。<br><img src="https://img-blog.csdnimg.cn/90aa9d5a24314422b0225529f1b4970b.png"></p>
<p>此后，便可以方便快捷的编写驱动程序和应用程序了。</p>
<h3 id="配置文件的添加"><a href="#配置文件的添加" class="headerlink" title="配置文件的添加"></a>配置文件的添加</h3><hr>
<p>clangd 是集成了 clang-tidy 和 clang-format 的，所以二者的配置文件也能在 clangd 下面使用。比如，我根据我的喜好更改了 format 格式和它的函数参数提示。<br><img src="https://img-blog.csdnimg.cn/34e1baf9f88c4f7d93d6250e7f5ce058.png"></p>
<p>.clangd 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 提示嵌入，不使用函数参数嵌入提示</span><br><span class="line">InlayHints:</span><br><span class="line">    Designators: Yes</span><br><span class="line">    Enabled: Yes</span><br><span class="line">    ParameterNames: No</span><br><span class="line">    DeducedTypes: Yes</span><br><span class="line"></span><br><span class="line">CompileFlags:</span><br><span class="line">    Add: [-xc, -Wall]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>.clang-format 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BasedOnStyle: LLVM</span><br><span class="line">UseTab: Never</span><br><span class="line">IndentWidth: 4</span><br><span class="line">TabWidth: 4</span><br><span class="line"></span><br><span class="line"># 最外层大括号换行</span><br><span class="line"># BreakBeforeBraces: Linux</span><br><span class="line"></span><br><span class="line">BreakBeforeBraces: Allman</span><br><span class="line">AllowShortIfStatementsOnASingleLine: true</span><br><span class="line">IndentCaseLabels: false</span><br><span class="line">ColumnLimit: 120</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>clangd vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 配置 SSH 连接远程</title>
    <url>/2024/04/12/VSCode%20%E9%85%8D%E7%BD%AE%20SSH%20%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%20+%20%E5%85%8D%E5%AF%86%E8%BF%9E%E6%8E%A5%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>由于本机计算资源有限，为了满足项目需求，导师安排了计算资源。最初，我尝试使用 XShell 进行连接，但由于其非图形界面，操作不够直观，不便于代码编写和项目管理。</p>
<p>而 VSCode 完美解决了这一痛点，我转而选择了 VSCode。VSCode 提供了图形界面的远程开发环境，使得远程连接变得更加轻松和便捷。本教程旨在记录并分享使用 VSCode 进行远程连接的步骤，希望能够帮助到有相似需求的人，提高远程开发的效率和便捷性。</p>
<span id="more"></span>

<p>本机：Windows</p>
<p>服务器：Linux</p>
<p>前置要求：</p>
<ul>
<li>本机安装 Vscode、ssh（命令行输入 ssh 检查）</li>
<li>打开 Vscode 时建议使用<strong>管理器员权限</strong>打开，在这之前遇到了一些报错。</li>
</ul>
<h2 id="一、远程连接过程"><a href="#一、远程连接过程" class="headerlink" title="一、远程连接过程"></a><strong>一、远程连接过程</strong></h2><ul>
<li>安装插件 remote-ssh</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-51a7090e353ee0442e8071aafc0cb73d_b.jpg"></p>
<ul>
<li>点击远程资源管理器、新建远程</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-2573982fab9eb5bafd09da842b213f7e_r.jpg"></p>
<ul>
<li>在窗口上方弹出的命令框中输入：<code>ssh name@ip</code>，<code>name</code>是你服务器的用户名，如果没有创建用户则填 root，<code>ip</code>是你的服务器 ip 地址</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-5b85e5d9f04ffab768c7c183b2309884_r.jpg"></p>
<p>比如我输入<code>ssh -p 2230 liuwf@202.116.7.104</code>，其中<code>-p 2230</code>表示指定端口号 2230，若是没有指定可以直接删除，输入后按回车</p>
<ul>
<li>回车后会弹出选择更新配置文件，点击第一个路径，会自动生成一个 config 文件</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-b7dfcd422a9d004694b390d3ceae825e_r.jpg"></p>
<ul>
<li>下图为 config 内容，如果没有自动生成，则手动打开并根据自身情况进行配置，文件的位置在上图的路径。</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-a549b15b4ac528314928d24778186540_r.jpg"></p>
<p><strong><em>Host:</em></strong> <em>这是一个用户定义的别名，用于指代远程主机。可以在在终端中执行</em> <code>_ssh 别名_</code> <em>替代</em><code>_ssh name@ip_</code><em>。</em></p>
<p><strong><em>HostName:</em></strong> <em>指定远程主机的实际地址或主机名。</em></p>
<p><strong><em>Port:</em></strong> <em>指定 SSH 连接使用的端口号。</em></p>
<p><strong><em>User:</em></strong> <em>指定连接到远程主机时使用的用户名。在这里，用户名是</em> <code>_liuwf_</code><em>。</em></p>
<ul>
<li>在 config 文件配置完成并保存后，在 VSCode 的远程资源管理器中已经出现刚配置的远程服务器，此时点击红框按钮连接即可</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-b13944c910f4be29538cbaaa01d3eae8_r.jpg"></p>
<ul>
<li>VSCode 会自动进行远程端的设置，窗口上方的中间位置会出现选择平台、输入密码设置，按照自己的情况填写即可。</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-f3dfcc846741b6d574fb6ee86041d5af_r.jpg"></p>
<ul>
<li>此时没有意外的话就可以连接上了远程服务器了</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-79fc77a6c6d904caa9cf90a63f2fbd9f_r.jpg"></p>
<ul>
<li>连接过程中，我遇到了如下错误：<br><code>Bad owner or permissions on C:\\Users\.ssh</code><br><code>\&gt; /config</code><br><code>\&gt; 过程试图写入的管道不存在。</code></li>
</ul>
<p>参考了<a href="https://link.zhihu.com/?target=https://blog.csdn.net/qq_46276946/article/details/131299973">链接</a>仍然不能解决。最后通过使用<strong>管理员权限</strong>打开 VSCode 解决该问题。</p>
<h2 id="二、如何免密连接"><a href="#二、如何免密连接" class="headerlink" title="二、如何免密连接"></a><strong>二、如何免密连接</strong></h2><p>每次连接都需要输入密码未免有些麻烦，一台机器想要免密访问其他机器，需要把自己的公钥内容发送到别的机器的 authorized_keys 中去，并在本机 config 文件中配置私钥文件位置。如下为流程。</p>
<h3 id="1-生成新的密钥对"><a href="#1-生成新的密钥对" class="headerlink" title="1. 生成新的密钥对"></a>1. 生成新的密钥对</h3><p>使用命令<code>ssh-keygen</code>生成新的密钥对。你可以选择在生成密钥对时为其指定不同的文件名。请注意，<code>-f</code> 后的<code>id_rsa_linux</code> 和 <code>id_rsa_windows</code> 只是示例文件名，你可以根据需要选择其他文件名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在 Linux 和 Mac 上</span><br><span class="line">ssh-keygen -t rsa -b 2048 -f ~/.ssh/id_rsa_linux</span><br><span class="line">​</span><br><span class="line"># 在 Windows 上</span><br><span class="line">ssh-keygen -t rsa -b 2048 -f C:\Users\YourUsername\.ssh\id_rsa_windows</span><br><span class="line">​</span><br><span class="line"># 如果你只有单平台使用 ssh</span><br><span class="line">ssh-keygen</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>当你在多个平台上使用 SSH 连接到不同的远程服务器时，可能需要为每个平台生成和使用不同的密钥对。这是因为每个平台（例如，Windows、Linux、Mac）可能有不同的文件系统和密钥文件位置，同时在安全性的考虑下，不同平台上的密钥对最好是独立的。</p>
<p>输入命令后一路回车</p>
<p><img src="https://pic2.zhimg.com/v2-6217ef2d7028e4ff6b9d6b2555757819_r.jpg"></p>
<p>系统会在你指定的路径（本例子为 <code>C:\Users\YourUsername\.ssh</code>）下生成两个文件，分别是<code>id_rsa_windows.pub</code>和<code>id_rsa_windows</code>，前者为生成的公钥，后者为私钥 。</p>
<h3 id="2-添加公钥到远程服务器"><a href="#2-添加公钥到远程服务器" class="headerlink" title="2. 添加公钥到远程服务器"></a>2. <strong>添加公钥到远程服务器</strong></h3><p>将生成的公钥（ <code>id_rsa_windows.pub</code>的内容）添加到你远程服务器的 <code>authorized_keys</code> 文件中，以允许连接。</p>
<p>(1). 若你本机是 <strong>Windows</strong>，可以使用以下方法之一：</p>
<ul>
<li><p>使用 <code>scp</code> 命令<strong>：</strong>使用 <code>scp</code> 命令将公钥文件传输到远程服务器，在远程服务器上，将公钥内容追加到 <code>authorized_keys</code> 文件，但是本人不建议使用 <a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=scp&spm=1001.2101.3001.7020">scp</a> 发送，这样会对自己机器或者对方机器的原有配置造成覆盖或是丢失，存在风险。</p>
</li>
<li><p>手动复制：手动复制公钥文件 (<code>id_rsa_windows.pub</code>) 的内容，然后登录到远程服务器，并将内容粘贴到 <code>authorized_keys</code> 文件。如下是我生成的<code>id_rsa_windows.pub</code>文件内容：</p>
</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-fedd244c6b0b53051387658643bd3e77_r.jpg"></p>
<p>在远程服务器上，<code>authorized_keys</code> 文件通常存储在用户的 <code>.ssh</code> 目录中。具体路径可能为 <code>~/.ssh/authorized_keys</code>。例如我的用户名是 <code>liuwf</code>，那么 <code>authorized_keys</code> 文件的路径可能是 <code>/home/liuwf/.ssh/authorized_keys</code> 。</p>
<p>如果你的<code>.ssh</code>目录或者 <code>authorized_keys</code> 文件不存在，你可以在服务器终端使用以下命令创建它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建目录</span><br><span class="line">mkdir ~/.ssh</span><br><span class="line"># 进入目录</span><br><span class="line">cd ~/.ssh</span><br><span class="line"># 创建 authorized_keys 文件</span><br><span class="line">touch authorized_keys</span><br><span class="line"># 使用文本编辑器打开 authorized_keys 文件，并将你的公钥内容粘贴到其中</span><br><span class="line">nano authorized_keys</span><br><span class="line"># 保存并关闭文本编辑器。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不熟练使用终端，也可以使用 VSCode 的资源管理器直接创建，粘贴公钥后保存。</p>
<p><img src="https://pic1.zhimg.com/v2-643ffe31669e71cf1bd92915c4ab5478_r.jpg"></p>
<p>(2). 如果你本机是 <strong>Linux</strong>：</p>
<p><code>ssh-copy-id</code> 命令通常用于将你的公钥复制到远程服务器的 <code>authorized_keys</code> 文件中。<code>-i</code> 选项用于指定身份文件（即你的公钥文件）。在本机执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i id_rsa_Windows.pub name@ip</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>确保公钥文件 (<code>id_rsa_Windows.pub</code>) 在本地机器上的正确位置，并且你有读取该密钥的权限。同时，确保远程服务器上的用户 有一个 <code>.ssh</code> 目录，并且 <code>authorized_keys</code> 文件有正确的权限（通常是目录权限为 <code>700</code>，<code>authorized_keys</code> 文件权限为 <code>600</code>）。</p>
<p>然后将你的公钥 (<code>id_rsa_Windows.pub</code>) 的内容复制并追加到远程服务器的 <code>authorized_keys</code> 文件中。</p>
<h3 id="3-配置-SSH-客户端："><a href="#3-配置-SSH-客户端：" class="headerlink" title="3. 配置 SSH 客户端："></a>3. <strong>配置 SSH 客户端：</strong></h3><p>将添加公钥到远程服务器后，最后一步便是配置你的主机。</p>
<p>打开你的 SSH 客户端（本机）配置文件（也就是前面生成的 config 文件，一般在<code>C:\Users\YourUsername\.ssh\config</code>），添加配置（<code>IdentityFile</code> <strong>私钥</strong>文件路径），以指定使用哪个私钥文件。下图红框为我添加的内容。</p>
<p><img src="https://pic1.zhimg.com/v2-4060da4d55fc7bf0fbcd11c828f666b0_r.jpg"></p>
<p>这样，当你使用 ssh 连接服务器时，SSH 客户端将自动选择相应的私钥文件，就可以实现免密登录了。</p>
<p>参考链接：</p>
<p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/qq_56845026/article/details/130639709">配置 SSH 多账户配置不冲突_ssh 多用户 - CSDN 博客</a><a href="https://link.zhihu.com/?target=https://blog.csdn.net/u011762522/article/details/119352495">【大数据技术】多台机器配置 ssh 免密登录的最快捷最不易出错的方法_如何实现不同机器间无密码连接_daydayup-2016 的博客 - CSDN 博客</a><a href="https://zhuanlan.zhihu.com/p/222452460">undefined</a></p>
<p>update 2023&#x2F;11&#x2F;17</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 python 字节码</title>
    <url>/2024/04/22/Python%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<p><a href="https://so.csdn.net/so/search?q=Python&spm=1001.2101.3001.7020">Python</a> 通常被描述为一种 <strong>解释型语言</strong>，在这类语言中，源代码在程序运行时被 “翻译” 成 “指令”，但这还不够确切。同许多解释型语言一样，Python 在正式处理代码前，内部先进行预处理，将 Python 源代码编译成字节码，然后将其转发至 Python 虚拟机中。换言之，<strong>Python 实际上将源代码编译为 “虚拟机” 的一组指令，而这种中间格式的指令便称为 “字节码”</strong>。</p>
<span id="more"></span>

<h3 id="字节码编译"><a href="#字节码编译" class="headerlink" title="字节码编译"></a>字节码编译</h3><p>执行 Python 程序时，Python 内部将隐式地将 <strong>源代码 (source code)</strong> 编译成 <strong>字节码 (byte code)<strong>。编译可以理解为一种简单的 “翻译” 步骤，</strong>但有别于 C、C++ 等静态语言的编译</strong>；字节码则是一种 <strong>低级的</strong>、<strong>与平台无关的</strong> 代码表现形式，*<em>但有别于</em>***机器的二进制代码 (如 Intel 或 ARM 芯片的指令)**。简言之，Python 将源代码语句的每一条分解为单一步骤，从而 “翻译” 为一组字节码指令。相比于文本文件中的 Python 源代码，字节码的运行速度更快。</p>
<p>注意，上述过程的发生对大多数用户而言是隐式的。若 Python 进程在机器上拥有写入权限， 那么它将把程序的字节码保存为一个 <strong>.pyc</strong> <strong>文件</strong> (即已编译的 Python 源文件 (.py compiled)) 。在 Python3 中，**.pyc 字节码文件** 被存储在名为 <strong><strong>pycache</strong></strong> 的子目录中，该子目录位于与 .py 源文件相同的路径下。而 <strong>pycache</strong> 子目录中的文件命名中包含了编译它们的 Python 的版本信息 (基于创建它的特定 Python 进制代码版本，如 test.<strong>cpython-36</strong>.pyc) 。例如：</p>
<p>在 Windows 下创建一个 test.py 文件：</p>
<p><img src="https://img-blog.csdnimg.cn/20200523141631484.png"></p>
<p>然后在 IDE 中编译 (后续说明原因)，在 test.py 所在目录下可以显式看到多出了一个 <strong>pycache</strong> 子目录：</p>
<p><img src="https://img-blog.csdnimg.cn/20200523125801716.png"></p>
<p>进入 <strong>pycache</strong> 子目录中可以看到其字节码文件  test.cpython-36.pyc：</p>
<p><img src="https://img-blog.csdnimg.cn/20200523125901740.png"></p>
<p>在记事本中打开，可见由于编码问题无法直接阅读，但可以看到 test.py 的程序主体也在其中：</p>
<p><img src="https://img-blog.csdnimg.cn/20200523141519552.png"></p>
<p>事实上，当一个模块首次被导入或修改已编译的源文件时，都会在 .py 所在目录的 <strong>pycache</strong> 的子目录下创建一个包含已编译代码的 .pyc 文件。新创建的 <strong>pycache</strong> 子目录能够 <strong>避免太多文件挤在同一路径下</strong>，而新的字节码文件命名规范确保了同一主机上安装的不同版本的 Python 所生成的字节码文件 <strong>不会相互覆盖</strong>。当然，这些字节码文件都是自动生成的，与大多数 Python 程序无关，也随着不同版本的 Python 有着不同的形式。</p>
<p>上述 Python 保存字节码的方式是对 Python 程序 <strong>启动速度</strong> 的一种优化 (<strong>而非运行速度的优化</strong>)。下次运行程序时，若上次保存字节码后未再修改过源代码，并且使用同一个 Python 编译器版本运行， 那么 Python 将会加载 .pyc 文件并跳过编译步骤。该过程工作原理如下：</p>
<blockquote>
<ul>
<li><strong>源文件的改变</strong>：Python 会自动检查源文件和字节码文件最后一次修改的时间戳，以确认是否必须重新编译：若源代码被编辑并保存，则下次程序运行时，将自动重新创建字节码文件。</li>
<li><strong>Python 的版本</strong>：导入 (import) 机制会检查是否需要因使用了不同的 Python 版本而重新编译，这些版本信息在 Python3 中存储于字节码文件名中间部分。</li>
</ul>
</blockquote>
<p>可见，源文件的修改和 Python 版本的改变都会触发新的字节码文件的编译。导入模块时，若同时存在 .py 和 .pyc 文件，Python 将优先使用 .pyc 文件运行；若 .pyc 文件的编译时间早于 .py 的时间，则将重新编译 .py 并更新 .pyc 文件。还有，字节码文件也是发布 Python 程序的方法之一。若 Python 只找到 .pyc 字节码文件，而未找到对应的原始 .py 源代码文件，它也很 “乐意” 运行该程序。</p>
<p><strong>即便 Python 无法在机器上写入字节码， 程序也可以正常工作 —— 字节码会在内存中生成， 并在程序结束时直接被丢弃</strong> (这就是在 IDE 中只点击 “运行” 不会看到 .pyc 文件的原因，若要显式查看还需要在 IDE 中手动点击“编译”)。然而，由于 .pyc 文件具有加速启动的作用，最好确保在大型程序中能够创建它们。</p>
<p>最后，字节码只会针对那些被导入 (import) 的文件而生成， 而不是顶层的执行脚本 (严格来说，这是一种针对 “导入” 的优化)。此外，文件仅在程序运行 (或编译) 时才会被导入，而在交互式命令行中输入的命令并不会生成字节码。</p>
<h3 id="Python-虚拟机-PVM"><a href="#Python-虚拟机-PVM" class="headerlink" title="Python 虚拟机 (PVM)"></a>Python 虚拟机 (PVM)</h3><p>一旦源程序编译成字节码 (或从已存在的 .pyc 文件中载入字节码)，便会将字节码发送到被称为 <strong>Python 虚拟机 (Python Virtual Machine, PVM)</strong> 的程序上来执行。不同于大名鼎鼎的 JAVA 虚拟机 (JVM)，Python 虚拟机 (PVM) 相对鲜为人知，其中一个原因在于 PVM 是更为知名的 <strong>Python 解释器 (Python Interpreter)</strong> 的一部分 (如 CPython 使用了基于堆栈的虚拟机)。但不同于诸如 Vmware 那种 <strong>系统虚拟机</strong>，此处指的是类似 JVM、CLR 的 <strong>程序虚拟机</strong>。</p>
<p>常见的 Python 解释器有：</p>
<p><img src="https://img-blog.csdnimg.cn/20200523150938912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4NDAz,size_16,color_FFFFFF,t_70"></p>
<p>简单来说，<strong>Python 解释器</strong> 由一个 <strong>编译器 (compiler)</strong> 和一个 <strong>虚拟机</strong> 构成，<strong>编译器负责将源代码转换成字节码文件，而虚拟机负责执行字节码。</strong>所以，解释型语言其实也有隐式的编译过程，只不过该编译过程并非直接生成目标代码，而是生成中间代码 (字节码)，然后再通过虚拟机来逐行解释执行字节码。</p>
<p>更具体地，PVM 并非一个独立程序，也无须安装。本质上，PVM 可以理解为一个 <strong>迭代运行字节码指令的 “大循环”</strong> —— 一个接一个地完成操作。PVＭ 作为 <strong>Python 的运行时引擎</strong>，时常表现为 Python 系统的一部分，并且作为实际运行脚本的组件。从程序运行的技术流程上看，PVM 是 <strong>Python 解释器运行程序的最后一步</strong>。下图展示了 Python 运行时的简化执行模型：</p>
<p><img src="https://img-blog.csdnimg.cn/2020052314241452.png"></p>
<p>事实上，程序员编写的由源代码构成的 .py 源文件，先被自动编译为由字节码构成的 .pyc 字节码文件，然后被传递给 Python 虚拟机 (PVM) 中运行。注意，.pyc 文件是字节码在磁盘上的表现形式，而字节码在 PVM 程序里对应的是 PyCodeObject 对象 (import 模块时创建该对象)。PVM 会字节码当前的上下文环境中，从编译得到的 PyCodeObject 对象中逐条执行字节码指令，从而完成程序的执行。关于更深层的源码分析则大可不必深究。</p>
<p>总体上，操作系统中执行程序离不开两个概念：<strong>进程和线程</strong>。Python 通过 PyInterpreterState 和 PyTreadState 分别模拟进程和线程的概念。其中，每个 PyThreadState 都对应着一个帧栈，PVM 在多个线程上切换。当 PVM 开始执行时，它会先进行一些初始化操作，最后进入 PyEval_EvalFramEx 函数，它的作用是不断读取编译好的字节码并逐条执行，类似 CPU 执行指令的过程。PyEval_EvalFramEx 函数内部主要是一个 switch 结构，根据字节码的不同执行不同的代码。</p>
<p>总之，程序员只需简单地编写代码并运行文件，而 Python 会负责所有运行这些文件的逻辑。</p>
<h3 id="性能意义"><a href="#性能意义" class="headerlink" title="性能意义"></a>性能意义</h3><p>倘若熟悉 C 和 C++ 这类完全编译语言，则很容易发现 Python 运行模式中的一些差异。例如，Python 的执行流程中通常 <strong>没有 build &#x2F; make 的步骤</strong>，而是写完代码立即执行 (run)；<strong>Python 字节码并非机器的二进制代码</strong> (如 Intel 或 ARM 芯片的指令)。其实，字节码是特定于 Python 的一种表现形式。这就是为什么 <strong>Python 代码难以运行得像 C 或 C++ 代码一样快，因为 PVM 循环 (而非 CPU 芯片) 仍需逐行解释字节码，并且相比于 CPU 指令，执行字节码指令需要更多的工作</strong>。另一方面，与其他经典的解释器不同，Python 仍有内部的编译步骤，即无需反复地重新分析、分解每行源代码语句的文本 (所以 Python 又比经典的解释型语言更快些)。在上述机制的综合作用下，Python 代码的运行速度介于传统的编译语言和传统的解释语言之间。</p>
<h3 id="开发意义"><a href="#开发意义" class="headerlink" title="开发意义"></a>开发意义</h3><p>Python 执行模型所导致的另一个结果是：Python 的开发和执行环境实际上并无区别。换言之，<strong>编译和执行源代码的系统是同一个系统</strong>。在 Python 中，编译器总是在运行时出现，并作为运行程序系统的一部分，从而将大大缩短开发周期，<strong>提升开发效率</strong>。在程序开始执行前，无需预编译和链接，只需简单地输入并运行代码即可。这同样让 Python 带上了更浓厚的 <strong>动态语言</strong> 色彩：在运行时， Python 程序去构建并执行另一个 Python 程序是可能的，且往往非常方便。例如，eval 和 exec 内置模块能够接受并运行包含 Python 程序代码的字符串。上述结构是 Python 能够实现产品定制的原因：因为 Python 代码可以动态地被修改，用户可以改进系统内部的 Python 部分，而无需拥有或编译整个系统的代码。</p>
<p>总而言之，Python 完全不需要初始的编译阶段，所有的事情都是在程序运行时发生的，甚至包括建立函数和类的操作以及模块的链接。而这些工作对于静态语言而言，往往发生在执行之前。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2022/03/04/git/</url>
    <content><![CDATA[<h2 id="git-命令使用"><a href="#git-命令使用" class="headerlink" title="git 命令使用"></a>git 命令使用</h2><p>开始使用 git 的简易指南<br>更多可以参考: (<a href="http://book.git-scm.com/">http://book.git-scm.com/</a>)</p>
<span id="more"></span>

<h3 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h3><p>创建新文件夹，打开，然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init </span><br></pre></td></tr></table></figure>
<p> 以创建新的 git 仓库。</p>
<h3 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h3><p>执行如下命令以创建一个本地仓库的克隆版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> /path/to/repository</span><br></pre></td></tr></table></figure>
<p>如果是远端服务器上的仓库，你的命令会是这个样子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> username@host:/path/to/repository</span><br></pre></td></tr></table></figure>

<h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录,它持有实际文件；第二个是 缓存区，它像个缓存区域(Index)，临时保存你的改动；最后是 HEAD，指向你最近一次提交后的结果。 </p>
<h3 id="添加与提交"><a href="#添加与提交" class="headerlink" title="添加与提交"></a>添加与提交</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add filename</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add *</span><br></pre></td></tr></table></figure>
<p>这是 git 基本工作流程的第一步；使用如下命令以实际提交改动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;代码提交信息&quot;</span></span><br></pre></td></tr></table></figure>
<p>现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。</p>
<h3 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h3><p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>可以把 <i>master</i> 换成你想要推送的任何分支。</p>
<p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin &lt;server&gt; </span><br></pre></td></tr></table></figure>
<p>如此你就能够将你的改动推送到所添加的服务器上去了。</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master&#x2F;main 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上创建一个叫做“branch_x”的分支，并切换过去：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b branch_x</span><br></pre></td></tr></table></figure>
<p>切换回主分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b main</span><br></pre></td></tr></table></figure>
<p>再把新建的分支删掉：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d branch_x</span><br></pre></td></tr></table></figure>
<p>除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h3><p>要更新你的本地仓库至最新改动，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure>

<p>以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。要合并其他分支到你的当前分支（例如 master），执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）。 这时候就需要你修改这些文件来人肉合并这些 冲突（conflicts） 。改完之后，你需要执行如下命令以将它们标记为合并成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>在合并改动之前，也可以使用如下命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff &lt;source_branch&gt; &lt;target_branch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h3><p>假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- &lt;file name&gt;</span><br></pre></td></tr></table></figure>
<p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。</p>
<p>假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch origin</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard origin/master </span><br></pre></td></tr></table></figure>

<p>显示历史记录时，只显示一行注释信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config format.pretty oneline</span><br></pre></td></tr></table></figure>


<h3 id="github-com和raw-githubusercontent-com访问不了的解决方法"><a href="#github-com和raw-githubusercontent-com访问不了的解决方法" class="headerlink" title="github.com和raw.githubusercontent.com访问不了的解决方法"></a>github.com和raw.githubusercontent.com访问不了的解决方法</h3><p>本文链接 <a href="https://www.ioiox.com/archives/62.html">https://www.ioiox.com/archives/62.html</a><br>这里还有免费FRP!!!</p>
<h3 id="修改-hosts"><a href="#修改-hosts" class="headerlink" title="修改 hosts"></a>修改 hosts</h3><p>在 hosts 文件添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">199.232.4.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure>

<h3 id="使用gh-proxy来代理访问"><a href="#使用gh-proxy来代理访问" class="headerlink" title="使用gh-proxy来代理访问"></a>使用gh-proxy来代理访问</h3><p>gh-proxy 是一款 github release、archive以及项目文件的加速项目，支持直接在终端 git clone ,也可以在 web 端代理下载 github 以及 raw.githubusercontent.com 等文件.<br>项目默认使用jsdelivr和cnpmjs</p>
<p>支持终端命令行下载 , 例如 git clone , wget , curl 等以及 raw.githubusercontent.com 文件下载.<br>注意：不支持 SSH Key 方式 git clone 下载.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone</span><br><span class="line">git clone https://ghproxy.com/https://github.com/stilleshan/ServerStatus.git</span><br><span class="line"></span><br><span class="line">wget &amp; curl</span><br><span class="line">wget https://ghproxy.com/https://github.com/stilleshan/ServerStatus/archive/master.zip</span><br><span class="line">wget https://ghproxy.com/https://raw.githubusercontent.com/stilleshan/ServerStatus/master/Dockerfile</span><br><span class="line">curl -O https://ghproxy.com/https://github.com/stilleshan/ServerStatus/archive/master.zip</span><br><span class="line">curl -O https://ghproxy.com/https://raw.githubusercontent.com/stilleshan/ServerStatus/master/Dockerfile</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>python fabric 自动化</title>
    <url>/2024/03/28/fabric/</url>
    <content><![CDATA[<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><em>作用</em></h3><p>很强大的工具</p>
<p>可以将自动化部署或者多机操作的命令固化到一个脚本里</p>
<p>和某些运维工具很像，用它主要是因为，python…..</p>
<p>简单好用易上手</p>
<p>当然，shell 各种命令组合起来也可以，上古神器和现代兵器的区别</p>
<p>网上能找到的 fabric 大多东摘西抄, 程序不能运行. 锅主要由 fabric 来背, 一开始他们并不支持 python3, 所以当 python3 流行之后, 以前针对 python2 的 fabric 教程就基本不能用了; 于是有热心程序员们搞了个非官方的 fabric3 , 写了一些教程 (很少且很多文章是错的), 但后来 fabric 官方支持了 python3 , 也出了个教程…</p>
<p>于是在互联网上至少存在 3 种 fabric 教程. 针对 python2 的, 针对非官方 python3 版本的, 还有官方 python3 官方版本的, 初学者大概会被弄得要发疯了吧…</p>
<span id="more"></span>

<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>在本机和目标机器安装对应包（注意，都要有）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo easy_install fabric</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目前是 1.6 版本（或者用 pip install，一样的）</p>
<p>安装完后，可以查看是否安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ken@~$] which fab</span><br><span class="line">/usr/local/bin/fab</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>装完之后，可以浏览下<a href="http://docs.fabfile.org/en/1.6/">官方文档</a></p>
<p>然后，可以动手了</p>
<h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><p>先进行本机简单操作，有一个初步认识，例子来源与官网</p>
<p>新建一个 py 脚本: fabfile.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def hello():</span><br><span class="line">    print(&quot;Hello world!&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>命令行执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ken@~/tmp/fab$] fab hello</span><br><span class="line">Hello world!</span><br><span class="line"></span><br><span class="line">Done.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，这里可以不用 fabfile 作为文件名，但是在执行时需指定文件</p>
<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ken@~/tmp/fab$] mv fabfile.py test.py</span><br><span class="line">fabfile.py -&gt; test.py</span><br><span class="line">[ken@~/tmp/fab$] fab hello</span><br><span class="line"></span><br><span class="line">Fatal error: Couldn&#x27;t find any fabfiles!</span><br><span class="line"></span><br><span class="line">Remember that -f can be used to specify fabfile path, and use -h for help.</span><br><span class="line"></span><br><span class="line">Aborting.</span><br><span class="line">[ken@~/tmp/fab$] fab -f test.py hello</span><br><span class="line">Hello world!</span><br><span class="line"></span><br><span class="line">Done.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<p>带参数：</p>
<p>修改 fabfile.py 脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def hello(name, value):</span><br><span class="line">    print(&quot;%s = %s!&quot; % (name, value))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行</p>
<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ken@~/tmp/fab$] fab hello:name=age,value=20</span><br><span class="line">age = 20!</span><br><span class="line"></span><br><span class="line">Done.</span><br><span class="line">[ken@~/tmp/fab$] fab hello:age,20</span><br><span class="line">age = 20!</span><br><span class="line"></span><br><span class="line">Done.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<h3 id="执行本机操作"><a href="#执行本机操作" class="headerlink" title="执行本机操作"></a>执行本机操作</h3><p>简单的本地操作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from fabric.api import local</span><br><span class="line"></span><br><span class="line">def lsfab():</span><br><span class="line">    local(&#x27;cd ~/tmp/fab&#x27;)</span><br><span class="line">    local(&#x27;ls&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ken@~/tmp/fab$] pwd;ls</span><br><span class="line">/Users/ken/tmp/fab</span><br><span class="line">fabfile.py   fabfile.pyc  test.py      test.pyc</span><br><span class="line">[ken@~/tmp/fab$] fab -f test.py lsfab</span><br><span class="line">[localhost] local: cd ~/tmp/fab</span><br><span class="line">[localhost] local: ls</span><br><span class="line">fabfile.py  fabfile.pyc test.py     test.pyc</span><br><span class="line"></span><br><span class="line">Done.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<p>实战开始：</p>
<p>假设，你每天要提交一份配置文件 settings.py 到版本库（这里没有考虑冲突的情况）</p>
<p>如果是手工操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/project/test/conf/</span><br><span class="line">git add settings.py</span><br><span class="line">git commit -m &#x27;daily update settings.py&#x27;</span><br><span class="line">git pull origin</span><br><span class="line">git push origin</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是说，这几个命令你每天都要手动敲一次，所谓 daily job，就是每天都要重复的，机械化的工作，让我们看看用 fabric 怎么实现一键搞定：(其实用 shell 脚本可以直接搞定，但是 fab 的优势不是在这里，这里主要位后面本地 + 远端操作做准备，毕竟两个地方的操作写一种脚本便于维护)</p>
<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from fabric.api import local</span><br><span class="line"></span><br><span class="line">def setting_ci():</span><br><span class="line">    local(&quot;cd /home/project/test/conf/&quot;)</span><br><span class="line">    local(&quot;git add settings.py&quot;)</span><br><span class="line">    #后面你懂的，懒得敲了…..</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<h3 id="混搭整合远端操作"><a href="#混搭整合远端操作" class="headerlink" title="混搭整合远端操作"></a>混搭整合远端操作</h3><p>这时候，假设，你要到机器 A 的 &#x2F; home&#x2F;ken&#x2F;project 对应项目目录把配置文件更新下来</p>
<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># encoding: utf-8</span><br><span class="line"></span><br><span class="line">from fabric.api import local,cd,run</span><br><span class="line"></span><br><span class="line">env.hosts=[&#x27;user@ip:port&#x27;,] #ssh要用到的参数</span><br><span class="line">env.password = &#x27;pwd&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def setting_ci():</span><br><span class="line">    local(&#x27;echo &quot;add and commit settings in local&quot;&#x27;)</span><br><span class="line">    #刚才的操作换到这里，你懂的</span><br><span class="line"></span><br><span class="line">def update_setting_remote():</span><br><span class="line">    print &quot;remote update&quot;</span><br><span class="line">    with cd(&#x27;~/temp&#x27;):   #cd用于进入某个目录</span><br><span class="line">        run(&#x27;ls -l | wc -l&#x27;)  #远程操作用run</span><br><span class="line"></span><br><span class="line">def update():</span><br><span class="line">    setting_ci()</span><br><span class="line">    update_setting_remote()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<p>然后，执行之：</p>
<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ken@~/tmp/fab$] fab -f deploy.py update</span><br><span class="line">[user@ip:port] Executing task &#x27;update&#x27;</span><br><span class="line">[localhost] local: echo &quot;add and commit settings in local&quot;</span><br><span class="line">add and commit settings in local</span><br><span class="line">remote update</span><br><span class="line">[user@ip:port] run: ls -l | wc -l</span><br><span class="line">[user@ip:port] out: 12</span><br><span class="line">[user@ip:port] out:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Done.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<p>注意，如果不声明 env.password，执行到对应机器时会跳出要求输入密码的交互</p>
<h3 id="多服务器混搭"><a href="#多服务器混搭" class="headerlink" title="多服务器混搭"></a>多服务器混搭</h3><p>操作多个服务器，需要配置多个 host</p>
<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># encoding: utf-8</span><br><span class="line"></span><br><span class="line">from fabric.api import *</span><br><span class="line"></span><br><span class="line">#操作一致的服务器可以放在一组，同一组的执行同一套操作</span><br><span class="line">env.roledefs = &#123;</span><br><span class="line">            &#x27;testserver&#x27;: [&#x27;user1@host1:port1&#x27;,],  </span><br><span class="line">            &#x27;realserver&#x27;: [&#x27;user2@host2:port2&#x27;, ]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">#env.password = &#x27;这里不要用这种配置了，不可能要求密码都一致的，明文编写也不合适。打通所有ssh就行了&#x27;</span><br><span class="line"></span><br><span class="line">@roles(&#x27;testserver&#x27;)</span><br><span class="line">def task1():</span><br><span class="line">    run(&#x27;ls -l | wc -l&#x27;)</span><br><span class="line"></span><br><span class="line">@roles(&#x27;realserver&#x27;)</span><br><span class="line">def task2():</span><br><span class="line">    run(&#x27;ls ~/temp/ | wc -l&#x27;)</span><br><span class="line"></span><br><span class="line">def dotask():</span><br><span class="line">    execute(task1)</span><br><span class="line">    execute(task2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<p>结果：</p>
<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ken@~/tmp/fab$] fab -f mult.py dotask</span><br><span class="line">[user1@host1:port1] Executing task &#x27;task1&#x27;</span><br><span class="line">[user1@host1:port1] run: ls -l | wc -l</span><br><span class="line">[user1@host1:port1] out: 9</span><br><span class="line">[user1@host1:port1] out:</span><br><span class="line"></span><br><span class="line">[user2@host2:port2] Executing task &#x27;task2&#x27;</span><br><span class="line">[user2@host2:port2] run: ls ~/temp/ | wc -l</span><br><span class="line">[user2@host2:port2] out: 11</span><br><span class="line">[user2@host2:port2] out:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Done.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ol>
<li>颜色</li>
</ol>
<p>可以打印颜色，在查看操作结果信息的时候更为醒目和方便</p>
<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from fabric.colors import *</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">    print green(&#x27;success&#x27;)</span><br><span class="line">    print red(&#x27;fail&#x27;)</span><br><span class="line">    print yellow(&#x27;yellow&#x27;)</span><br><span class="line">#fab -f color.py show</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<ol start="2">
<li>错误和异常</li>
</ol>
<p>关于<a href="http://docs.fabfile.org/en/1.6/usage/execution.html#failures">错误处理</a></p>
<p>默认，一组命令，上一个命令执行失败后，不会接着往下执行</p>
<p>失败后也可以进行不一样的处理， <a href="http://docs.fabfile.org/en/1.6/tutorial.html#failure-handling">文档</a></p>
<p>目前没用到，后续用到再看了</p>
<ol start="3">
<li>密码管理</li>
</ol>
<p>看<a href="http://docs.fabfile.org/en/1.6/usage/execution.html#password-management">文档</a></p>
<p>更好的密码管理方式，哥比较土，没打通，主要是服务器列表变化频繁，我的处理方式是：</p>
<p>1.host,user,port,password 配置列表，所有的都写在一个文件</p>
<p>或者直接搞到脚本里，当然这个更……..</p>
<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env.hosts = [</span><br><span class="line"></span><br><span class="line">&#x27;host1&#x27;,</span><br><span class="line"></span><br><span class="line">&#x27;host2&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">]</span><br><span class="line">env.passwords = &#123; </span><br><span class="line">&#x27;host1&#x27;: &quot;pwdofhost1&quot;,</span><br><span class="line">&#x27;host2&#x27;: &quot;pwdofhost2&quot;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 或者</span><br><span class="line"></span><br><span class="line">env.roledefs = &#123;</span><br><span class="line">&#x27;testserver&#x27;: [&#x27;host1&#x27;, &#x27;host2&#x27;],</span><br><span class="line">&#x27;realserver&#x27;: [&#x27;host3&#x27;, ]</span><br><span class="line">&#125;</span><br><span class="line">env.passwords = &#123;</span><br><span class="line">&#x27;host1&#x27;: &quot;pwdofhost1&quot;,</span><br><span class="line">&#x27;host2&#x27;: &quot;pwdofhost2&quot;,</span><br><span class="line">&#x27;host3&#x27;: &quot;pwdofhost3&quot;, </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);" title="复制代码"><img src="http://assets.cnblogs.com/images/copycode.gif"></a></p>
<ol start="2">
<li>根据 key 解析成 map 嵌套，放到 deploy 中</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>F1C100s 启动</title>
    <url>/2024/03/08/f1c100s%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="sunxi-tools"><a href="#sunxi-tools" class="headerlink" title="sunxi-tools"></a>sunxi-tools</h3><p>Sunxi-tools 是一组命令行工具，用于操作基于全志 SoC 的 ARM 设备。它们可以用于各种目的，比如在 FEX 和二进制格式之间转换，操作 PIO 设置，访问 FEL 工厂模式，以及编程 SPI 闪存。</p>
<p>今天咱们研究下如何在 Windows 环境下使用 sunxi-tools。</p>
<span id="more"></span>


<p>下载并解压缩</p>
<p>Zadig 用于安装 sunxi-tools windows 驱动安装。</p>
<p>Zadig USB 是一个开源的 USB 驱动程序安装工具，它允许用户更改 USB 设备的驱动程序。这个工具通常用于 Windows 操作系统，用于安装 WinUSB、libusb、usbser 等驱动程序。</p>
<p>开发板进入烧写模式</p>
<p>短路 V3S（F1C100s&#x2F;F1C200s&#x2F;V3s）板子的 spi flash 1,4 或 1,2 脚, 上电（通过 USB 线进入接入电脑）电脑检测到新的 usb 烧写设备。</p>
<h3 id="H3-四核Cortex-A7-32bit"><a href="#H3-四核Cortex-A7-32bit" class="headerlink" title="H3 四核Cortex-A7 32bit"></a>H3 四核Cortex-A7 32bit</h3><p><a href="https://www.armbian.com/nanopi-neo/">https://www.armbian.com/nanopi-neo/</a><br>镜像<br><a href="https://github.com/armbian/community/releases/download/24.5.0-trunk.306/Armbian_community_24.5.0-trunk.306_Nanopineo_jammy_current_6.6.23.img.xz">https://github.com/armbian/community/releases/download/24.5.0-trunk.306/Armbian_community_24.5.0-trunk.306_Nanopineo_jammy_current_6.6.23.img.xz</a> root 1234</p>
<h3 id="F1C100S-ARM9-ARM926EJ-S-32bit"><a href="#F1C100S-ARM9-ARM926EJ-S-32bit" class="headerlink" title="F1C100S ARM9 ARM926EJ-S 32bit"></a>F1C100S ARM9 ARM926EJ-S 32bit</h3><p>F1C100s 的内核是 ARM926EJ-S ，ARMv5 架构，有 MMU，没有硬件 FPU，主频默认为 408MHz；</p>
<h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Manufacturer    Allwinner</span><br><span class="line">CPU             ARM ARM926EJ-S @ 533MHz</span><br><span class="line">                L1 Cache: 16KB Data, 32KB Instruction</span><br><span class="line">                FPU: None</span><br><span class="line">Memory          32MB Embedded DDR (F1C100s) or 64MB Embedded DDR (F1C200s)</span><br><span class="line">GPU              Custom 2D-only</span><br><span class="line">VPU              Unknown</span><br><span class="line">Video            LCD, CVBS</span><br><span class="line">Audio            DAC</span><br><span class="line">Storage          SD/MMC (SD v2.0, eMMC V4.41)</span><br><span class="line">USB              USB 2.0 OTG</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="功能框图"><a href="#功能框图" class="headerlink" title="功能框图"></a>功能框图</h4><p><img src="https://aijishu.com/img/bVbJ2K"></p>
<h4 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h4><p><img src="https://aijishu.com/img/bVbJ2L"></p>
<ul>
<li>F1C100s 的内核是 ARM926EJ-S ，ARMv5 架构，有 MMU，没有硬件 FPU，主频默认为 408MHz；</li>
<li>F1C100s 内置 32MB DDR1 内存；</li>
<li>F1C200s 是 F1C100s 的兄弟型号，其它特性都相同，内存容量翻倍为 64MB；</li>
</ul>
<h4 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h4><p>1、上电后, f1c100s 内部 BROM (芯片内置，无法擦除) 启动；<br>2、首先检查 SD0 有没有插卡, 如果有插卡就读卡 8k 偏移数据，是否是合法的启动数据, 如果是 BROM 引导结束, 否则进入下一步；<br>3、检测 SPI0 NOR FLASH(W25QXXX, MX25LXXX) 是否存在, 是否有合法的启动数据, 如果是 BROM 引导结束, 否则进入下一步；<br>4、检测 SPI0 NAND FLASH 是否存在, 是否有合法的启动数据, 如果是 BROM 引导结束, 否则进入下一步；<br>5、因为找不到任何可以引导的介质， 系统进入 usb fel 模式， 可以用 USB 烧录了。<br>对于 F1C100s 而言启动时寻找用户程序的位置顺序如下：</p>
<ul>
<li>SDC0 接口（PF0~PF5）上的 SD（TF）卡；</li>
<li>SPI0 接口（PC0~PC3）上的 Nor Flash；</li>
<li>SPI0 接口（PC0~PC3）上的 Nand Flash；<br>对于 SD（TF）卡而言在它上面的数据存储布局通常如下：</li>
</ul>
<table><thead><tr><th>start</th><th>sector</th><th>size</th><th>usage</th></tr></thead><tbody><tr><td>0KB</td><td>0</td><td>8KB</td><td>Unused, available for an MBR or (limited) GPT partition table</td></tr><tr><td>8KB</td><td>16</td><td>32KB</td><td>Initial SPL loader</td></tr><tr><td>40KB</td><td>80</td><td>Max 984KB</td><td>U-Boot</td></tr><tr><td>1MB</td><td>2048</td><td>-</td><td>bootfs and rootfs</td></tr></tbody></table>

<p>上面参数中 SPL 从 8K 位置开始不能动（这是由 BROM 决定的）；文件系统可以根据需要来分区，boot 分区在前，通常为 FAT 格式。</p>
<p>编译后得到 u-boot-sunxi-with-spl.bin 这个文件会拼合 spl 和 u-boot ，直接把这个文件写入到 8KB 开始的位置就行了。</p>
<p>对于 SPI Flash 而言其实和 SD（TF）卡而言差不多，最关键的就是将 u-boot-sunxi-with-spl.bin 文件放在头部，即从 0 位置开始写入；其它内容根据需求而设置，只要对应的调整 u-boot 读取启动内核时相关位置参数就行。</p>
<p>需要注意的是默认情况下 SPI Flash 最大支持 16M，更大就需要在程序中设置 bank 了。</p>
<h4 id="fel-模式"><a href="#fel-模式" class="headerlink" title="fel 模式"></a>fel 模式</h4><p>上文中可以了解到 F1C100s 要是启动外部程序均失败的话就会进入 FEL 模式，用户可以通过 USB 和芯片进行交互 。在 FEL 模式你可以直接运行 u-boot 和 linux 等，也可以将数据写入 spiflash 中（可以用作烧录固件到设备中）。</p>
<p>FEL 模式其实也就是 BROM 上的一段程序，可以在 u-boot 命令行中使用 go 0xffff0020 跳转进入。另外也可以通过在 SD（TF）卡写入下面数据来通过 SD（TF）卡启动跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sdX 为SD（TF）卡，使用 sudo fdisk -l 查看</span><br><span class="line"># 如果有自动挂载的分区则逐条使用 sudo umount /dev/sdXn 进行卸载</span><br><span class="line">wget https://github.com/linux-sunxi/sunxi-tools/raw/master/bin/fel-sdboot.sunxi</span><br><span class="line">sudo dd if=fel-sdboot.sunxi of=/dev/sdX bs=1024 seek=8</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ARM926EJ-S</tag>
      </tags>
  </entry>
  <entry>
    <title>人生如赴宴，举止须从容</title>
    <url>/2034/05/04/life/</url>
    <content><![CDATA[<h1 id="人生如赴宴，举止须从容"><a href="#人生如赴宴，举止须从容" class="headerlink" title="人生如赴宴，举止须从容"></a>人生如赴宴，举止须从容</h1><p>人和动物&#x2F;野兽的区别，人是有智慧的。身体由大脑控制，大脑是由思想，意志等控制着。所以需要训练大脑，增强意志力，拥有更强的自控力。如同计算机发出指令，最简单的if&#x2F;else判断语句后面都有一个True&#x2F;Flase。人也一样，一个优秀的人，在做出主动选择或者被动响应时，都应该由一个判断的过程，而这个判断的算法每个人都不一样。如何得到一个优秀的执行判断的神经网络模型，需要训练，多看（输入）、多做（输出）、多想（反馈），才能得到优化。</p>
<p>一个人的成长，是从全能自恋到真实自信的过程，也是从孤独自恋到有深情依恋的过程，同时是从想象进入现实的过程。<br>想象与现实的一个巨大差别是，想象可瞬间完成，而现实却需要时间和过程，它越重要，就越需要漫长的过程。</p>
<p>现代人的大脑结构，有好几个自我。它们相互竞争，试图控制我们的想法、感受和行动。每个意志力挑战都是一次自我博弈。要想让更好的自己占据主导，我们就要强化自我意识和自控力。这样，我们才会有意志力和“我想要”的力量。</p>
<p>作为一个遵纪守法的好人，也许我们从来没有想过和“暴力”扯上关系。不过如果稍微留意一下现实生活中的谈话方式，并且用心体会各种谈话方式给我们的不同感受，我们一定会发现有些话确实伤人！言语上的指责、嘲讽、否定、说教以及任意打断、拒不回应、随意出口的评价和结论给我们带来的情感和精神上的创伤，甚至比肉体的伤害更加令人痛苦。这些无心或有意的语言暴力让人变得冷漠、隔膜、敌视。</p>
<span id="more"></span>

<h2 id="全能自恋"><a href="#全能自恋" class="headerlink" title="全能自恋"></a>全能自恋</h2><ul>
<li>你只是一个人，不是生来就全能，需要不断的学习和实践。</li>
<li>行动和投入是对全能自恋的直接治疗方法。</li>
<li>一些事情我们自己能控制，另一些则不能。学会区分什么你能控制的，什么你不能控制的。</li>
</ul>
<h2 id="自控力"><a href="#自控力" class="headerlink" title="自控力"></a>自控力</h2><p>如果你想要更强的自控力，就得有更多的自我意识，要意识到自己在做什么，为什么要这样做（什么样的想法、感受和情况最容易让你有冲动，想些什么或暗示什么最容易让你放弃冲动）。</p>
<ul>
<li>任何时候，我们都有选择的空间。任何时候，我都可以选择我的行为，朝向你认为“好”的方向。哪怕是赴死，也可以选择从容、优雅一些。</li>
</ul>
<h4 id="脑力训练"><a href="#脑力训练" class="headerlink" title="脑力训练"></a>脑力训练</h4><p>经常挑战自己说<strong>我不要</strong>和<strong>我想要</strong>，日常冥想练习，让更多的血液流进前额皮质。<br>每天做10分钟冥想训练，注意力收回的过程就是自控力。</p>
<ol>
<li>原定不动，安静坐好。不要烦躁     </li>
<li>注意你的呼吸。闭上眼睛，吸气在脑海中默念“吸”，呼气时在脑海里默念“呼”。</li>
<li>感受呼吸，弄清自己是怎么走神的。集中注意力在呼吸上。</li>
</ol>
<h4 id="三思而后行"><a href="#三思而后行" class="headerlink" title="三思而后行"></a>三思而后行</h4><p>自控力不仅和心理有关，更和生理有关。只有在大脑和身体同时作用的瞬间，你才有力量克服冲动。当你最需要意志力的时候，你能够学会将自己的生理机能调整到这种状态。自控力就成了本能反应。<br>利用威胁，对生命的威胁，不做会死，例如剑齿虎的威胁，利用应激反应做启动，引出自控力。<br>深呼一口气，让你的身体进入更平静的状态，避免冲动行为，给自己更多的时间，让你深思熟虑想办法。</p>
<h4 id="降低你的心率"><a href="#降低你的心率" class="headerlink" title="降低你的心率"></a>降低你的心率</h4><p><strong>当人感受到压力时，交感神经系统会控制身体。这种生理现象让你能够战斗或者逃跑。心率升高，心率变异程度就会降低</strong>此时，由于伴随应激反应产生的焦虑或愤怒，心率会被迫保持在较高水平上。<strong>相反，当人们成功自控的时候，副交感神经系统会发挥主要作用，缓解压力，控制冲动行为。心率降低，心率变异程度便会升高。</strong></p>
<h2 id="非暴力沟通"><a href="#非暴力沟通" class="headerlink" title="非暴力沟通"></a>非暴力沟通</h2><p>非暴力沟通指导我们转变谈话和聆听的方式。我们不在条件反射式地反应，而是去明了自己的观察、感受和愿望，有意识的使用语言。尊重和倾听他人，又诚实、清晰地表达自己。<br><strong>听到批评时，我们一般会申辩、退缩或反击</strong>。然而，一旦<strong>专注于彼此的观察、感受及需要，而不反驳他人</strong>，我们便能发现内心的柔情，对自己和他人产生新的体会。通过强调倾听–<strong>倾听自己和他人</strong>，非暴力沟通培养彼此的尊重、关注与爱，使人乐于助人。</p>
<p>（发起方）非暴力沟通模式的四个要素（观察，感受，需求，请求），利用四要素诚实地表达自己。</p>
<ul>
<li>留意发生的事情，我们此刻<strong>观察</strong>到什么？清楚地表达观察结果，而不是判断或评估。</li>
<li>接着，表达<strong>感受</strong>，例如受伤、害怕、喜悦、开心、气愤等。</li>
<li>然受，说出哪些<strong>需要</strong>导致那样的感受。</li>
<li><strong>具体的请求</strong>，明确的告知他人，我们期待他采取何种行动，来满足我们。</li>
</ul>
<p>（接收方）非暴力沟通另一方面是借助它们关切地倾听。我们首先通过体会他人此刻的观察、感受和需要，和他们建立联系，然后聆听他们的请求，来发现做什么可以帮助他们。</p>
<p>实际应用<br>非暴力沟通不只是语言表达或使用文字的技巧，它包含的意识和意图，也可以通过沉默、专注以及面部表情和身体语言来表达。<strong>倾听每句话所包含的情感和感受，去了解，去询问。</strong></p>
<h3 id="是什么蒙蔽了爱"><a href="#是什么蒙蔽了爱" class="headerlink" title="是什么蒙蔽了爱"></a>是什么蒙蔽了爱</h3><p>是什么使我们难以体会到心中的爱，某些语言和表达方式的负面影响，它们虽然致力向于忽视人的感受和需要，以致彼此的疏远和伤寒。这些语言和表达方式，我称为“异化的沟通方式”。我们大多数的人使用的语言倾向于评判、比较、命令和指责 ，而不是鼓励我们倾听彼此的感受和需要。</p>
<h4 id="道德评判"><a href="#道德评判" class="headerlink" title="道德评判"></a>道德评判</h4><p>道德评判是用道德标准来评判人，如果一个人的行为不符合我们的价值观，那他就被看作是不道德的或者邪恶的。批评、指责、辱骂、归类、比较及评论等都是在评判人。<br><strong>苏菲派诗人鲁米写道：“在道德与不道德的区分之外，有片田野。我将在那里见你。”</strong><br>然而，语言使我们陷入是非之中。它擅长将人分类，把人看作好人或坏人，正常或不正常，负责人或者不负责任，聪明或愚蠢，等等。诸如此类的评论暗含着我们的价值观及需要。不幸的是，以这样的方式提出主张，很可能会招来敌意，使我们的愿望难得到满足，即使他们接受批评，做出让步，通常不是心甘情愿的。如果他们处于恐惧或内疚来迎合我们，或迟或早，我们将会发现对方不再那么友好。当然，他们也付出了代价。屈服于外部和内部的压力，很可能使他们心怀怨恨，并厌恶自己。<br>不要将价值判断于道德评判混为一谈，什么是可贵的品质，我们每个人都要自己的看法。例如，我们也许会欣赏诚实、自由以及和平的价值。</p>
<h4 id="进行比较"><a href="#进行比较" class="headerlink" title="进行比较"></a>进行比较</h4><p>比较也是批判的一种形式。比较蒙蔽了我们对人对己的爱意。如果真想过上悲惨生活，就去与他人做比较。<br>去和优秀的人比较，开始觉得自己活得很惨，心情极为低落。</p>
<h4 id="回避责任"><a href="#回避责任" class="headerlink" title="回避责任"></a>回避责任</h4><p>我们对自己的思想、情感和行动负有责任。不是因为“不得不”而去做一件事情，而是你负有不可推卸的责任，作为子女、伴侣、公民的责任，要有责任感，而不是唯名是从，服从命令。</p>
<h4 id="强人所难"><a href="#强人所难" class="headerlink" title="强人所难"></a>强人所难</h4><p>我们对别人的要求往往暗含着威胁,如果不配合，他们就会受到惩罚。</p>
<h2 id="道歉的五种语言"><a href="#道歉的五种语言" class="headerlink" title="道歉的五种语言"></a>道歉的五种语言</h2><p>冒犯他人后需要真诚的道歉，丈夫要妻子，关怀她，努力满足她的需求。美好婚姻的基石并不是完美的人，而愿意承认错误并寻求宽恕的心。</p>
<h3 id="变达歉意"><a href="#变达歉意" class="headerlink" title="变达歉意"></a>变达歉意</h3><p>说“对不起”，要让人感觉到我们的真诚，从身体语言动作上，看别人的眼神，说话的声音。<br><strong>真诚的道歉不能找借口，在道歉之后马上来个“但是…”, 应该另找时机进行沟通。</strong>一旦我们在口头上把责任推给对方(这就是指责)，道歉就会变成攻击。而攻击永远不会带来宽恕与和解。</p>
<ul>
<li>我现在才知道已经深深地伤害了你，这让我感到无比痛苦。我为自己的行为真诚地道歉。</li>
<li>我真的很难过，让你失望了。我本来应该更细心一些，很抱歉让你这么痛苦。</li>
<li>我当时显然没有认真考虑你地感受。我从来没打算要伤害你，但现在我知道我的话太过火了。<br>很抱歉，我当时那么的不礼貌。</li>
</ul>
<h3 id="承认过错"><a href="#承认过错" class="headerlink" title="承认过错"></a>承认过错</h3><p>借口又使他们觉得没必要道歉。不愿意承认错误是和自尊心分不开的。承认错误会被视为软弱，因为只有失败者才会人认错。<strong>成熟的成年人会学会为自己的行为承认责任。</strong> 不成熟的人则继续哪些幼稚的幻想，把自己的错误推卸给别人。<br>为自己的行为负责的核心是愿意承认<strong>我错了</strong>。真正的强大在于，有足够的智慧和勇气知错就改。</p>
<ul>
<li>我知道我做错了，毫无借口。说到底，我的做法很自私，我错了。</li>
<li>我又犯了一个我们以前讨论过的错误，把事情搞砸了。我知道只是我的错。</li>
</ul>
<h3 id="弥补过失"><a href="#弥补过失" class="headerlink" title="弥补过失"></a>弥补过失</h3><h3 id="真诚悔改"><a href="#真诚悔改" class="headerlink" title="真诚悔改"></a>真诚悔改</h3><h3 id="请求饶恕"><a href="#请求饶恕" class="headerlink" title="请求饶恕"></a>请求饶恕</h3>]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>phychology</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world</title>
    <url>/2022/01/01/hello/</url>
    <content><![CDATA[<h1 id="静态网页博客搭建"><a href="#静态网页博客搭建" class="headerlink" title="静态网页博客搭建"></a>静态网页博客搭建</h1><ul>
<li>wordpress + 云主机</li>
<li>jekyll&#x2F;hexo + git代码托管</li>
</ul>
<span id="more"></span>

<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="next-主题配置"><a href="#next-主题配置" class="headerlink" title="next 主题配置"></a>next 主题配置</h3><p>NEXT这款主题源码都直接托管在 GitHub 上，可以直接搜索，下载地址：<a href="https://github.com/theme-next/hexo-theme-next.git%E3%80%82">https://github.com/theme-next/hexo-theme-next.git。</a></p>
<p>下载源码之后，直接解压到博客的themes的目录下，比如我的主题目录就是<code>D:\hexo\themes\next</code></p>
<p>配置文件的分类<br>hexo 搭建的博客有两个yml配置文件，一个称之为站点配置文件，是根目录下的_config.yml，另一个是主题配置文件，是主题目录下的_config.yml文件。</p>
<h4 id="基本信息配置，根目录下的-config-yml"><a href="#基本信息配置，根目录下的-config-yml" class="headerlink" title="基本信息配置，根目录下的_config.yml"></a>基本信息配置，根目录下的_config.yml</h4><p>基本信息包括：博客标题、作者、描述、语言等等。这些基本信息的配置都在站点配置文件中。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description: 描述</span><br><span class="line">author: 作者</span><br><span class="line">language: 语言（简体中文是zh-Hans）</span><br><span class="line">timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写）</span><br></pre></td></tr></table></figure>
<h4 id="修改主题next目录下的-config-yml"><a href="#修改主题next目录下的-config-yml" class="headerlink" title="修改主题next目录下的 _config.yml"></a>修改主题next目录下的 _config.yml</h4><p>hexo 博客的主题很多，想要切换也是很简单，直接在站点配置文件中设置即可，如下：</p>
<p>Next 主题样式设置<br>Next 主题提供了 4 种风格供我们选择，分别为Muse、Mist、Pisces、Gemini。</p>
<p>以上 4 种风格大同小异，作者博客的风格是Gemini，大家可以根据自己的喜好任意切换，在主题配置文件中找到Scheme Settings，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置自己喜欢的风格</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<h4 id="添加文章搜索功能"><a href="#添加文章搜索功能" class="headerlink" title="添加文章搜索功能"></a>添加文章搜索功能</h4><p>Next 主题添加搜索的功能很简单，首先安装搜索插件：</p>
<p><code>npm install hexo-generator-searchdb --save</code></p>
<p>插件安装完成之后在站点配置文件中找到 local_search,修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local Search</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<h4 id="设置首页不显示全文"><a href="#设置首页不显示全文" class="headerlink" title="设置首页不显示全文"></a>设置首页不显示全文</h4><ol>
<li>文章截断<br>在需要截断的地方加入：</li>
</ol>
<!--more-->
<p>首页就会显示这条以上的所有内容，隐藏接下来的所有内容。<br>2. 写摘要<br>在文章的front-matter中添加description，其中description中的内容就会被显示在首页上，其余一律不显示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 让首页显示部分内容</span><br><span class="line">date: 2020-10-13 15:34:10</span><br><span class="line">description: 这是显示在首页的概述，正文内容均会被隐藏。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h4 id="去掉文章目录标题的自动编号"><a href="#去掉文章目录标题的自动编号" class="headerlink" title="去掉文章目录标题的自动编号"></a>去掉文章目录标题的自动编号</h4><p>我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？</p>
<p>在主题配置文件中找到toc属性，将其中的number属性设置成false，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line">  number: false</span><br><span class="line">  wrap: false</span><br></pre></td></tr></table></figure>

<h2 id="部署到-github-io"><a href="#部署到-github-io" class="headerlink" title="部署到 github.io"></a>部署到 github.io</h2><p>需要先安装插件 <code>npm install --save hexo-deployer-git</code></p>
<ol>
<li>新建 xxx.github.io 公开仓库，xxx 为当前用户名，仓库参数默认。</li>
<li>修改_config.yml 文件最后的deployment 项<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/linkua/linkua.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></li>
<li>执行 hexo deploy</li>
</ol>
<h2 id="编写-md"><a href="#编写-md" class="headerlink" title="编写 md"></a>编写 md</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hello world</span><br><span class="line">date: 2020-01-01 00:00:01 </span><br><span class="line">categories: hexo</span><br><span class="line">tags: md</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="categories-和-tags-的区别"><a href="#categories-和-tags-的区别" class="headerlink" title="categories 和 tags 的区别"></a>categories 和 tags 的区别</h3><p>“categories”（分类）和”tags”（标签）在内容管理系统中用于对文章或内容进行分类和标记，但它们在功能和用途上有一些区别：</p>
<p>分类（Categories）：<br>分类通常用于对文章或内容进行更广泛的主题性分类。它们代表了文章所属的主要类别或主题。例如，一个博客可能有 “科技”、” 健康”、” 旅行” 等分类。<br>一篇文章通常只能属于一个分类，它代表了文章的主要内容或主题。<br>标签（Tags）：<br>标签则是用于对文章或内容进行更具体的描述性标记。标签通常用于描述文章的关键词、主题或内容特点，使读者能够更容易地找到相关内容。例如，对于一篇关于健康的文章，可能会有 “健康”、” 饮食”、” 运动” 等标签。<br>一篇文章可以有多个标签，这样可以更细致地描述文章的内容特点。<br>因此，分类更多地用于对文章进行宏观的整体分类，而标签则更适合用于对文章进行细致的描述和关联。</p>
<p>比如一个食谱网址。</p>
<p>食谱的分类（Categories）是早餐、午餐、晚餐、开胃菜、汤、沙拉、配菜和甜点。所有的食谱都可以划归为其中的一种。</p>
<p>此外，用户可能还希望根据一些特点来寻找食谱，比如原味、番茄味、三鲜味、麻辣味等。这些使用标签（Tags）表示。</p>
<h3 id="注意代码块"><a href="#注意代码块" class="headerlink" title="注意代码块"></a>注意代码块</h3><p>代码块由“&#96;&#96;&#96;+回车”抱起来，不然hexo会乱码</p>
<h3 id="修改文章底部标签的-的样式"><a href="#修改文章底部标签的-的样式" class="headerlink" title="修改文章底部标签的#的样式"></a>修改文章底部标签的#的样式</h3><p>默认的文章标签的样式是带有#这个符号的，比如#Spring Boot，但是可以将#修改成标签的icon，效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Use icon instead of the symbol # to indicate the tag at the bottom of the post</span><br><span class="line">tag_icon: true</span><br></pre></td></tr></table></figure>
































]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo next</tag>
      </tags>
  </entry>
  <entry>
    <title>freertos</title>
    <url>/2024/01/02/freeRTOS/</url>
    <content><![CDATA[<h2 id="MISRA"><a href="#MISRA" class="headerlink" title="MISRA"></a>MISRA</h2><p>MISRA C是由汽车产业软件可靠性协会（MISRA）提出的C语言开发标准。其目的是在增进嵌入式系统的安全性及可移植性。针对C++语言也有对应的标准MISRA C++。</p>
<p>MISRA C一开始主要是针对汽车产业，不过其他产业也逐渐开始使用MISRA C：包括航天、电信、国防、医疗设备、铁路等领域中都已有厂商使用MISRA C。</p>
<p>MISRA C的第一版《Guidelines for the use of the C language in vehicle based software》是在1998年发行，一般称为MISRA-C:1998.。MISRA-C:1998有127项规则，规则从1号编号到127号，其中有93项是必需要求，其余的34项是推荐使用的规则。</p>
<p>在2004年时发行了第二版的MISRA C的第一版《Guidelines for the use of the C language in critical systems》（或称作MISRA-C:2004），其中有许多重要建议事项的变更，其规则也重新编号。MISRA-C:2004有141项规则，其中121项是必需要求，其余的20项是推荐使用的规则。规则分为21类，从“开发环境”到“运行期错误”。</p>
<p>2012年发布第三版，为当前最新有效的C语言规范版本，称为MISRAC:2012。 </p>
<p>Misra C不能100%保证程序不出问题，但是能尽可能的预防，总结一下，基本上使用Misra C具有以下五个维度的优势：</p>
<p>提升可靠性 提升可读性 提升可移植性 提升可维护性 提升安全性</p>
<span id="more"></span>

<h2 id="数据类型和编码风格指南"><a href="#数据类型和编码风格指南" class="headerlink" title="数据类型和编码风格指南"></a>数据类型和编码风格指南</h2><p>数据类型<br>FreeRTOS 的每个端口都有一个唯一的 portmacro.h 头文件，其中包含（除其他外）两种端口特定数据类型的定义：TickType_t 和 BaseType_t。这些数据类型在表 2 中进行了描述。<br>变量<br>TickType_t 是用于保存滴答计数值和指定时间的数据类型。<br>TickType_t 可以是无符号 16 位类型，也可以是无符号 32 位类型，具体取决于 FreeRTOSConfig.h 中 configUSE_16_BIT_TICKS 的设置。<br>BaseType_t 这始终被定义为架构中最有效的数据类型。通常，这是 32 位架构上的 32 位类型，16 位架构上的 16 位类型，以及 8 位架构上的 8 位类型。<br>BaseType_t 通常用于只能采用非常有限范围的值的返回类型，以及用于 pdTRUE&#x2F;pdFALSE 类型的布尔值。<br>一些编译器使所有不合格的 char 变量无符号，而另一些编译器使它们有符号。出于这个原因，FreeRTOS 源代码明确地用 ‘signed’ 或 ‘unsigned’ 来限定 char 的每次使用，<br>除非 char 用于保存 ASCII 字符，或者指向 char 的指针用于指向字符串。<br>从不使用普通的 int 类型。</p>
<p>变量名<br>变量以它们的类型为前缀：’c’ 表示 char，’s’ 表示 int16_t（短），’l’ int32_t（长），’x’ 表示 BaseType_t 和任何其他非标准类型（结构、任务句柄、队列把手等）。</p>
<p>如果一个变量是无符号的，它也以’u’为前缀。如果一个变量是一个指针，它也以’p’为前缀。例如，uint8_t 类型的变量将以“uc”为前缀，而指向 char 的指针类型的变量将以“pc”为前缀。</p>
<p>函数名称</p>
<p>函数以它们返回的类型和定义它们的文件作为前缀。例如：</p>
<p>v Task PrioritySet() 返回一个void并在task .c 中定义。</p>
<p>x Queue Receive() 返回一个BaseType_t类型的变量，并在queue .c 中定义。</p>
<p>pv Timer GetTimerID ( ) 返回指向 void 的指针，并在timers .c 中定义。</p>
<p>文件范围（私有）函数以“prv”为前缀。</p>
<p>格式化</p>
<p>一个制表符始终设置为等于四个空格。</p>
<p>宏名称</p>
<p>大多数宏都是大写的，并以小写字母为前缀，指示宏的定义位置。表 3 提供了前缀列表。<br>端口（例如，portMAX_DELAY）        portmacro.h<br>任务（例如，taskENTER_CRITICAL()） task.h<br>配置（例如，configUSE_PREEMPTION） FreeRTOSConfig.h</p>
<p>pdFALSE   0<br>pdPASS    1</p>
<h2 id="创建-FreeRTOS项目"><a href="#创建-FreeRTOS项目" class="headerlink" title="创建 FreeRTOS项目"></a>创建 FreeRTOS项目</h2><p>File                        Location</p>
<p>tasks.c                     FreeRTOS&#x2F;Source</p>
<p>queue.c                     FreeRTOS&#x2F;Source</p>
<p>list.c                      FreeRTOS&#x2F;Source</p>
<p>timers.c                    FreeRTOS&#x2F;Source</p>
<p>event_groups.c              FreeRTOS&#x2F;Source</p>
<p>All C and assembler files   FreeRTOS&#x2F;Source&#x2F;portable&#x2F;[compiler]&#x2F;[architecture]</p>
<p>heap_n.c                    FreeRTOS&#x2F;Source&#x2F;portable&#x2F;MemMang，其中 n 为 1、2、3、4 或 5。此文件从 FreeRTOS V9.0.0 变为可选文件。</p>
<p>使用早于 V9.0.0 的 FreeRTOS 版本的项目必须构建 heap_n.c 文件之一。从 FreeRTOS V9.0.0 开始，只有在 FreeRTOSConfig.h 中的 configSUPPORT_DYNAMIC_ALLOCATION 设置为 1 或 configSUPPORT_DYNAMIC_ALLOCATION 未定义时，才需要 heap_n.c 文件。有关详细信息，请参阅第 2 章，堆内存管理。</p>
<p>以下步骤基于常见的 Bluepill STM32F103C8T6, 也适用于其它 libopencm3 支持的MCU型号</p>
<h3 id="方案一-只复制需要的文件-Keil-or-others"><a href="#方案一-只复制需要的文件-Keil-or-others" class="headerlink" title="方案一: 只复制需要的文件 Keil or others"></a>方案一: 只复制需要的文件 Keil or others</h3><p>在 PlatformIO 中, Board 选择 Bluepill F103C8, Framework 选择 libopencm3, 创建项目<br>在项目的lib下新建目录 FreeRTOS<br>解压缩最新的 FreeRTOS<br>复制 FreeRTOS&#x2F;Source&#x2F; 目录下, 除 portable 目录以外其它全部文件和目录, 至 lib&#x2F;FreeRTOS 下<br>复制 FreeRTOS&#x2F;Source&#x2F;portable&#x2F;GCC&#x2F;ARM_CM3 目录下所有文件(port.c, portmacro.h), 至 lib&#x2F;FreeRTOS 下<br>复制 FreeRTOS&#x2F;Source&#x2F;portable&#x2F;Common 目录下所有文件(mpu_wrappers.c), 至 lib&#x2F;FreeRTOS 下<br>复制 FreeRTOS&#x2F;Source&#x2F;portable&#x2F;MemMang 目录下 heap_4.c, 至 lib&#x2F;FreeRTOS 下<br>复制 FreeRTOSConfig.h, 至 lib&#x2F;FreeRTOS&#x2F;include 下<br>编写 src&#x2F;main.c</p>
<h3 id="方案二-完整的FreeRTOS-使用library-json-PlatformIO-libopencm3-FreeRTOS"><a href="#方案二-完整的FreeRTOS-使用library-json-PlatformIO-libopencm3-FreeRTOS" class="headerlink" title="方案二: 完整的FreeRTOS, 使用library.json  PlatformIO: libopencm3 + FreeRTOS"></a>方案二: 完整的FreeRTOS, 使用library.json  PlatformIO: libopencm3 + FreeRTOS</h3><p>在 PlatformIO 中, Board 选择 Bluepill F103C8, Framework 选择 libopencm3, 创建项目<br>在项目的lib下新建目录 FreeRTOS<br>解压缩最新的 FreeRTOS<br>复制 FreeRTOS&#x2F;Source&#x2F; 目录下所有文件至 lib&#x2F;FreeRTOS 下<br>复制 FreeRTOSConfig.h, 至 lib&#x2F;FreeRTOS 下<br>lib&#x2F;FreeRTOS 下添加 library.json<br>编写 src&#x2F;main.c<br>library.json 内容如下, 只包含需要的 c 文件, 用 flags 包含额外的include路径, issue #4148</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;FreeRTOS&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;10.4.6&quot;,</span><br><span class="line">    &quot;build&quot;: &#123;</span><br><span class="line">        &quot;flags&quot;: [</span><br><span class="line">            &quot;-Iportable/GCC/ARM_CM3&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;srcFilter&quot;: [</span><br><span class="line">            &quot;+&lt;*.c&gt;&quot;,</span><br><span class="line">            &quot;+&lt;portable/GCC/ARM_CM3/port.c&gt;&quot;,</span><br><span class="line">            &quot;+&lt;portable/MemMang/heap_4.c&gt;&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">如果是多核MCU, 需要再包含 mpu_wrappers.c, 对于 F103C8 就不需要了</span><br><span class="line"></span><br><span class="line">&quot;+&lt;portable/Common/mpu_wrappers.c&gt;&quot;,</span><br></pre></td></tr></table></figure>

<h3 id="FreeRTOSConfig-h-函数名适配"><a href="#FreeRTOSConfig-h-函数名适配" class="headerlink" title="FreeRTOSConfig.h 函数名适配"></a>FreeRTOSConfig.h 函数名适配</h3><p>在 libopencm3&#x2F;lib&#x2F;cm3&#x2F;vector.c 中, 定义了 .sv_call,.pend_sv and .systick 的处理函数,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Those are defined only on CM3 or CM4 */</span><br><span class="line">#if defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__)</span><br><span class="line">	.memory_manage_fault = mem_manage_handler,</span><br><span class="line">	.bus_fault = bus_fault_handler,</span><br><span class="line">	.usage_fault = usage_fault_handler,</span><br><span class="line">	.debug_monitor = debug_monitor_handler,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	.sv_call = sv_call_handler,</span><br><span class="line">	.pend_sv = pend_sv_handler,</span><br><span class="line">	.systick = sys_tick_handler,</span><br><span class="line">	.irq = &#123;</span><br><span class="line">		IRQ_HANDLERS</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些函数名与 FreeRTOS 中的函数名不一致, 需要将其关联. 使用宏替换的方式比使用函数转发方式效率更高, 所以在 FreeRTOSConfig.h 中需要增加如下定义, 否则 FreeRTOS 不能正常工作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * In libopencm3/lib/cm3/vector.c, these 3 handlers(right side) are for .sv_call,.pend_sv and .systick</span><br><span class="line"> * These macro will rename the methods in port.c to make it work, more efficient than wrapped by method</span><br><span class="line">*/</span><br><span class="line">#define vPortSVCHandler sv_call_handler</span><br><span class="line">#define xPortPendSVHandler pend_sv_handler</span><br><span class="line">#define xPortSysTickHandler sys_tick_handler</span><br></pre></td></tr></table></figure>

<h2 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h2><h3 id="heap-1-c"><a href="#heap-1-c" class="headerlink" title="heap_1.c"></a>heap_1.c</h3><p>实现了一个非常基本的 pvPortMalloc() 版本，并没有实现 vPortFree()。从不删除任务或其他内核对象的应用程序有可能使用 heap_1<br>一些原本禁止使用动态内存分配的商业关键和安全关键系统也有可能使用 heap_1。由于与非确定性、内存碎片和分配失败相关的不确定性，关键系统通常会禁止动态内存分配——但 Heap_1 始终是确定性的，并且不能对内存进行碎片化。</p>
<h3 id="heap-2-c"><a href="#heap-2-c" class="headerlink" title="heap_2.c"></a>heap_2.c</h3><p>Heap_2 保留在 FreeRTOS 发行版中以实现向后兼容性，但不建议将其用于新设计。考虑使用 heap_4 而不是 heap_2，因为 heap_4 提供了增强的功能。<br>Heap_2.c 还通过细分由 configTOTAL_HEAP_SIZE 标注的数组来工作。它使用最合适的算法来分配内存，并且与 heap_1 不同，它确实允许释放内存。同样，数组是静态声明的，因此即使在分配数组中的任何内存之前，应用程序也会消耗大量 RAM。<br>最佳拟合算法确保 pvPortMalloc() 使用大小最接近请求的字节数的空闲内存块。<br>Heap_2 适用于重复创建和删除任务的应用程序，前提是分配给创建的任务的堆栈大小不变。</p>
<h3 id="heap-3-c"><a href="#heap-3-c" class="headerlink" title="heap_3.c"></a>heap_3.c</h3><p>Heap_3.c 使用标准库 malloc() 和 free() 函数，因此堆的大小由链接器配置定义，configTOTAL_HEAP_SIZE 设置没有影响。<br>Heap_3 通过暂时挂起 FreeRTOS 调度程序使 malloc() 和 free() 线程安全。线程安全和调度程序暂停都是第 7 章资源管理中介绍的主题。</p>
<h3 id="heap-4-c"><a href="#heap-4-c" class="headerlink" title="heap_4.c"></a>heap_4.c</h3><p>与 heap_1 和 heap_2 一样，heap_4 通过将数组细分为更小的块来工作。和以前一样，数组是静态声明的，并由 configTOTAL_HEAP_SIZE 确定尺寸，因此即使在实际从数组中分配任何内存之前，应用程序也会消耗大量 RAM。<br>Heap_4 使用首次拟合算法来分配内存。与 heap_2 不同，heap_4 将相邻的空闲内存块组合（合并）成一个更大的块，从而最大限度地降低内存碎片的风险。<br>Heap_4 不是确定性的，但比 malloc() 和 free() 的大多数标准库实现要快。</p>
<h3 id="heap-5-c"><a href="#heap-5-c" class="headerlink" title="heap_5.c"></a>heap_5.c</h3><p>heap_5 用于分配和释放内存的算法与 heap_4 使用的算法相同。与 heap_4 不同，heap_5 不限于从单个静态声明的数组分配内存；heap_5 可以从多个独立的内存空间分配内存。<br>Heap_5 是当运行 FreeRTOS 的系统提供的 RAM 没有在系统的内存映射中显示为单个连续（没有空间）块时很有用。<br>heap_5 是唯一提供的内存分配方案，必须在调用 pvPortMalloc() 之前显式初始化。Heap_5 使用 vPortDefineHeapRegions() API 函数进行初始化。使用 heap_5 时，<br>必须先调用 vPortDefineHeapRegions()，然后才能创建任何内核对象（任务、队列、信号量等）。<br>vPortDefineHeapRegions() 用于指定每个单独的内存区域的起始地址和大小，这些区域共同构成 heap_5 使用的总内存。</p>
<h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><p>任务被实现为 C 函数。它们唯一的特别之处是它们的原型，它必须返回 void 并采用 void 指针参数。<br>void ATaskFunction( void *pvParameters );<br>每个任务本身就是一个小程序。它有一个入口点，通常会在无限循环中永远运行，并且不会退出。</p>
<p>一个应用程序可以包含许多任务。如果运行应用程序的处理器包含一个内核，那么在任何给定时间只能执行一个任务。这意味着任务可以以两种状态之一存在，运行和未运行。</p>
<h3 id="xTaskCreate-任务创建API函数"><a href="#xTaskCreate-任务创建API函数" class="headerlink" title="xTaskCreate() 任务创建API函数"></a>xTaskCreate() 任务创建API函数</h3><p>FreeRTOS V9.0.0 还包括 xTaskCreateStatic() 函数，该函数在编译时分配静态创建任务所需的内存：任务是使用 FreeRTOS xTaskCreate() API 函数创建的。<br>BaseType_t xTaskCreate(TaskFunction_t pvTaskCode,const char * const pcName, uint16_t usStackDepth, void *pvParameters, UBaseType_t uxPriority,TaskHandle_t *pxCreatedTask );</p>
<p>pvTaskCode 参数只是一个指向实现任务的函数的指针（实际上，只是函数的名称）。<br>pcName 任务的描述性名称。FreeRTOS 不以任何方式使用它。它纯粹是作为调试帮助而包含在内的。通过人类可读的名称识别任务比尝试通过句柄识别任务要简单得多。<br>usStackDepth 每个任务都有自己独特的堆栈，在创建任务时由内核分配给该任务。<br>usStackDepth 值告诉内核使堆栈有多大。该值指定堆栈可以容纳的字数，而不是字节数。例如，如果堆栈是 32 位宽，并且 usStackDepth 作为 100 传入，那么将分配 400 字节的堆栈空间（100 * 4 字节）。堆栈深度乘以堆栈宽度不得超过可包含在 uint16_t 类型变量中的最大值<br>pvParameters 任务函数接受指向 void ( void* ) 的指针类型参数。分配给 pvParameters 的值是传递给任务的值。<br>uxPriority 定义任务执行的优先级。优先级可以从最低优先级 0 分配到最高优先级 (configMAX_PRIORITIES – 1)。configMAX_PRIORITIES 是一个用户定义的常量，<br>pxCreatedTask 可用于传递正在创建的任务的句柄。然后，此句柄可用于引用 API 调用中的任务，例如更改任务优先级或删除任务。<br>如果您的应用程序没有使用任务句柄，则可以将 pxCreatedTask 设置为 NULL。</p>
<p>返回值</p>
<p>有两种可能的返回值：<br>pdPASS 这表明任务已成功创建。<br>pdFAIL 这表明该任务尚未创建，因为 FreeRTOS 没有足够的堆内存来分配足够的 RAM 来保存任务数据结构和堆栈。</p>
<h3 id="在-main-中创建多个任务实例"><a href="#在-main-中创建多个任务实例" class="headerlink" title="在 main() 中创建多个任务实例"></a>在 main() 中创建多个任务实例</h3><p>&#x2F;* 启动调度程序，以便任务开始执行。*&#x2F; vTaskStartScheduler();<br>在启动调度程序之前从 main() 中创建了两个任务。也可以从另一个任务中创建一个任务。</p>
<h3 id="在任务中创建新任务实例"><a href="#在任务中创建新任务实例" class="headerlink" title="在任务中创建新任务实例"></a>在任务中创建新任务实例</h3><p>&#x2F;* 如果此任务代码正在执行，那么调度程序必须已经启动。在进入无限循环之前创建另一个任务。*&#x2F;</p>
<h3 id="同一任务实现创建多个任务实例"><a href="#同一任务实现创建多个任务实例" class="headerlink" title="同一任务实现创建多个任务实例"></a>同一任务实现创建多个任务实例</h3><p>即使现在只有一个任务实现（vTaskFunction），也可以创建多个已定义任务的实例。每个创建的实例都将在 FreeRTOS 调度程序的控制下独立执行<br>利用pvParameters 任务参数实现相同任务程序调用，但不同功能和运行结果。</p>
<h2 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h2><p>xTaskCreate() API 函数的 uxPriority 参数为正在创建的任务分配初始优先级。在调度程序启动后，可以使用 vTaskPrioritySet() API 函数更改优先级。<br>可用优先级的最大数量由 FreeRTOSConfig.h 中应用程序定义的 configMAX_PRIORITIES 编译时配置常量设置。低数值优先级值表示低优先级任务，优先级 0 是可能的最低优先级。<br>因此，可用优先级的范围是 0 到 (configMAX_PRIORITIES – 1)。任意数量的任务可以共享相同的优先级——确保最大的设计灵活性。</p>
<p>FreeRTOS 调度程序可以使用两种方法之一来决定哪个任务将处于运行状态。configMAX_PRIORITIES 可以设置的最大值取决于使用的方法：</p>
<h3 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h3><p>通用方法在 C 中实现，可用于所有 FreeRTOS 架构端口。<br>如果在 FreeRTOSConfig.h 中将 configUSE_PORT_OPTIMISED_TASK_SELECTION 设置为 0，或者如果 configUSE_PORT_OPTIMISED_TASK_SELECTION 未定义，<br>或者如果通用方法是为正在使用的 FreeRTOS 端口提供的唯一方法，则将使用通用方法。</p>
<h3 id="架构优化方法"><a href="#架构优化方法" class="headerlink" title="架构优化方法"></a>架构优化方法</h3><p>架构优化的方法使用少量的汇编代码，并且比泛型方法更快。configMAX_PRIORITIES 设置不影响最坏情况的执行时间。<br>并非所有 FreeRTOS 端口都提供架构优化的方法。</p>
<p>FreeRTOS 调度程序将始终确保能够运行的最高优先级任务是选择进入运行状态的任务。在多个相同优先级的任务能够运行的情况下，调度程序将依次将每个任务转换为运行状态和退出运行状态。</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>实际运行的任务（使用处理时间）处于运行状态。在单核处理器上，在任何给定时间只能有一个任务处于运行状态。<br>实际未运行但既不处于 Blocked 状态也不处于 Suspended 状态的任务处于 Ready 状态。处于Ready 状态的任务可供调度程序选择作为进入Running 状态的任务。调度器会一直选择优先级最高的Ready状态任务进入Running状态。<br>任务可以在 Blocked 状态下等待事件，并在事件发生时自动移回 Ready 状态。时间事件发生在特定时间，例如，当块时间到期时，通常用于实现周期性或超时行为。当任务或中断服务例程使用任务通知、队列、事件组或多种类型的信号量之一发送信息时，会发生同步事件。它们通常用于表示异步活动，例如数据到达外围设备。</p>
<h3 id="配置调度算法"><a href="#配置调度算法" class="headerlink" title="配置调度算法"></a>配置调度算法</h3><p>调度算法是决定哪个就绪状态任务转换到运行状态的软件例程。<br>到目前为止，所有示例都使用了相同的调度算法，但可以使用 configUSE_PREEMPTION 和 configUSE_TIME_SLICING 配置常量更改该算法。这两个常量都在 FreeRTOSConfig.h 中定义。</p>
<p>第三个配置常量 configUSE_TICKLESS_IDLE 也会影响调度算法，因为它的使用会导致滴答中断在很长一段时间内完全关闭。configUSE_TICKLESS_IDLE 是一个高级选项，专门用于必须最小化功耗的应用程序。<br>configUSE_TICKLESS_IDLE 在第 10 章，低功耗支持中进行了描述。本节提供的描述假定 configUSE_TICKLESS_IDLE 设置为 0，如果未定义常量，这是默认设置</p>
<p>在所有可能的配置中，FreeRTOS 调度程序将确保选择共享优先级的任务依次进入运行状态。这种“轮流”政策通常被称为<br>作为“循环调度”。Round Robin调度算法不保证同等优先级的任务之间平均共享时间，只有同等优先级的Ready状态的任务会依次进入Running状态。</p>
<h4 id="带时间片的优先级抢先"><a href="#带时间片的优先级抢先" class="headerlink" title="带时间片的优先级抢先"></a>带时间片的优先级抢先</h4><p>configUSE_PREEMPTION      1<br>configUSE_TIME_SLICING    1<br>如果优先级高于运行状态任务的任务进入就绪状态，抢占式调度算法将立即“抢占”运行状态任务。被抢占意味着非自愿地（没有显式让步或阻塞）移出运行状态并进入就绪状态，以允许不同的任务进入运行状态<br>时间片用于在同等优先级的任务之间共享处理时间，即使这些任务没有明确地让出或进入阻塞状态。</p>
<p>如果存在与运行任务具有相同优先级的其他就绪状态任务，则描述为使用“时间片”的调度算法将在每个时间片结束时选择一个新任务进入运行状态。一次<br>slice 等于两个 RTOS 滴答中断之间的时间。</p>
<p>不使用时间片时的任务上下文切换比使用时间片时少。因此，关闭时间片可以减少调度程序的处理开销。但是，关闭时间片也可能导致同等优先级的任务接收的处理时间量大不相同，图29 展示了这种情况。因此，在没有时间片的情况下运行调度程序被认为是一种高级技术，仅应由以下人员使用有经验的用户。<br>configUSE_PREEMPTION      1<br>configUSE_TIME_SLICING    0</p>
<h4 id="合作调度"><a href="#合作调度" class="headerlink" title="合作调度"></a>合作调度</h4><p>configUSE_PREEMPTION      0<br>configUSE_TIME_SLICING    0&#x2F;1	</p>
<p>使用协同调度器时，只有在运行状态任务进入阻塞状态，或者运行状态任务通过调用taskYIELD()显式让步（手动请求重新调度）时才会发生上下文切换。任务永远不会被抢占，因此不能使用时间切片。</p>
<h3 id="时间片调度"><a href="#时间片调度" class="headerlink" title="时间片调度"></a>时间片调度</h3><p>调度算法，描述了一个称为“时间切片”的可选功能。到目前为止的示例中使用了时间片，并且是在它们产生的输出中观察到的行为。在示例中，两个任务都以相同的优先级创建，并且两个任务始终能够运行。<br>因此，每个任务执行一个“时间片”，在时间片开始时进入运行状态，在时间片结束时退出运行状态。<br>为了能够选择下一个要运行的任务，调度程序本身必须在每个时间片1结束时执行。为此目的使用称为“滴答中断”的周期性中断。时间片的长度由滴答中断频率有效设置，该频率由 FreeRTOSConfig.h 中应用程序定义的 configTICK_RATE_HZ 编译时间配置常量配置。<br>例如，如果 configTICK_RATE_HZ 设置为 100 (Hz)，则时间片将为 10 毫秒。两次滴答中断之间的时间称为“滴答周期”。一个时间片等于一个滴答周期。<br>“滴答计数”值是自调度程序启动以来发生的滴答中断的总数，假设滴答计数没有溢出。用户应用程序在指定延迟周期时不必考虑溢出，因为时间一致性由 FreeRTOS 内部管理。</p>
<p>需要注意的是，时间片的结束并不是调度器可以选择新任务运行的唯一地方；正如本书将展示的那样，调度程序还将在当前执行的任务进入阻塞状态后或当中断将更高优先级的任务移至就绪状态时立即选择一个新任务来运行。</p>
<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>调度程序将始终确保能够运行的最高优先级任务是选择进入运行状态的任务<br>调度程序将始终选择能够运行的最高优先级任务。任务 2 的优先级高于任务 1，并且始终能够运行；因此，任务 2 是唯一进入运行状态的任务。由于任务 1 永远不会进入运行状态，它永远不会打印出它的字符串。任务 1 被称为任务 2 的处理时间“饥饿”。</p>
<p>为了使任务有用，必须将它们重写为事件驱动。事件驱动的任务只有在触发它的事件发生后才能执行工作（处理），并且在该事件发生之前无法进入运行状态。</p>
<h4 id="封锁状态"><a href="#封锁状态" class="headerlink" title="封锁状态"></a>封锁状态</h4><p>正在等待事件的任务被称为处于“阻塞”状态，这是“未运行”状态的子状态。<br>任务可以进入 Blocked 状态以等待两种不同类型的事件：<br>时间（时间相关）事件——事件要么是延迟期到期，要么是达到的绝对时间。例如，一个任务可能会进入 Blocked 状态以等待 10 毫秒通过。<br>同步事件——事件源自另一个任务或中断。例如，任务可能进入阻塞状态以等待数据到达队列。同步事件涵盖了广泛的事件类型。<br>FreeRTOS 队列、二进制信号量、计数信号量、互斥体、递归互斥体、事件组和直接到任务通知都可用于创建同步事件<br>一个任务有可能阻塞一个有超时的同步事件，有效地同时阻塞这两种类型的事件。例如，一个任务可以选择等待一个<br>数据到达队列的最大时间为 10 毫秒。如果任一数据在 10 毫秒内到达，或 10 毫秒过去但没有数据到达，任务将离开阻塞状态。</p>
<h4 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h4><p>“暂停”也是未运行的子状态。处于 Suspended 状态的任务对调度程序不可用。进入挂起状态的唯一方法是调用 vTaskSuspend() API 函数，唯一的出路是调用 vTaskResume() 或 xTaskResumeFromISR() API 函数。大多数应用程序不使用挂起状态。</p>
<h4 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h4><p>处于 Not Running 状态但未被 Blocked 或 Suspended 的任务称为处于 Ready 状态。它们能够运行，因此“准备好”运行，但当前不处于运行状态。</p>
<h4 id="vTaskDelay"><a href="#vTaskDelay" class="headerlink" title="vTaskDelay()"></a>vTaskDelay()</h4><p>vTaskDelay() 将调用任务置于 Blocked 状态以进行固定数量的滴答中断。该任务在处于阻塞状态时不使用任何处理时间，因此该任务仅在实际有工作要做时才使用处理时间。<br>宏 pdMS_TO_TICKS() 可用于将以毫秒为单位的时间转换为以滴答为单位的时间。例如，调用 vTaskDelay(pdMS_TO_TICKS(100)) 将导致调用任务</p>
<p>保持阻塞状态 100 毫秒。</p>
<p>大多数时候没有应用程序任务可以运行（没有应用程序任务处于就绪状态），因此没有应用程序任务可以选择进入运行状态。在这种情况下，空闲任务将运行。分配给空闲的处理时间量是系统中空闲处理能力的量度。使用 RTOS 可以显着增加备用处理能力，只需让应用程序完全由事件驱动即可。</p>
<h4 id="vTaskDelayUntil"><a href="#vTaskDelayUntil" class="headerlink" title="vTaskDelayUntil( )"></a>vTaskDelayUntil( )</h4><p>使用 vTaskDelay() 并不能保证它们运行的​​频率是固定的，因为任务离开阻塞状态的时间与它们调用 vTaskDelay() 的时间有关。将任务转换为使用 vTaskDelayUntil() 而不是 vTaskDelay() 可以解决这个潜在问题。</p>
<p>void vTaskDelayUntil(TickType_t * pxPreviousWakeTime, TickType_t xTimeIncrement);</p>
<p>xLastWakeTime &#x3D; xTaskGetTickCount();<br>&#x2F;* xLastWakeTime 变量需要使用当前滴答计数进行初始化。请注意，这是唯一一次显式写入变量。在此之后 xLastWakeTime 在 vTaskDelayUntil() 中自动更新。*&#x2F;<br>for(;;)<br>{<br>&#x2F;* 这个任务应该每 250 毫秒准确地执行一次。根据 vTaskDelay() 函数，时间以滴答为单位测量，pdMS_TO_TICKS() 宏用于将毫秒转换为滴答。</p>
<p>xLastWakeTime 在 vTaskDelayUntil() 中自动更新，因此任务不会显式更新。*&#x2F;</p>
<p>vTaskDelayUntil(&amp;xLastWakeTime, pdMS_TO_TICKS(250));<br>}</p>
<h3 id="空闲任务和空闲任务挂钩"><a href="#空闲任务和空闲任务挂钩" class="headerlink" title="空闲任务和空闲任务挂钩"></a>空闲任务和空闲任务挂钩</h3><p>必须始终至少有一项任务可以进入运行状态1。为了确保这种情况，调度程序会在调用 vTaskStartScheduler() 时自动创建一个空闲任务。空闲任务只不过是在一个循环中，所以，就像最初的第一个示例中的任务一样，它总是能够运行。</p>
<p>空闲任务具有尽可能低的优先级（优先级为零），以确保它永远不会阻止更高优先级的应用程序任务进入运行状态。</p>
<p>可以通过使用空闲钩子（或空闲回调）函数将特定于应用程序的功能直接添加到空闲任务中，该函数在空闲任务循环的每次迭代中由空闲任务自动调用一次。<br>空闲任务挂钩的常见用途包括：</p>
<p>执行低优先级、后台或连续处理功能。<br>衡量备用处理能力的数量。（只有在所有更高优先级的应用程序任务都没有工作要执行时，空闲任务才会运行；因此，测量分配给空闲任务的处理时间量可以清楚地表明有多少处理时间是空闲的。）<br>将处理器置于低功耗模式，在无需执行应用程序处理时提供一种简单且自动的节能方法（尽管使用此方法可实现的节能低于使用刻度线可实现的节能）少空闲模式在第 10 章，低功耗支持中描述）。</p>
<p>空闲任务挂钩函数绝不能尝试阻塞或挂起。<br>&#x2F;* 声明一个将由钩子函数递增的变量。*&#x2F; volatile uint32_t ulIdleCycleCount &#x3D; 0UL;</p>
<p>&#x2F;* 空闲钩子函数必须调用 vApplicationIdleHook()，不带参数，并返回 void。*&#x2F;<br>void vApplicationIdleHook（void）<br>{<br>&#x2F;* 这个钩子函数只增加一个计数器。*&#x2F; ulIdleCycleCount++;<br>}<br>configUSE_IDLE_HOOK 必须在 FreeRTOSConfig.h 中设置为 1 才能调用空闲挂钩函数</p>
<h3 id="更改任务"><a href="#更改任务" class="headerlink" title="更改任务"></a>更改任务</h3><p>vTaskPrioritySet() API 函数可用于在调度程序启动后更改任何任务的优先级。请注意，仅当 FreeRTOSConfig.h 中的 INCLUDE_vTaskPrioritySet 设置为 1 时，vTaskPrioritySet() API 函数才可用。<br>任务可以通过传递 NULL 代替有效的任务句柄来更改自己的优先级。</p>
<p>uxTaskPriorityGet() API 函数可用于查询任务的优先级。请注意，仅当 FreeRTOSConfig.h 中的 INCLUDE_uxTaskPriorityGet 设置为 1 时，uxTaskPriorityGet() API 函数才可用。<br>任务可以通过传递 NULL 代替有效的任务句柄来查询自己的优先级。</p>
<p>任务可以使用 vTaskDelete() API 函数通过传递 NULL 来删除自身或任何其他任务。请注意，vTaskDelete() API 函数仅在 FreeRTOSConfig.h 中的 INCLUDE_vTaskDelete 设置为 1 时可用。<br>已删除的任务不再存在，无法再次进入运行状态。</p>
<p>空闲任务负责释放分配给已被删除的任务的内存。因此，使用 vTaskDelete() API 函数的应用程序不要完全饿死所有处理时间的空闲任务，这一点很重要。</p>
<p>任务 1 运行并创建任务 2。任务 2 立即开始运行，因为它具有更高的优先级</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>“队列”提供任务到任务、任务到中断和中断到任务的通信机制。<br>FreeRTOS 通过复制方法使用队列。复制排队意味着发送到队列的数据被逐字节复制到队列中。<br>复制队列不会阻止队列也被用于引用队列。例如，当排队数据的大小使得将数据复制到队列中变得不切实际时，可以将指向数据的指针复制到队列中。</p>
<p>队列本身就是对象，任何知道它们存在的任务或 ISR 都可以访问这些对象。任意数量的任务可以写入同一个队列，任意数量的任务可以从同一个队列中读取。</p>
<h3 id="阻塞队列读取-写入"><a href="#阻塞队列读取-写入" class="headerlink" title="阻塞队列读取&#x2F;写入"></a>阻塞队列读取&#x2F;写入</h3><p>当任务尝试从队列中读取时，它可以选择指定一个“阻塞”时间。如果队列已经为空，这是任务将保持在阻塞状态以等待队列中可用数据的时间。处于阻塞状态的任务正在等待队列中的数据可用，当另一个任务或中断将数据放入队列时，它会自动移动到就绪状态。如果指定的阻塞时间在数据可用之前到期，任务也将自动从阻塞状态移动到就绪状态。<br>队列可以有多个读取器，因此单个队列可能会阻止多个任务在其上等待数据。在这种情况下，当数据可用时，只有一个任务会被解除阻塞。未阻塞的任务将始终是等待数据的最高优先级任务。如果阻塞的任务具有相同的优先级，则等待数据时间最长的任务将被解除阻塞。</p>
<p>就像从队列中读取一样，任务在写入队列时可以选择指定阻塞时间。在这种情况下，阻塞时间是任务应该保持在阻塞状态以等待队列上可用空间的最长时间，如果队列已经满的话。<br>队列可以有多个写入者，因此一个完整的队列可能会阻止多个任务在其上等待完成发送操作。在这种情况下，当队列上的空间可用时，只有一个任务会被解除阻塞。未阻塞的任务将始终是等待空间的最高优先级任务。如果阻塞的任务具有相同的优先级，则等待空间时间最长的任务将被解除阻塞。</p>
<h3 id="使用队列"><a href="#使用队列" class="headerlink" title="使用队列"></a>使用队列</h3><p>xQueueCreate() API函数 QueueHandle_t xQueueCreate(UBaseType_t uxQueueLength, UBaseType_t uxItemSize);<br>队列必须先显式创建，然后才能使用。<br>队列由句柄引用，句柄是 QueueHandle_t 类型的变量。xQueueCreate() API 函数创建一个队列并返回一个引用它创建的队列的 QueueHandle_t。</p>
<p>FreeRTOS V9.0.0 还包括 xQueueCreateStatic() 函数，该函数在编译时分配静态创建队列所需的内存：FreeRTOS 在创建队列时从 FreeRTOS 堆分配 RAM。RAM 用于保存队列数据结构和队列中包含的项目。如果没有足够的堆 RAM 可用于创建队列，xQueueCreate() 将返回 NULL。<br>uxQueueLength   正在创建的队列在任何时候可以容纳的最大项目数。<br>uxItemSize      可以存储在队列中的每个数据项的大小（以字节为单位）。<br>返回值          如果返回 NULL，则无法创建队列，因为 FreeRTOS 没有足够的堆内存来分配队列数据结构和存储区域。</p>
<p>创建队列后，可以使用 xQueueReset() API 函数将队列返回到其原始空状态。</p>
<p>第一个参数是数据发送到的队列。队列是在调度程序启动之前创建的，</p>
<h4 id="xQueueSend-API函数"><a href="#xQueueSend-API函数" class="headerlink" title="xQueueSend() API函数"></a>xQueueSend() API函数</h4><p>xQueueSendToBack() 和 xQueueSendToFront() API函数<br>xQueueSendToBack() 用于将数据发送到队列的后端（尾部），而 xQueueSendToFront() 用于将数据发送到队列的前端（头部）。<br>与 xQueueSendToBack() 等价并且完全相同</p>
<p>BaseType_t xQueueSendToBack(QueueHandle_t xQueue, const void * pvItemToQueue, TickType_t xTicksToWait );</p>
<p>xQueue        正在向其发送（写入）数据的队列句柄。队列句柄将从用于创建队列的 xQueueCreate() 调用中返回。<br>pvItemToQueue 指向要复制到队列中的数据的指针。队列可以容纳的每个项目的大小是在队列被设置时设置的创建，所以这么多字节将从 pvItemToQueue 复制到队列存储区。<br>xTicksToWait  如果队列已满，任务应保持在 Blocked 状态以等待队列上可用空间的最长时间。块时间以滴答周期指定，因此它所代表的绝对时间取决于滴答频率。宏 pdMS_TO_TICKS() 可用于将以毫秒为单位的时间转换为以滴答为单位的时间。<br>              将 xTicksToWait 设置为 portMAX_DELAY 将导致任务无限期等待（不会超时），前提是在 FreeRTOSConfig.h 中将 INCLUDE_vTaskSuspend 设置为 1。</p>
<p>返回值 有两种可能的返回值：<br>       仅当数据成功发送到队列时才会返回 pdPASS。<br>       如果指定了阻塞时间（xTicksToWait 不为零），那么调用任务可能被置于阻塞状态，等待队列中的空间可用，然后函数返回，但数据已成功写入在块时间到期之前排队。</p>
<pre><code>   如果由于队列已满而无法将数据写入队列，则将返回 errQUEUE_FULL。如果指定了阻塞时间（xTicksToWait 不为零），则调用任务将被置于阻塞状态以等待另一个任务或中断以在队列中腾出空间，但是指定的块时间在此之前到期。
</code></pre>
<p>注意：切勿从中断服务例程调用 xQueueSendToFront() 或 xQueueSendToBack()。应使用中断安全版本 xQueueSendToFrontFromISR() 和 xQueueSendToBackFromISR() 代替它们。</p>
<h4 id="xQueueReceive-API函数"><a href="#xQueueReceive-API函数" class="headerlink" title="xQueueReceive() API函数"></a>xQueueReceive() API函数</h4><p>xQueueReceive() 用于从队列中接收（读取）项目。收到的项目将从队列中删除。</p>
<p>注意：切勿从中断服务程序调用 xQueueReceive()。第 6 章描述了中断安全的 xQueueReceiveFromISR() API 函数。</p>
<p>BaseType_t    xQueueReceive(QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait );<br>xQueue        从中接收（读取）数据的队列句柄。队列句柄将从用于创建队列的 xQueueCreate() 调用中返回。<br>pvBuffer      指向将接收到的数据复制到其中的内存的指针。队列保存的每个数据项的大小是在创建队列时设置的。pvBuffer 指向的内存必须至少大到足以容纳那么多字节。<br>xTicksToWait  如果队列已经为空，任务应保持在 Blocked 状态以等待队列上可用的数据的最长时间。如果 xTicksToWait 为零，则如果队列已经为空，则 xQueueReceive() 将立即返回。<br>              块时间以滴答周期指定，因此它所代表的绝对时间取决于滴答频率。宏 pdMS_TO_TICKS() 可用于将以毫秒为单位的时间转换为以滴答为单位的时间。<br>              将 xTicksToWait 设置为 portMAX_DELAY 将导致任务等待 如果在 FreeRTOSConfig.h 中将 INCLUDE_vTaskSuspend 设置为 1，则无限期（无超时）。</p>
<p>返回值 有两种可能的返回值：<br>只有从队列中成功读取数据时，才会返回 pdPASS。<br>如果指定了阻塞时间（xTicksToWait 不为零），则调用任务可能被置于阻塞状态，以等待队列中的数据可用，但在阻塞时间之前已成功从队列中读取数据已到期。<br>如果由于队列已经为空而无法从队列中读取数据，则将返回 errQUEUE_EMPTY。<br>如果指定了阻塞时间（xTicksToWait 不为零），则调用任务将被置于阻塞状态以等待另一个任务或中断向队列发送数据，但阻塞时间在此之前已过期。</p>
<h3 id="uxQueueMessagesWaiting-API函数"><a href="#uxQueueMessagesWaiting-API函数" class="headerlink" title="uxQueueMessagesWaiting() API函数"></a>uxQueueMessagesWaiting() API函数</h3><p> 用于查询当前队列中的项目数。</p>
<p>UBaseType_t uxQueueMessagesWaiting(QueueHandle_t xQueue);</p>
<p>返回值 正在查询的队列当前持有的项目数。如果返回零，则队列为空。</p>
<p>接收任务具有最高优先级，因此队列永远不会包含超过一项。这是因为一旦数据被放入队列，接收任务就会抢占发送任务。<br>发送任务具有较高的优先级，因此队列通常会被填满。这是因为，一旦接收任务从队列中删除一个项目，它就会被其中一个发送任务抢占，然后立即重新填充队列。然后发送任务重新进入阻塞状态以等待队列中的空间再次可用。</p>
<h3 id="处理大型或可变大小的数据"><a href="#处理大型或可变大小的数据" class="headerlink" title="处理大型或可变大小的数据"></a>处理大型或可变大小的数据</h3><p>排队指针<br>如果存储在队列中的数据很大，那么最好使用队列来传递指向数据的指针，而不是逐字节地将数据本身复制到队列中和从队列中取出。传输指针在处理时间和创建队列所需的 RAM 量方面都更有效。<br>但是，在对指针进行排队时，必须格外小心以确保：</p>
<ol>
<li>所指向的 RAM 的所有者已明确定义。<br>通过指针在任务之间共享内存时，必须确保两个任务不会同时修改内存内容，或采取任何其他可能导致内存内容无效或不一致的操作。理想情况下，应该只允许发送任务访问内存，直到指向内存的指针被排队，并且在从队列中接收到指针之后，应该只允许接收任务访问内存。</li>
<li>指向的 RAM 仍然有效。<br>如果指向的内存是动态分配的，或者是从预先分配的缓冲区池中获得的，那么只有一个任务应该负责释放内存。在内存被释放后，任何任务都不应尝试访问内存。<br>永远不应使用指针来访问已在任务堆栈上分配的数据。堆栈帧更改后数据将无效</li>
</ol>
<p>两种强大的设计模式；将结构发送到队列，并将指针发送到队列。结合这些技术，任务可以使用单个队列从任何数据源接收任何数据类型。FreeRTOS+TCP TCP&#x2F;IP 堆栈的实现提供了如何实现这一点的实际示例。</p>
<h3 id="多个队列"><a href="#多个队列" class="headerlink" title="多个队列"></a>多个队列</h3><p>通常应用程序设计需要单个任务来接收不同大小的数据、不同含义的数据以及来自不同来源的数据。上一节演示了如何使用接收结构的单个队列以简洁有效的方式实现这一点。但是，有时应用程序的设计者会处理限制其设计选择的约束，<br>因此需要为某些数据源使用单独的队列。例如，集成到设计中的第三方代码可能假定存在专用队列。在这种情况下，可以使用“队列集”。<br>队列集允许任务从多个队列接收数据，而无需任务依次轮询每个队列以确定哪个队列（如果有）包含数据。<br>与使用接收结构的单个队列实现相同功能的设计相比，使用队列集从多个源接收数据的设计不太整洁，效率也较低。出于这个原因，建议仅在设计约束使其绝对必要时才使用队列集。</p>
<p>通过在 FreeRTOSConfig.h 中将 configUSE_QUEUE_SETS 编译时配置常量设置为 1 来启用队列集功能。</p>
<h4 id="xQueueCreateSet-API函数队列集必须在使用前显式创建。"><a href="#xQueueCreateSet-API函数队列集必须在使用前显式创建。" class="headerlink" title="xQueueCreateSet() API函数队列集必须在使用前显式创建。"></a>xQueueCreateSet() API函数队列集必须在使用前显式创建。</h4><p>队列集由句柄引用，句柄是 QueueSetHandle_t 类型的变量。xQueueCreateSet() API 函数创建一个队列集并返回一个引用它创建的队列集的 QueueSetHandle_t。</p>
<p>QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength );</p>
<p>uxEventQueueLength 当作为队列集合成员的队列接收数据时，接收队列的句柄将发送到队列集合。uxEventQueueLength 定义了正在创建的队列集在任何时候可以容纳的最大队列句柄数<br>信号量也可以添加到队列集中。作为另一个示例，如果队列集包含长度为 3 的队列和二进制信号量（长度为 1），则 uxEventQueueLength 必须设置为 4（三加一）。</p>
<p>返回值 如果返回 NULL，则无法创建队列集，因为 FreeRTOS 没有足够的堆内存来分配队列集数据结构和存储区域。<br>返回非 NULL 值表示已成功创建队列集。返回的值应存储为已创建队列集的句柄。</p>
<h4 id="xQueueAddToSet-API函数-将队列或信号量添加到队列集。"><a href="#xQueueAddToSet-API函数-将队列或信号量添加到队列集。" class="headerlink" title="xQueueAddToSet() API函数 将队列或信号量添加到队列集。"></a>xQueueAddToSet() API函数 将队列或信号量添加到队列集。</h4><p>BaseType_t xQueueAddToSet(QueueSetMemberHandle_t xQueueOrSemaphore,QueueSetHandle_t xQueueSet );</p>
<p>xQueueOrSemaphore 正在添加到队列集中的队列或信号量的句柄。 队列句柄和信号量句柄都可以转换为 QueueSetMemberHandle_t 类型。<br>xQueueSet         要添加队列或信号量的队列集的句柄。</p>
<p>返回值 有两种可能的返回值：<br>仅当队列或信号量成功添加到队列集中时，才会返回 pdPASS。<br>如果无法将队列或信号量添加到队列集中，将返回 pdFAIL。<br>队列和二进制信号量只有在它们为空时才能添加到集合中。计数信号量只能在计数为零时添加到集合中。队列和信号量一次只能是一组的成员。</p>
<h4 id="xQueueSelectFromSet-API函数"><a href="#xQueueSelectFromSet-API函数" class="headerlink" title="xQueueSelectFromSet() API函数"></a>xQueueSelectFromSet() API函数</h4><p>xQueueSelectFromSet() 从队列集中读取队列句柄。<br>当作为集合成员的队列或信号量接收数据时，接收队列或信号量的句柄被发送到队列集合，并在任务调用 xQueueSelectFromSet() 时返回。如果从对 xQueueSelectFromSet() 的调用中返回句柄，则该句柄引用的队列或信号量已知包含数据，调用任务必须直接从队列或信号量中读取。<br>注意：不要从作为集合成员的队列或信号量中读取数据，除非队列或信号量的句柄首先从对 xQueueSelectFromSet() 的调用中返回。每次调用 xQueueSelectFromSet() 返回队列句柄或信号量句柄时，仅从队列或信号量中读取一项。</p>
<p>QueueSetMemberHandle_t xQueueSelectFromSet(QueueSetHandle_t xQueueSet,const TickType_t xTicksToWait );<br>xQueueSet    正在接收（读取）队列句柄或信号量句柄的队列集的句柄。队列集句柄将从对用于创建队列集的 xQueueCreateSet() 的调用中返回。<br>xTicksToWait 如果集合中的所有队列和信号量都为空，则调用任务应保持在阻塞状态以等待从队列集中接收队列或信号量句柄的最长时间。<br>返回值       非 NULL 的返回值将是已知包含数据的队列或信号量的句柄。如果指定了阻塞时间（xTicksToWait 不为零），则调用任务可能被置于阻塞状态以等待数据从集合中的队列或信号量中可用，但已成功读取句柄在块时间到期之前设置的队列。<br>句柄作为 QueueSetMemberHandle_t 类型返回，该类型可以转换为 QueueHandle_t 类型或 SemaphoreHandle_t 类型。<br>如果返回值为 NULL，则无法从队列集中读取句柄。如果指定了阻塞时间（xTicksToWait 不为零），则调用任务将被置于阻塞状态以等待另一个任务或中断将数据发送到集合中的队列或信号量，但阻塞时间在此之前到期发生了。</p>
<h3 id="使用队列创建邮箱"><a href="#使用队列创建邮箱" class="headerlink" title="使用队列创建邮箱"></a>使用队列创建邮箱</h3><p>嵌入式社区内的术语没有达成共识，“邮箱”在不同的 RTOS 中意味着不同的东西。在本书中，术语邮箱用于指代长度为 1 的队列。队列可能因其在应用程序中的使用方式而被描述为邮箱，而不是因为它与队列在功能上有所不同：<br>队列用于将数据从一个任务发送到另一个任务，或从中断服务程序发送到任务。发送者将一个项目放入队列，接收者从队列中移除该项目。数据通过队列从发送方传递到接收方。</p>
<p>邮箱用于保存可由任何任务或任何中断服务程序读取的数据。数据不通过邮箱，而是保留在邮箱中，直到被覆盖。发件人覆盖邮箱中的值。接收者从邮箱中读取值，但不从邮箱中删除值。</p>
<p>&#x2F;* 邮箱是一个队列，所以它的句柄存储在一个 QueueHandle_t 类型的变量中。*&#x2F;<br>QueueHandle_t xMailbox；</p>
<p>&#x2F;* 创建将用作邮箱的队列。队列的长度为 1 以允许它与 xQueueOverwrite() API 函数一起使用，如下所述。*&#x2F;<br>xMailbox &#x3D; xQueueCreate(1, sizeof(Example_t));</p>
<h4 id="xQueueOverwrite-API函数"><a href="#xQueueOverwrite-API函数" class="headerlink" title="xQueueOverwrite() API函数"></a>xQueueOverwrite() API函数</h4><p>与 xQueueSendToBack() API 函数一样，xQueueOverwrite() API 函数将数据发送到队列。与 xQueueSendToBack() 不同，如果队列已满，则 xQueueOverwrite() 将覆盖已在队列中的数据。<br>xQueueOverwrite() 只能用于长度为 1 的队列。如果队列已满，该限制避免了函数的实现需要任意决定要覆盖队列中的哪个项目。<br>注意：切勿从中断服务程序调用 xQueueOverwrite()。应使用中断安全版本 xQueueOverwriteFromISR() 代替它。</p>
<p>BaseType_t xQueueOverwrite(QueueHandle_t xQueue, const void * pvItemToQueue);<br>xQueue        正在向其发送（写入）数据的队列句柄。队列句柄将从用于创建队列的 xQueueCreate() 调用中返回。<br>pvItemToQueue 指向要复制到队列中的数据的指针。 队列可以容纳的每个项目的大小是在创建队列时设置的，因此会从 pvItemToQueue 将这么多字节复制到队列存储区中。</p>
<p>返回值        即使队列已满，xQueueOverwrite() 也会写入队列，因此 pdPASS 是唯一可能的返回值。</p>
<h4 id="xQueuePeek-API函数"><a href="#xQueuePeek-API函数" class="headerlink" title="xQueuePeek() API函数"></a>xQueuePeek() API函数</h4><p>xQueuePeek() 用于从队列中接收（读取）项目，而不会从队列中删除该项目。xQueuePeek() 从队列头部接收数据，不修改队列中存储的数据，也不修改队列中数据的存储顺序。<br>注意：切勿从中断服务程序调用 xQueuePeek()。应使用中断安全版本 xQueuePeekFromISR() 代替它。</p>
<p>使用无限阻塞时间，因此无需检查从 xQueuePeek() 返回的值，因为 xQueuePeek() 仅在数据可用时才会返回。*&#x2F; xQueuePeek(xMailbox, pxData, portMAX_DELAY);</p>
<h3 id="软件定时器管理"><a href="#软件定时器管理" class="headerlink" title="软件定时器管理"></a>软件定时器管理</h3><p>软件定时器用于在未来的设定时间安排功能的执行，或以固定的频率定期执行。软件定时器执行的函数称为软件定时器的回调函数。‌<br>软件定时器由 FreeRTOS 内核实现并受其控制。它们不需要硬件支持，并且与硬件定时器或硬件计数器无关。</p>
<p>软件定时器功能是可选的。要包括软件定时器功能：<br>构建 FreeRTOS 源文件 FreeRTOS&#x2F;Source&#x2F;timers.c 作为项目的一部分.<br>在 FreeRTOSConfig.h 中将 configUSE_TIMERS 设置为 1。</p>
<p>RTOS 守护进程（定时器服务）任务<br>所有软件定时器回调函数都在同一个 RTOS 守护进程（或“定时器服务”）任务1的上下文中执行.<br>守护程序任务是在调度程序启动时自动创建的标准 FreeRTOS 任务。它的优先级和堆栈大小分别由 configTIMER_TASK_PRIORITY 和 configTIMER_TASK_STACK_DEPTH 编译时配置常量设置。这两个常量都在 FreeRTOSConfig.h 中定义。<br>软件定时器回调函数不得调用会导致调用任务进入阻塞状态的 FreeRTOS API 函数，否则会导致守护任务进入阻塞状态。</p>
<p>软件计时器 API 函数将命令从调用任务发送到称为“计时器命令队列”的队列上的守护程序任务。如图41 所示。命令示例包括“启动计时器”、“停止计时器”和“重置计时器”。<br>定时器命令队列是一个标准的 FreeRTOS 队列，它在调度程序启动时自动创建。定时器命令队列的长度由 FreeRTOSConfig.h 中的 configTIMER_QUEUE_LENGTH 编译时间配置常量设置。</p>
<p>该任务曾经被称为“定时器服务任务”，因为它最初只用于执行软件定时器回调函数。现在，同样的任务也用于其他目的，因此它以更通用的名称“RTOS 守护程序任务”而闻名。</p>
<p>守护进程任务调度<br>守护程序任务与任何其他 FreeRTOS 任务一样安排；当它是能够运行的最高优先级任务时，它只会处理命令或执行计时器回调函数。</p>
<ol>
<li>调用 xTimerStart() 的任务优先级为高于守护任务的优先级<br>如果命令被发送到定时器命令队列，守护任务将离开阻塞状态，在这种情况下它将处理命令，或者如果软件定时器到期，在这种情况下它将执行软件定时器的回调函数。<br>正在启动的软件计时器将到期的时间是从“启动计时器”命令发送到计时器命令队列的时间计算的-它不是从守护程序任务收到“启动计时器”的时间计算的来自定时器命令队列的命令。</li>
</ol>
<p>2.调用 xTimerStart() 的任务的优先级为低于守护任务的优先级<br>xTimerStart() 向定时器命令队列发送命令，导致守护任务离开阻塞状态。daemon任务的优先级高于Task 1的优先级，所以调度器选择daemon任务作为进入Running状态的任务。</p>
<h4 id="创建和启动软件计时器"><a href="#创建和启动软件计时器" class="headerlink" title="创建和启动软件计时器"></a>创建和启动软件计时器</h4><p>软件计时器必须在使用之前显式创建。<br>软件定时器由 TimerHandle_t 类型的变量引用。xTimerCreate() 用于创建软件定时器并返回 TimerHandle_t 以引用它创建的软件定时器。软件计时器在休眠状态下创建。<br>pvTimerID 每个软件定时器都有一个 ID 值。ID 是一个空指针，应用程序编写者可以将其用于任何目的。当多个软件定时器使用相同的回调函数时，ID 特别有用，因为它可用于提供定时器特定的存储。本章中的示例演示了计时器 ID 的使用。<br>pvTimerID 为正在创建的任务的 ID 设置初始值</p>
<p>xTimerStart() 用于启动处于休眠状态的软件定时器，或复位（重新启动）处于运行状态的软件定时器。xTimerStop() 用于停止处于运行状态的软件定时器。停止软件定时器与将定时器转换为休眠状态相同。<br>BaseType_t    xTimerStart(TimerHandle_t xTimer, TickType_t xTicksToWait);<br>xTicksToWait  如果在调度程序启动之前调用 xTimerStart()，则忽略 xTicksToWait 的值，xTimerStart() 的行为就像xTicksToWait 已设置为零。</p>
<p>每个软件定时器都有一个 ID，它是一个标签值，应用程序编写者可以将其用于任何目的。ID 存储在 void 指针 (void *) 中，因此可以直接存储整数值，指向任何其他对象，或用作函数指针。<br>创建软件定时器时，会为 ID 分配一个初始值，之后可以使用 vTimerSetTimerID() API 函数更新 ID，并使用 pvTimerGetTimerID() API 函数进行查询。<br>与其他软件定时器 API 函数不同，vTimerSetTimerID() 和 pvTimerGetTimerID() 直接访问软件定时器——它们不向定时器命令队列发送命令。</p>
<h4 id="软件定时器回调函数"><a href="#软件定时器回调函数" class="headerlink" title="软件定时器回调函数"></a>软件定时器回调函数</h4><p>软件定时器回调函数作为 C 函数实现。它们的唯一特别之处是它们的原型，它必须返回 void，并将软件计时器的句柄作为其唯一参数。回调函数原型如清单 72 所示。<br>v同一个回调函数可以分配给多个软件定时器。完成后，回调函数参数用于确定哪个软件计时器到期。</p>
<p>void ATimerCallback(TimerHandle_t xTimer);<br>软件定时器回调函数从头到尾执行，并以正常方式退出。它们应该保持简短，并且不得进入 Blocked 状态。</p>
<p>注意：正如将要看到的，软件定时器回调函数在 FreeRTOS 调度程序启动时自动创建的任务的上下文中执行。<br>因此，软件定时器回调函数绝对不能调用 FreeRTOS API 函数，这将导致调用任务进入阻塞状态。</p>
<p>正如将要看到的，软件定时器回调函数在 FreeRTOS 调度程序启动时自动创建的任务的上下文中执行。因此，软件定时器回调函数绝对不能调用 FreeRTOS API 函数，这将导致调用任务进入阻塞状态。<br>可以调用xQueueReceive()等函数，但前提是函数的xTicksToWait参数（指定函数的阻塞时间）设置为0。不可以调用vTaskDelay()等函数，调用vTaskDelay()将始终将调用任务置于阻塞状态。</p>
<p>软件定时器<br>软件定时器的“周期”是软件定时器启动和软件定时器回调函数执行之间的时间。<br>一次性和自动重新加载计时器<br>一次性计时器<br>一旦启动，一次性计时器将只执行一次其回调函数。一次性计时器可以手动重新启动，但不会自行重新启动。<br>自动重新加载计时器<br>一旦启动，自动重载计时器将在每次到期时重新启动，从而定期执行其回调函数。</p>
<h4 id="更改定时器"><a href="#更改定时器" class="headerlink" title="更改定时器"></a>更改定时器</h4><p>使用 xTimerChangePeriod() 函数更改软件定时器的周期。<br>如果 xTimerChangePeriod() 用于更改已经运行的计时器的周期，则计时器将使用新的周期值重新计算其到期时间。重新计算的到期时间与调用 xTimerChangePeriod() 的时间有关，与最初启动计时器的时间无关。<br>切勿从中断服务程序调用 xTimerChangePeriod()。应使用中断安全版本 xTimerChangePeriodFromISR() 代替它。</p>
<p>复位软件定时器意味着重新启动定时器；计时器的到期时间被重新计算为相对于计时器重置的时间，而不是计时器最初启动的时间。<br>使用 xTimerReset() API 函数重置计时器。xTimerReset() 也可用于启动处于休眠状态的计时器。<br>注意：切勿从中断服务程序调用 xTimerReset()。应使用中断安全版本 xTimerResetFromISR() 代替它。</p>
<h3 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h3><p>嵌入式实时系统必须采取行动来响应源自环境的事件。例如，到达以太网外围设备的数据包（事件）可能需要传递到 TCP&#x2F;IP 堆栈进行处理（操作）。重要的系统必须为来自多个源的事件提供服务，所有这些都将具有不同的处理开销和响应时间要求。在每种情况下，都必须对最佳事件处理实施策略做出判断：<br>应该如何检测事件？通常使用中断，但也可以轮询输入。<br>使用中断时，中断服务程序（ISR）内部应该执行多少处理，外部执行多少？通常希望使每个 ISR 尽可能短。<br>事件如何传达给主（非 ISR）代码，以及如何构建此代码以最好地适应潜在异步事件的处理？<br>FreeRTOS 不会对应用程序设计者强加任何特定的事件处理策略，但确实提供了允许以简单且可维护的方式实现所选策略的功能。</p>
<p>虽然是用软件编写的，但中断服务程序是一种硬件功能，因为硬件控制着哪个中断服务程序将运行以及何时运行。任务只有在没有 ISR 运行时才会运行，因此最低优先级的中断会中断最高优先级的任务，任务无法抢占 ISR。<br>注意：切勿从 ISR 调用名称中没有“FromISR”的 FreeRTOS API 函数。</p>
<p>通常认为最好的做法是使 ISR 尽可能短。原因包括：<br>即使任务被分配了非常高的优先级，它们也只会在硬件没有处理中断的情况下运行,中断所需的任何其他处理通常可以在任务中执行，从而允许中断服务程序尽可能快地退出。这称为“延迟中断处理”，因为中断所需的处理从 ISR“延迟”到任务。</p>
<p>如果中断处理对时间要求特别严格，则可以设置延迟处理任务的优先级，以确保该任务始终抢占系统中的其他任务。然后可以实现 ISR 以包括对 portYIELD_FROM_ISR() 的调用，确保 ISR 直接返回到中断处理被推迟到的任务。这具有确保整个事件处理在时间上连续（无中断）执行的效果，就像它已经在 ISR 本身内实现一样。</p>
<h4 id="二进制信号量用于将中断处理“推迟”到任务"><a href="#二进制信号量用于将中断处理“推迟”到任务" class="headerlink" title="二进制信号量用于将中断处理“推迟”到任务"></a>二进制信号量用于将中断处理“推迟”到任务</h4><p>BaseType_t xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore, BaseType_t *pxHigherPriorityTaskWoken );<br>pxHigherPriorityTaskWoken  单个信号量可能会阻止一个或多个任务在其上等待信号量可用。调用 xSemaphoreGiveFromISR() 可以使信号量可用，从而导致等待信号量的任务离开阻塞状态。如果调用 xSemaphoreGiveFromISR() 导致任务离开阻塞状态，并且未阻塞任务的优先级高于当前正在执行的任务（被中断的任务），则在内部，xSemaphoreGiveFromISR() 会将 *pxHigherPriorityTaskWoken 设置为 pdTRUE。<br>如果 xSemaphoreGiveFromISR() 将此值设置为 pdTRUE，则通常应在退出中断之前执行上下文切换。这将确保中断直接返回到最高优先级的就绪状态任务.</p>
<p>如果 portYIELD_FROM_ISR() xHigherPriorityTaskWoken 参数为 pdFALSE（零），则不请求上下文切换，并且宏不起作用。如果 portYIELD_FROM_ISR() xHigherPriorityTaskWoken 参数不是 pdFALSE，则请求上下文切换，并且处于运行状态的任务可能会更改。</p>
<p>static uint32_t ulExampleInterruptHandler( void )<br>{<br>    BaseType_t xHigherPriorityTaskWoken;</p>
<pre><code>xHigherPriorityTaskWoken = pdFALSE;

xSemaphoreGiveFromISR( xBinarySemaphore, &amp;xHigherPriorityTaskWoken );

portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
</code></pre>
<p>}</p>
<p>仅当中断以相对较低的频率发生时，示例中使用的任务结构才足够。<br>实际应用中，中断是由硬件产生的，并且发生在不可预知的时间。因此，为了尽量减少错过中断的机会，延迟中断处理任务的结构必须使其能够处理在每次调用 xSemaphoreTake().</p>
<h4 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h4><p>正如二进制信号量可以被认为是长度为 1 的队列一样，计数信号量也可以被认为是长度大于 1 的队列。任务对存储在队列中的数据不感兴趣——只对队列中的项目数感兴趣。configUSE_COUNTING_SEMAPHORES 必须在 FreeRTOSConfig.h 中设置为 1，以便计数信号量可用。<br>每次“给定”计数信号量时，都会使用其队列中的另一个空间。队列中的项目数是信号量的“计数”值。<br>计数信号量通常用于两件事：<br>1计数事件<br>在这种情况下，事件处理程序将在每次事件发生时“给予”一个信号量——导致信号量的计数值在每次“给予”时递增。每次处理事件时，任务都会“获取”一个信号量——导致信号量的计数值在每次“获取”时递减。计数值是已发生的事件数与已处理的事件数之差。</p>
<p>2资源管理<br>在这种情况下，计数值表示可用资源的数量。为了获得对资源的控制，任务必须首先获得一个信号量——递减信号量的计数值。当计数值达到零时，没有空闲资源。当任务完成资源后，它会“返回”信号量——增加信号量的计数值。</p>
<p>所有各种类型的 FreeRTOS 信号量的句柄都存储在 SemaphoreHandle_t 类型的变量中。<br>在可以使用信号量之前，必须先创建它。要创建计数信号量，请使用 xSemaphoreCreateCounting() API 函数。</p>
<p>SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount );</p>
<p>static uint32_t ulExampleInterruptHandler( void )<br>{<br>    BaseType_t xHigherPriorityTaskWoken;<br>    xHigherPriorityTaskWoken &#x3D; pdFALSE;<br>    xSemaphoreGiveFromISR( xCountingSemaphore, &amp;xHigherPriorityTaskWoken );<br>    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );<br>}</p>
<h4 id="将工作推迟到-RTOS-守护程序任务"><a href="#将工作推迟到-RTOS-守护程序任务" class="headerlink" title="将工作推迟到 RTOS 守护程序任务"></a>将工作推迟到 RTOS 守护程序任务</h4><p>到目前为止所介绍的延迟中断处理示例要求应用程序编写者为每个使用延迟处理技术的中断创建一个任务。也可以使用 xTimerPendFunctionCallFromISR() 1 API 函数将中断处理推迟到 RTOS 守护程序任务——无需为每个中断创建单独的任务。将中断处理延迟到守护程序任务称为“集中延迟中断处理”。<br>守护程序任务的优先级由 FreeRTOSConfig.h 中的 configTIMER_TASK_PRIORITY 编译时间配置常量设置。</p>
<p>不同的中断具有不同的时序约束，因此在同一应用程序中使用两种延迟中断处理的方法很常见。</p>
<p>BaseType_t xTimerPendFunctionCallFromISR(PendedFunction_t xFunctionToPend, void *pvParameter1，uint32_t ulParameter2，BaseType_t *pxHigherPriorityTaskWoken );</p>
<p>void vPendableFunction( void *pvParameter1, uint32_t ulParameter2 );</p>
<p>xFunctionToPend 指向将在守护程序任务中执行的函数的指针（实际上，只是函数名）。<br>pvParameter1 将作为函数的 pvParameter1 参数传递给守护程序任务执行的函数的值。该参数具有 void * 类型以允许它用于传递任何数据类型。例如，整数类型可以直接转换为 void <em>，或者 void * 可用于指向结构<br>ulParameter2 将作为函数的 ulParameter2 参数传递给守护程序任务执行的函数的值。<br>pxHigherPriorityTaskWoken xTimerPendFunctionCallFromISR() 写入定时器命令队列。如果 RTOS 守护任务处于阻塞状态以等待定时器命令队列上的数据可用，那么写入定时器命令队列将导致守护任务离开阻塞状态。<br>如果守护程序任务的优先级高于当前执行任务（被中断的任务）的优先级，则在内部，xTimerPendFunctionCallFromISR() 将设置</em>pxHigherPriorityTaskWoken 为 pdTRUE。<br>如果 xTimerPendFunctionCallFromISR() 将此值设置为 pdTRUE，则必须在中断退出之前执行上下文切换。这将确保中断直接返回到守护任务，因为守护任务将是最高优先级的就绪状态任务。</p>
<p>&#x2F;* 产生软件中断的任务的优先级低于守护任务的优先级。守护程序任务的优先级由 FreeRTOSConfig.h 中的 configTIMER_TASK_PRIORITY 编译时间配置常量设置。*&#x2F;<br>const UBaseType_t ulPeriodicTaskPriority &#x3D; configTIMER_TASK_PRIORITY - 1;</p>
<h4 id="在中断服务例程-使用队列"><a href="#在中断服务例程-使用队列" class="headerlink" title="在中断服务例程 使用队列"></a>在中断服务例程 使用队列</h4><p>二进制和计数信号量用于传达事件。队列用于传递事件和传输数据。</p>
<p>BaseType_t xQueueSendToFrontFromISR( QueueHandle_t xQueue, void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken);</p>
<p>队列提供了一种将数据从中断传递到任务的简单方便的方法，但如果数据到达的频率很高，则使用队列效率不高。<br>适用于生产代码的更有效的技术包括：<br>使用直接内存访问 (DMA) 硬件来接收和缓冲字符。这种方法实际上没有软件开销。然后可以使用直接到任务通知1来解除阻塞仅在检测到传输中断后才处理缓冲区的任务。<br>将每个接收到的字符复制到线程安全的 RAM 缓冲区中2。同样，直接到任务通知可用于在接收到完整消息或检测到传输中断后解除阻塞将处理缓冲区的任务。<br>直接在 ISR 中处理接收到的字符，然后使用队列将处理数据（而不是原始数据）的结果发送给任务。这在之前的图 34 中得到了证明。</p>
<p>xHigherPriorityTaskWoken 用作 portYIELD_FROM_ISR() 的参数。<br>如果发送到 xStringQueue 导致任务离开 Blocked 状态，并且如果离开 Blocked 状态的任务的优先级高于处于 Running 状态的任务的优先级，则 xHigherPriorityTaskWoken 将在 xQueueSendToBackFromISR() 中设置为 pdTRUE .</p>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><p>在多任务系统中，如果一个任务开始访问资源，但在退出运行状态之前未完成其访问，则可能会出错。如果任务使资源处于不一致状态，则任何其他任务或中断对同一资源的访问可能会导致数据损坏或其他类似问题。<br>考虑以下场景，其中两个任务尝试写入液晶显示器 (LCD)。访问外设，读取、修改、写入操作，对变量的非原子访问，函数重入</p>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>为确保始终保持数据一致性，对任务之间或任务与中断之间共享的资源的访问必须使用“互斥”技术进行管理。目标是确保一旦任务开始访问不可重入且非线程安全的共享资源，同一任务对资源具有独占访问权，直到资源返回到一致状态。</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>基本临界区是分别被宏 taskENTER_CRITICAL() 和 taskEXIT_CRITICAL() 调用包围的代码区域。临界区也称为临界区。</p>
<p>taskENTER_CRITICAL() 和 taskEXIT_CRITICAL() 不带任何参数，或返回值1 。清单 114演示了它们的使用。</p>
<p>&#x2F;* 确保对 PORTA 寄存器的访问不会因将其置于临界区而被中断。进入临界区。*&#x2F;<br>taskENTER_CRITICAL();</p>
<p>&#x2F;* 在调用 taskENTER_CRITICAL() 和调用 taskEXIT_CRITICAL() 之间不能切换到另一个任务。中断仍然可以在允许中断嵌套的 FreeRTOS 端口上执行，但仅限于逻辑优先级高于分配给 configMAX_SYSCALL_INTERRUPT_PRIORITY 常量的值的中断——并且不允许这些中断调用 FreeRTOS API 函数。*&#x2F;</p>
<p>&#x2F;* 对 PORTA 的访问已完成，因此可以安全地退出临界区。*&#x2F;<br>taskEXIT_CRITICAL();</p>
<p>以这种方式实现的关键部分是提供互斥的一种非常粗略的方法。它们的工作方式是完全禁用中断，或者禁用中断优先级（由 configMAX_SYSCALL_INTERRUPT_PRIORITY 设置），具体取决于所使用的 FreeRTOS 端口。抢先式上下文切换只能在中断中发生，因此，只要中断保持禁用状态，调用 taskENTER_CRITICAL() 的任务就可以保证保持在运行状态，直到退出临界区。<br>基本临界区必须保持非常短，否则它们会对中断响应时间产生不利影响。对 taskENTER_CRITICAL() 的每次调用都必须与对 taskEXIT_CRITICAL() 的调用紧密配对</p>
<p>基本临界区保护代码区域不被其他任务和中断访问。通过挂起调度程序实现的临界区仅保护代码区域不被其他任务访问，因为中断仍然启用。<br>临界区太长而无法通过简单地禁用中断来实现，相反，可以通过暂停调度程序来实现。但是，调度程序暂停时的中断活动会使恢复（或“取消暂停”）调度程序成为一个相对较长的操作，因此必须考虑在每种情况下使用哪种方法最好。<br>vTaskSuspendAll() API函数<br>调度程序通过调用 vTaskSuspendAll() 被挂起。暂停调度程序可防止发生上下文切换，但会启用中断。如果在调度程序挂起时中断请求上下文切换，则该请求将保持挂起，并且仅在调度程序恢复（未挂起）时执行。<br>调度程序挂起时不得调用 FreeRTOS API 函数。</p>
<h4 id="互斥体（和二进制信号量）"><a href="#互斥体（和二进制信号量）" class="headerlink" title="互斥体（和二进制信号量）"></a>互斥体（和二进制信号量）</h4><p>Mutex 是一种特殊类型的二进制信号量，用于控制对两个或多个任务之间共享的资源的访问。MUTEX 一词源于“互斥”。configUSE_MUTEXES 必须在 FreeRTOSConfig.h 中设置为 1 才能使用互斥锁。</p>
<p>在互斥场景中使用互斥锁时，可以将互斥锁视为与共享资源相关联的令牌。对于合法访问资源的任务，它必须首先成功“获取”令牌（成为令牌持有者）。当令牌持有者用完资源后，它必须“归还”令牌。<br>只有当令牌被返回后，另一个任务才能成功获取令牌，然后安全地访问相同的共享资源。除非任务持有令牌，否则不允许任务访问共享资源。</p>
<p>尽管互斥锁和二进制信号量共享许多特性，必须始终返回用于互斥的信号量。用于同步的信号量通常被丢弃并且不返回。<br>互斥锁是一种信号量。所有各种类型的 FreeRTOS 信号量的句柄都存储在 SemaphoreHandle_t 类型的变量中。<br>在使用互斥体之前，必须先创建它。要创建互斥量类型的信号量，请使用 xSemaphoreCreateMutex() API 函数。</p>
<p>像往常一样， main() 只是创建互斥体，创建任务，然后启动调度程序.<br>&#x2F;* 在使用信号量之前，它必须被显式创建。在本例中，创建了一个互斥类型的信号量。*&#x2F;</p>
<p>xMutex &#x3D; xSemaphoreCreateMutex();</p>
<p>xSemaphoreTake(xMutex, portMAX_DELAY);<br>{<br>&#x2F;&#x2F;TODO<br>}<br>xSemaphoreGive(xMutex);</p>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><p>使用互斥体提供互斥的潜在缺陷之一。所描述的执行顺序显示了较高优先级的任务 2 必须等待较低优先级的任务 1 放弃对互斥体的控制。以这种方式被较低优先级任务延迟的较高优先级任务称为“优先级反转”。<br>如果中等优先级任务开始执行而高优先级任务正在等待信号量（结果将是高优先级任务等待低优先级任务），则这种不良行为将被进一步夸大，而低优先级任务甚至无法执行。</p>
<p>FreeRTOS 互斥体和二进制信号量非常相似——不同之处在于互斥体包含基本的“优先级继承”机制，而二进制信号量则没有。优先级继承是一种将优先级倒置的负面影响降至最低的方案。<br>优先级继承的工作原理是将互斥锁持有者的优先级临时提高到试图获得相同互斥锁的最高优先级任务的优先级。持有互斥锁的低优先级任务“继承”等待互斥锁的任务的优先级。</p>
<p>如前所述，优先级继承功能会影响使用互斥锁的任务的优先级。因此，不能在中断服务例程中使用互斥锁。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>“死锁”是使用互斥锁进行互斥的另一个潜在陷阱。死锁有时也以更具戏剧性的名称“致命拥抱”而闻名。</p>
<p>递归互斥体 （解决自身死锁）<br>任务也可能与自身发生死锁。如果一个任务尝试多次使用同一个互斥锁，而不首先返回互斥锁<br>虽然它已经持有递归互斥锁，但任务再次获取互斥锁。在实际应用程序中，这仅可能发生在此任务调用的子函数内部，因为没有实际理由故意多次使用同一个互斥锁。调用任务已经是互斥锁持有者，所以对 xSemaphoreTakeRecursive() 的第二次调用只是将递归调用计数增加到 2。</p>
<p>如果多个任务在紧密循环中使用互斥锁，并且使用互斥锁的任务具有相同的优先级，则必须注意确保任务接收大致相等的处理时间。</p>
<h4 id="守门人任务"><a href="#守门人任务" class="headerlink" title="守门人任务"></a>守门人任务</h4><p>守门任务提供了一种实现互斥的干净方法，没有优先级反转或死锁的风险。<br>守门人任务是对资源拥有唯一所有权的任务。只有守门任务被允许直接访问资源——任何其他需要访问资源的任务只能通过使用网守的服务间接访问。</p>
<p>守门人任务大部分时间都处于阻塞状态，等待消息到达队列。其他任务或中断可以通过队列发送消息到守门人任务。</p>
<h4 id="事件组"><a href="#事件组" class="headerlink" title="事件组"></a>事件组</h4><p>已经注意到实时嵌入式系统必须采取行动来响应事件。前几章描述了 FreeRTOS 允许将事件传递给任务的功能。此类功能的示例包括信号量和队列，它们都具有以下属性：<br>它们允许任务在 Blocked 状态下等待单个事件的发生。<br>它们在事件发生时解除对单个任务的阻塞——被解除阻塞的任务是等待事件的最高优先级任务。</p>
<p>事件组是 FreeRTOS 的另一个功能，它允许将事件传达给任务。与队列和信号量不同：<br>事件组允许任务在阻塞状态下等待多个事件之一的组合发生。<br>当事件发生时，事件组会解除阻塞等待同一事件或事件组合的所有任务。</p>
<p>事件组的这些独特属性使其可用于同步多个任务、将事件广播到多个任务、允许任务在阻塞状态等待一组事件中的任何一个发生，以及允许任务在完成多个操作的阻塞状态。<br>事件组还提供了减少应用程序使用的 RAM 的机会，因为通常可以用单个事件组替换许多二进制信号量。</p>
<p>事件组、事件标志和事件位</p>
<p>事件“标志”是一个布尔值（1 或 0），用于指示事件是否发生。事件“组”是一组事件标志。</p>
<p>一个事件标志只能为 1 或 0，允许将一个事件标志的状态存储在一个位中，并将一个事件组中所有事件标志的状态存储在一个变量中；事件组中每个事件标志的状态由 EventBits_t 类型变量中的单个位表示。因此，事件标志也称为事件“位”。如果 EventBits_t 变量中的某个位设置为 1，则该位表示的事件已经发生。如果 EventBits_t 变量中的某个位设置为 0，则该位表示的事件尚未发生。</p>
<p>有关 EventBits_t 数据类型<br>事件组中的事件位数取决于 FreeRTOSConfig.h 1中的 configUSE_16_BIT_TICKS 编译时间配置常量：<br>如果 configUSE_16_BIT_TICKS 为 1，则每个事件组包含 8 个可用事件位。<br>如果 configUSE_16_BIT_TICKS 为 0，则每个事件组包含 24 个可用事件位。<br>多任务<br>事件组本身就是对象，任何知道它们存在的任务或 ISR 都可以访问这些对象。任意数量的任务可以设置同一事件组中的位，任意数量的任务可以从同一事件组中读取位。</p>
<h4 id="xEventGroupCreate-API函数"><a href="#xEventGroupCreate-API函数" class="headerlink" title="xEventGroupCreate() API函数"></a>xEventGroupCreate() API函数</h4><p>使用 EventGroupHandle_t 类型的变量引用事件组。xEventGroupCreate() API 函数用于创建事件组，并返回一个 EventGroupHandle_t 以引用它创建的事件组。<br>返回非 NULL 值表示事件组已成功创建。返回值应存储为句柄到创建的事件组。</p>
<h4 id="xEventGroupSetBits"><a href="#xEventGroupSetBits" class="headerlink" title="xEventGroupSetBits()"></a>xEventGroupSetBits()</h4><p>xEventGroupSetBits() API 函数设置事件组中的一个或多个位，通常用于通知任务已发生由正在设置的一个或多个位表示的事件。</p>
<p>xEventGroupSetBits() API 函数设置事件组中的一个或多个位，通常用于通知任务已发生由正在设置的一个或多个位表示的事件。<br>注意：切勿从中断服务例程中调用 xEventGroupSetBits()。应使用中断安全版本 xEventGroupSetBitsFromISR() 代替它。</p>
<p>给予信号量是一种确定性操作，因为事先知道给予信号量最多可以导致一个任务离开阻塞状态。当在事件组中设置位时，事先不知道有多少任务将离开阻塞状态，因此在事件组中设置位不是确定性操作。<br>FreeRTOS 设计和实施标准不允许在中断服务例程内或在禁用中断时执行非确定性操作。因此，xEventGroupSetBitsFromISR() 不会直接在中断服务例程中设置事件位，而是将操作推迟到 RTOS 守护程序任务。</p>
<p>BaseType_t xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken );</p>
<p>xEventGroup 正在设置位的事件组的句柄。事件组句柄将从对用于创建事件组的 xEventGroupCreate() 的调用中返回。<br>uxBitsToSet 一个位掩码，指定要在事件组中设置为 1 的事件位或事件位。事件组的值通过将事件组的现有值与 uxBitsToSet 中传递的值进行按位或运算来更新。<br>            例如，将 uxBitsToSet 设置为 0x05（二进制 0101）将导致事件组中的事件位 3 和事件位 0 被设置（如果尚未设置），同时保留所有事件组中的其他事件位不变。<br>pxHigherPriorityTaskWoken  xEventGroupSetBitsFromISR() 不会直接在中断服务例程中设置事件位，而是通过在定时器命令队列上发送命令将操作推迟到 RTOS 守护程序任务。<br>如果守护任务处于阻塞状态以等待定时器命令队列上的数据可用，那么写入定时器命令队列将导致守护任务离开阻塞状态。如果守护任务的优先级高于当前执行任务（被中断的任务）的优先级，那么在内部，<br>xEventGroupSetBitsFromISR() 将设置  *pxHigherPriorityTaskWoken 为 pdTRUE。</p>
<p>如果 xEventGroupSetBitsFromISR() 将此值设置为 pdTRUE，则应在退出中断之前执行上下文切换。这将确保中断直接返回到守护任务，因为守护任务将是最高优先级的就绪状态任务。</p>
<h4 id="xEventGroupWaitBits-API函数"><a href="#xEventGroupWaitBits-API函数" class="headerlink" title="xEventGroupWaitBits() API函数"></a>xEventGroupWaitBits() API函数</h4><p>xEventGroupWaitBits() API 函数允许任务读取事件组的值，如果尚未设置事件位，则可选择在阻塞状态等待事件组中的一个或多个事件位被设置。<br>EventBits_t xEventGroupWaitBits( const EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait);</p>
<p>调度程序用来确定任务是否进入阻塞状态以及任务何时离开阻塞状态的条件称为“解除阻塞条件”。<br>解锁条件由 uxBitsToWaitFor 和 xWaitForAllBits 参数值的组合指定：<br>uxBitsToWaitFor 指定要测试事件组中的哪些事件位<br>xWaitForAllBits 指定是使用按位 OR 测试还是按位 AND 测试<br>如果在调用 xEventGroupWaitBits() 时满足解除阻塞条件，则任务不会进入阻塞状态。</p>
<p>调用任务使用 uxBitsToWaitFor 参数指定要测试的位，并且调用任务可能需要在满足其解除阻塞条件后将这些位清零。可以使用 xEventGroupClearBits() API 函数清除事件位，但在以下情况下，使用该函数手动清除事件位将导致应用程序代码出现竞争条件：<br>有多个任务使用同一个事件组。<br>由不同的任务或中断服务程序在事件组中设置位。<br>调用任务使用 uxBitsToWaitFor 参数指定要测试的位，并且调用任务可能需要在满足其解除阻塞条件后将这些位清零。可以使用 xEventGroupClearBits() API 函数清除事件位，但在以下情况下，使用该函数手动清除事件位将导致应用程序代码出现竞争条件：<br>有多个任务使用同一个事件组。<br>由不同的任务或中断服务程序在事件组中设置位。</p>
<p>提供 xClearOnExit 参数是为了避免这些潜在的竞争条件。如果 xClearOnExit 设置为 pdTRUE，那么事件位的测试和清除对调用任务来说是一个原子操作（不会被其他任务或中断中断）。<br>xClearOnExit 如果调用任务的解除阻塞条件已经满足，并且 xClearOnExit 设置为 pdTRUE，则在调用任务退出 xEventGroupWaitBits() API 函数之前，事件组中由 uxBitsToWaitFor 指定的事件位将被清除回 0。<br>如果 xClearOnExit 设置为 pdFALSE，则事件组中事件位的状态不会被 xEventGroupWaitBits() API 函数修改。</p>
<h4 id="使用事件组同步"><a href="#使用事件组同步" class="headerlink" title="使用事件组同步"></a>使用事件组同步</h4><p>向多个任务广播，可用于一次向多个任务发送事件。<br>事件组可用于创建同步点：<br>每个必须参与同步的任务都在事件组中分配了一个唯一的事件位。<br>每个任务在到达同步点时都会设置自己的事件位。<br>设置了自己的事件位后，事件组上的每个任务都会阻塞以等待代表所有其他同步任务的事件位也被设置。</p>
<p>xEventGroupSync() API函数<br>提供 xEventGroupSync() 以允许两个或多个任务使用事件组相互同步。该功能允许任务设置一个或多个事件位作为一个单一的不间断的操作。</p>
<p>EventBits_t xEventGroupSync(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait);<br>xEventGroup 要在其中设置事件位并进行测试的事件组的句柄。事件组句柄将从对用于创建事件组的 xEventGroupCreate() 的调用中返回。<br>uxBitsToSet 一个位掩码，指定要在事件组中设置为 1 的事件位或事件位。事件组的值通过将事件组的现有值与 uxBitsToSet 中传递的值进行按位或运算来更新。<br>uxBitsToWaitFor 一个位掩码，指定要在事件组中测试的一个或多个事件位。例如，如果调用任务想要等待事件组中的事件位 0、1 和 2 被设置，则将 uxBitsToWaitFor 设置为 0x07（二进制 111）。<br>                例如，将 uxBitsToSet 设置为 0x04（二进制 0100）将导致设置事件位 3（如果尚未设置），同时保持事件组中的所有其他事件位不变。<br>xTicksToWait 任务应保持在阻塞状态以等待满足其解除阻塞条件的最长时间。</p>
<h3 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h3><p>已经看到，使用 FreeRTOS 的应用程序被构建为一组独立的任务，并且这些自主任务很可能必须相互通信，以便它们共同提供有用的系统功<br>通过中介对象进行</p>
<p>任务通知功能是可选的。要包含任务通知功能，请将 FreeRTOSConfig.h 中的 configUSE_TASK_NOTIFICATIONS 设置为 1。<br>当 configUSE_TASK_NOTIFICATIONS 设置为 1 时，每个任务都有一个“通知状态”，可以是“待处理”或“未待处理”，以及一个“通知值”，它是一个 32 位无符号整数。当任务收到通知时，其通知状态设置为待处理。当任务读取其通知值时，其通知状态设置为未挂起。<br>一个任务可以在 Blocked 状态下等待它的通知状态变为未决状态，并且可以选择超时。</p>
<p>这本书已经描述了任务可以相互通信的各种方式。到目前为止所描述的方法都需要创建一个通信对象。通信对象的示例包括队列、事件组和各种不同类型的信号量。<br>当使用通信对象时，事件和数据不会直接发送到接收任务或接收 ISR，而是发送到通信对象。同样，任务和 ISR 从通信对象接收事件和数据，而不是直接从发送事件或数据的任务或 ISR。<br>“任务通知”允许任务与其他任务交互，并与 ISR 同步，而不需要单独的通信对象。通过使用任务通知，任务或 ISR 可以直接向接收任务发送事件。<br>任务通知功能是可选的。要包含任务通知功能，请将 FreeRTOSConfig.h 中的 configUSE_TASK_NOTIFICATIONS 设置为 1。</p>
<p>同样，使用任务通知向任务发送事件或数据所需的 RAM 比使用队列、信号量或事件组执行等效操作要少得多。这是因为必须先创建每个通信对象（队列、信号量或事件组）才能使用它，而启用任务通知功能的固定开销仅为每个任务的 8 字节 RAM。<br>任务通知比通​​信对象更快，使用更少的 RAM，但任务通知不能在所有场景中使用。本节记录了无法使用任务通知的场景：<br>向 ISR 发送事件或数据<br>启用多个接收任务<br>缓冲多个数据项<br>向多个任务广播<br>在阻塞状态等待发送完成</p>
<p>任务通知是一个非常强大的功能，通常可以用来代替二进制信号量、计数信号量、事件组，有时甚至是队列。这种广泛的使用场景可以通过使用xTaskNotify() API 函数发送任务通知和xTaskNotifyWait() API 函数接收任务通知来实现。<br>提供 xTaskNotifyGive() API 函数作为 xTaskNotify() 的更简单但不太灵活的替代方案，而提供 ulTask​​NotifyTake() API 函数作为 xTaskNotifyWait() 的更简单但不太灵活的替代方案。</p>
<p>本节演示如何使用 xTaskNotifyFromISR() 通过任务通知事件发送数据。清单 157 中显示的伪代码演示了该技术，它提供了用于模数转换器 (ADC) 的 RTOS 感知中断服务例程的概要</p>
<h2 id="RTOS-任务间通信机制-同步事件-信号量、互斥锁、自旋锁、事件、邮箱、消息队列-、工作队列"><a href="#RTOS-任务间通信机制-同步事件-信号量、互斥锁、自旋锁、事件、邮箱、消息队列-、工作队列" class="headerlink" title="RTOS 任务间通信机制&#x2F;同步事件 (信号量、互斥锁、自旋锁、事件、邮箱、消息队列 、工作队列)"></a>RTOS 任务间通信机制&#x2F;同步事件 (信号量、互斥锁、自旋锁、事件、邮箱、消息队列 、工作队列)</h2><ol>
<li>RTOS的常见功能<br>信号量<br>互斥<br>自旋锁<br>事件<br>邮箱<br>消息队列<br>工作队列</li>
<li>将这些功能划分成两类<br>可以简单划分一下上面这些功能的使用场合，我们分成两类，第一类是以访问控制为主，第二类是以消息的传递为主。<br>第一类是信号量、互斥锁、自旋锁、事件。第二类就是消息队列、工作队列、邮箱。</li>
</ol>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>由消息队列控制块+消息存储buffer组成，是全局变量，任务主控发送接收导致对端唤醒，还有一种方式是延时时间到了由tick中断来唤醒</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量结构<br>信号量借用的消息队列数据结构，用uxMessagesWaiting来代指资源个数，二值信号量就是这个值只能是0和1，且没有后面的buffer，如下，所以发送接收和队列基本相同</p>
<p>二值信号量存在优先级翻转问题，就是高优先级任务因为低优先级任务占用了资源且低优先级任务被高于他优先级任务抢占导致不能运行，这样高优先级就一直阻塞住了，为了解决此问题（减小影响）设计了互斥量</p>
<h3 id="互斥量（锁）"><a href="#互斥量（锁）" class="headerlink" title="互斥量（锁）"></a>互斥量（锁）</h3><p>互斥量结构<br>互斥量就是二值信号量+优先级继承，xMutexHolder保存拿到此资源的TCB，TCB中还有一个uxBasePriority用于保存此任务创建时的优先级</p>
<p>FreeRTOS没有实现谁take谁give的限制，所以一个task take，另一个task give在代码上是能跑通的，要注意这点<br>还有死锁问题，一个任务先take后再次take，此任务就被阻塞了，无法唤醒，自我死锁，此时需要用递归互斥量</p>
<p>如果两个不同优先级的任务使用同一个互斥锁，那么 FreeRTOS 调度策略会明确任务执行的顺序；能够运行的优先级最高的任务将被选为进入运行状态的任务。例如，如果一个高优先级任务处于阻塞状态以等待一个低优先级任务持有的互斥锁，那么一旦低优先级任务返回互斥锁，高优先级任务就会抢占低优先级任务. 然后，高优先级任务将成为互斥锁持有者。</p>
<p>然而，当任务具有相同优先级时，通常会错误地假设任务将执行的顺序。如果任务 1 和任务 2 具有相同的优先级，并且任务 1 处于阻塞状态以等待任务 2 持有的互斥锁，那么当任务 2“给予”互斥锁时，任务 1 不会抢占任务 2。相反，任务 2 将保持在运行状态，而任务 1 将简单地从阻塞状态移动到就绪状态。</p>
<h3 id="递归互斥量（递归锁）"><a href="#递归互斥量（递归锁）" class="headerlink" title="递归互斥量（递归锁）"></a>递归互斥量（递归锁）</h3><p>递归互斥量和临界区嵌套设计方式一样，uxRecursiveCallCount来记录递归次数，且递归互斥量实现了谁take谁give的限制。</p>
<h3 id="自旋锁-（原地等待锁）"><a href="#自旋锁-（原地等待锁）" class="headerlink" title="自旋锁 （原地等待锁）"></a>自旋锁 （原地等待锁）</h3><p>在有些场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。</p>
<p>如果机器有多个CPU核心，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
<p>缺点<br>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。</p>
<p>如果锁被占用的时间很短，自旋等待的效果就会非常好；<br>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。<br>所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程。（这个次数默认是10次，可以配置）</p>
]]></content>
      <categories>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>rtos</tag>
      </tags>
  </entry>
  <entry>
    <title>java</title>
    <url>/2022/03/02/java/</url>
    <content><![CDATA[<h3 id="安装-oracle-jdk"><a href="#安装-oracle-jdk" class="headerlink" title="安装 oracle jdk"></a>安装 oracle jdk</h3><p>尽管现在jdk版本已经更新到17了，但是因为oracle jdk8u202版本后商用收费了，另外，也可以使用高版本的open jdk, Linux从源安装，一般都是自动指向OpenJDK的（免费开源嘛），如果要下载Oracle JDK一般需要手动下载。这边安装奇数版本jdk8u201,官网下载，需要注册&#x2F;登录帐号，<br><a href="https://www.oracle.com/java/technologies/downloads/archive/">https://www.oracle.com/java/technologies/downloads/archive/</a></p>
<span id="more"></span>

<p>创建目录:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /usr/lib/jvm</span><br></pre></td></tr></table></figure>

<p>解压缩到该目录:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf jdk-8u201-linux-x64.tar.gz -C /usr/lib/jvm/</span><br></pre></td></tr></table></figure>

<p>修改环境变量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>在文件末尾追加下面内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#set oracle jdk environment</span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_201 </span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>使环境变量马上生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>查看java版本，看看是否安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p>另外，也可以在update-alternatives工具中注册，update-alternatives 命令用于处理linux系统中软件版本的切换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.8.0_201/bin/java 300</span><br></pre></td></tr></table></figure>

<p>下面手动修改为jdk1.8.0_91：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config java</span><br></pre></td></tr></table></figure>


<h4 id="安装IntelliJ-IDEA"><a href="#安装IntelliJ-IDEA" class="headerlink" title="安装IntelliJ IDEA"></a>安装IntelliJ IDEA</h4><p>IDEA这玩意好用是好用，就是太费内存了，没个8G，16G用起来不得劲！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo snap install intellij-idea-community --classic</span><br></pre></td></tr></table></figure>

<h4 id="Ubuntu下安装配置-maven"><a href="#Ubuntu下安装配置-maven" class="headerlink" title="Ubuntu下安装配置 maven"></a>Ubuntu下安装配置 maven</h4><p>在上古时代，Java的构建都在使用make，编写makefile来进行Java构建有非常多别扭与不便的地方。</p>
<p>紧接着Apache Ant诞生了，Ant可以灵活的定义清理编译测试打包等过程，但是由于没有依赖管理的功能，以及需要编写复杂的xml，还是存在着诸多的不便。</p>
<p>随后Apache Maven诞生了，Maven是一个依赖项管理和构建自动化工具，遵循着约定大于配置的规则。虽然也需要编写xml，但是对于复杂工程更加容易管理，有着标准化的工程结构，清晰的依赖管理。此外，由于Maven本质上是一个插件执行框架，也提供了一定的开放性的能力，我们可以通过Maven的插件开发，为构建构成创造一定的灵活性。</p>
<p>但是由于采用约定大于配置的方式，丧失了一定的灵活性，同时由于采用xml管理构建过程与依赖，随着工程的膨胀，配置管理还是会带来不小的复杂度，在这个背景下，集合了Ant与Maven各自优势的Gradle诞生了。</p>
<p>从maven官网下载maven到&#x2F;user&#x2F;local<br>配置环境变量<br>编辑~&#x2F;.bashrc</p>
<p>~&#x2F;.bashrc：该文件包含用于你的bash shell的bash信息，当登录时以及每次打开新的shell时，该文件被读取；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>在最后输入以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export M2_HOME=/usr/local/apache-maven-3.5.0</span><br><span class="line">(根据你下载的maven文件名而定，我这里版本是3.5.0)</span><br><span class="line">export M2=$M2_HOME/bin</span><br><span class="line">export MAVEN_OPTS=&quot;-Xms256m -Xmx512m&quot;</span><br><span class="line">export PATH=$M2:$PATH</span><br></pre></td></tr></table></figure>
<p>使环境变量生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>检验是否成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn --version</span><br></pre></td></tr></table></figure>

<p>打开Maven项目根目录，运行以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn -U clean package</span><br></pre></td></tr></table></figure>
<p>其中-U参数为强制更新依赖包，clean指令意为清空缓存文件，package指令意为生成target目录，编译、测试代码，生成测试报告，生成jar&#x2F;war文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean spring-boot:run</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux deploy</title>
    <url>/2023/01/27/linuxdeploy/</url>
    <content><![CDATA[<h3 id="google-play"><a href="#google-play" class="headerlink" title="google play"></a>google play</h3><p>可以直接获取并下载Google Play APK的镜像站<br>Google Play官网：<a href="https://play.google.com/store">https://play.google.com/store</a></p>
<p>1、可以直接搜索应用名并下载的，但需要爬Q<br><a href="http://apkleecher.com/">http://apkleecher.com/</a><br><a href="http://apk-dl.com/">http://apk-dl.com/</a><br><a href="https://apkpure.com/">https://apkpure.com/</a><br>2、需要输入Google Play链接或者包名<br><a href="http://www.apksmart.com/">http://www.apksmart.com/</a><br><a href="https://tingyuan.me/apkdownload/">https://tingyuan.me/apkdownload/</a><br><a href="https://androidappsapk.co/apkdownloader/">https://androidappsapk.co/apkdownloader/</a></p>
<span id="more"></span>
<h3 id="旧手机"><a href="#旧手机" class="headerlink" title="旧手机"></a>旧手机</h3><p>新手机建议安装Termux终端模拟，这里针对破铜烂铁,决定废物利用下，拿来安装inux deploy，当作VPS用，安装 fr，clash，nginx，hexo博客等。<br>屏幕大的的就安装spacedesk当作电脑副屏。<br>打扫卫生发现家里有一堆旧手机,性能排列如下：</p>
<table>
<thead>
<tr>
<th>手机型号</th>
<th>CPU</th>
<th>架构</th>
<th>指令集</th>
<th>内存</th>
<th>系统版本</th>
</tr>
</thead>
<tbody><tr>
<td>S7edge</td>
<td>骁龙820</td>
<td>Kryo</td>
<td>ARMv8</td>
<td>4+32</td>
<td>android9.0</td>
</tr>
<tr>
<td>红米5A</td>
<td>骁龙425</td>
<td>A53</td>
<td>ARMv8</td>
<td>3+32</td>
<td>android8.1</td>
</tr>
<tr>
<td>坚果</td>
<td>骁龙615</td>
<td>A53</td>
<td>ARMv8</td>
<td>2+16</td>
<td>android8.1</td>
</tr>
<tr>
<td>魅蓝metal</td>
<td>MT6795</td>
<td>A53</td>
<td>ARMv8</td>
<td>2+16</td>
<td>android5.1</td>
</tr>
<tr>
<td>魅蓝2</td>
<td>MT6735</td>
<td>A53</td>
<td>ARMv8</td>
<td>2+16</td>
<td>android5.1</td>
</tr>
<tr>
<td>大神F1</td>
<td>MT6592</td>
<td>A7</td>
<td>ARMv7</td>
<td>2+8</td>
<td>android4.4</td>
</tr>
<tr>
<td>红米NOTE</td>
<td>骁龙400</td>
<td>A7</td>
<td>ARMv7</td>
<td>2+8</td>
<td>android4.4</td>
</tr>
<tr>
<td>三星8268</td>
<td>samsung</td>
<td>A7</td>
<td>ARMv7</td>
<td>1+4</td>
<td>android4.1</td>
</tr>
</tbody></table>
<p>参考手机性能天梯图：<a href="https://www.mydrivers.com/zhuanti/tianti/01/">https://www.mydrivers.com/zhuanti/tianti/01/</a></p>
<h4 id="Android各版本和Linux版本对应关系"><a href="#Android各版本和Linux版本对应关系" class="headerlink" title="Android各版本和Linux版本对应关系"></a>Android各版本和Linux版本对应关系</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Android Version    |API Level  |Linux Kernel in AOSP</span><br><span class="line">----------------------------------------------------</span><br><span class="line">1.5   Cupcake      |3          |2.6.27</span><br><span class="line">1.6   Donut        |4          |2.6.29</span><br><span class="line">2.0/1 Eclair       |5-7        |2.6.29</span><br><span class="line">2.2.x Froyo        |8          |2.6.32</span><br><span class="line">2.3.x Gingerbread  |9, 10      |2.6.35</span><br><span class="line">3.x.x Honeycomb    |11-13      |2.6.36</span><br><span class="line">4.0.x Ice Cream San|14, 15     |3.0.1</span><br><span class="line">4.1.x Jelly Bean   |16         |3.0.31</span><br><span class="line">4.2.x Jelly Bean   |17         |3.4.0</span><br><span class="line">4.3   Jelly Bean   |18         |3.4.39</span><br><span class="line">4.4   Kit Kat      |19, 20     |3.10</span><br><span class="line">5.x   Lollipop     |21, 22     |3.16.1</span><br><span class="line">6.0   Marshmallow  |23         |3.18.10</span><br><span class="line">7.0   Nougat       |24         |4.4.1</span><br><span class="line">7.1   Nougat       |25         |4.4.1</span><br><span class="line">8.0   Oreo         |26         |4.10</span><br><span class="line">8.1   Oreo         |27         |4.10</span><br><span class="line">9.0   Pie          |28         |4.4, 4.9 and 4.14</span><br></pre></td></tr></table></figure>

<h4 id="三星8268"><a href="#三星8268" class="headerlink" title="三星8268"></a>三星8268</h4><p>做个闹钟还可以，其他就算了。</p>
<h4 id="红米NOTE"><a href="#红米NOTE" class="headerlink" title="红米NOTE"></a>红米NOTE</h4><p>安卓4.0的砖头，没能刷入好用的5.1以上的room</p>
<h4 id="大神F1"><a href="#大神F1" class="headerlink" title="大神F1"></a>大神F1</h4><p>MT6592为32位CPU, 8个A7，主频高达1.8-2G，性能却比6735,小龙615，400好。</p>
<h4 id="魅蓝2"><a href="#魅蓝2" class="headerlink" title="魅蓝2"></a>魅蓝2</h4><p>MT6735为MTK第一代64位，4个A53 主频高达1.1-1.3G，低功耗，性能不行<br>frp-ARMv8可以用,用不了frp-ARMv7，clash—ARMv8用不了,clash-ARMv7可以用。无语。</p>
<h4 id="魅蓝metal"><a href="#魅蓝metal" class="headerlink" title="魅蓝metal"></a>魅蓝metal</h4><p>MT6795为64位8个A53，主频高达2.2G，性能可以大战小龙808了<br>还有6寸1080P大屏，可以当电脑副屏了。</p>
<h4 id="坚果"><a href="#坚果" class="headerlink" title="坚果"></a>坚果</h4><p>龙哥的艺术品，就不折腾她了，静静的躺着吧，毕竟锤子绝版了。</p>
<h4 id="红米5A"><a href="#红米5A" class="headerlink" title="红米5A"></a>红米5A</h4><p>留着以后搞，刷机发现recovery使用orangefox的,twrp官网的3.50用不了。</p>
<h4 id="S7edge"><a href="#S7edge" class="headerlink" title="S7edge"></a>S7edge</h4><p>安装Termux终端模拟。<br>高通820，功耗实在牛，就当作冬天暖手宝。<br>2k高清曲屏，拿来刷抖音，边暖手，舒服。</p>
<h3 id="刷系统"><a href="#刷系统" class="headerlink" title="刷系统"></a>刷系统</h3><p>android 5.x以上才具有安装linux deploy的价值，可能和linux内核的版本也有关吧，<br>挑选出这三台：魅蓝metal,魅蓝2,大神F1,三台都刷了flyme，安卓5.1。</p>
<p>登录flyme账户后给Kingroot权限能就能root，联网root 完，再换kingroot使用v9.9.9去除广告版来管理root权限，更清爽。</p>
<p>其中魅蓝metal，m2 为flyme 6.3，发现root 一顿操作后发现,实现开机启动，需要让手机管家.apk活着（通过手机管家唤醒自启动服务？？）,<br>而手机管家又会自动升级，甚至卸载KING root。极其恶心。<br>解决方法:直接找到&#x2F;system&#x2F;app&#x2F;中，删掉手机管家，或者一开始就在固件包中删掉它。</p>
<p>大神F1刷了flyme5.1，flyme5本是基于YUN OS的，这个版本是修改版，基于android 5.1，手机管家不会乱来。<br>但是大神的centos7 是32位的…32位的centos太难用了，很多库要找来找去的，跟不上时代了。</p>
<blockquote>
<p>注意：Android3.1之后，应用程序无法在安装后自己启动，没有ui的程序必须通过其他应用激活才能启动，如它的<code>Activity、Service、Content Provider</code>被其他应用调用。估计手机管家干这活不过，存在一种例外，就是&#x3D;&#x3D;应用程序被<code>adb push you.apk /system/app/</code>下是会自动启动的，不处于stopped状态&#x3D;&#x3D;。解决方式就是将APK推送到<code>/system/app</code>目录下,或者打包系统时，将APK放置到<code>/system/app</code> 中打包把linnux deploy 一定要安装到<code>/system/app</code>下</p>
</blockquote>
<p>总的来说，要安卓5.x以上，内核版本3.16.1，avrmv8架构才有搞头。</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul>
<li>RomMakeTool： 奇兔刷机的低版本ROM制作工具，需要断网使用 可以修改boot.img， 打包修改ROM等。</li>
<li>root工具：magisk manager 7.0+ 或者 kingroot v999 去广告版</li>
<li>Root Explorer : 文件拷贝，删除&#x2F;system&#x2F;app下固件等</li>
<li>busybox: pro 工具包</li>
<li>linux deploy : 2.4+</li>
<li>wifi adb: 无线 adb <code>adb connect ip:5555</code></li>
<li>Scrcpy: 电脑端远程直接控制手机</li>
</ul>
<p>链接：<a href="https://pan.baidu.com/s/1zt4C5yY-1CDXZef-mIOjVg">https://pan.baidu.com/s/1zt4C5yY-1CDXZef-mIOjVg</a><br>提取码：link （链接无效了，因为被百度拉黑，限速10KB了，日了狗）</p>
<h3 id="安装-centos"><a href="#安装-centos" class="headerlink" title="安装 centos"></a>安装 centos</h3><p> CPU类型对应架构如下，新出的都是64位的啦<br> 32位：A7(ARMv7)  - armhfp<br> 64位：A53(ARMv8) - aarch64&#x2F;arm64</p>
<h3 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h3><ul>
<li>安装类型：目录</li>
<li>安装路径：<code>/data/centos</code> （重要）</li>
<li>用户：root</li>
<li>启用初始化系统 <code>run-parts</code>，启用 <code>SSH</code></li>
</ul>
<h3 id="设置选项"><a href="#设置选项" class="headerlink" title="设置选项"></a>设置选项</h3><ul>
<li>锁定WIFI</li>
<li>CPU唤醒</li>
<li>开机启动</li>
<li>时间戳</li>
</ul>
<h3 id="隐身恢复"><a href="#隐身恢复" class="headerlink" title="隐身恢复"></a>隐身恢复</h3><p>点了设置中的隐身模式，会找不到她了</p>
<h4 id="使用-adb-恢复"><a href="#使用-adb-恢复" class="headerlink" title="使用 adb 恢复"></a>使用 adb 恢复</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb</span><br><span class="line">shell</span><br><span class="line">su</span><br><span class="line">am start -n ru.meefik.linuxdeploy/.MainActivity</span><br></pre></td></tr></table></figure>
<h3 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h3><p>若安装速度慢，可以尝试直接使用备份好的gz镜像源<br>使用备份的镜像时，不要点配置，安装完就可以使用了，点配置容易出问题。<br>常用rootfs下载地址(2019.12.13)</p>
<p><a href="http://hub.meefik.ru/rootfs/alpine_arm64.tgz">http://hub.meefik.ru/rootfs/alpine_arm64.tgz</a><br><a href="http://hub.meefik.ru/rootfs/centos_arm64.tgz">http://hub.meefik.ru/rootfs/centos_arm64.tgz</a><br><a href="http://hub.meefik.ru/rootfs/kali_arm64.tgz">http://hub.meefik.ru/rootfs/kali_arm64.tgz</a><br><a href="http://hub.meefik.ru/rootfs/kalitop10_arm64.tgz">http://hub.meefik.ru/rootfs/kalitop10_arm64.tgz</a><br><a href="http://hub.meefik.ru/rootfs/ubuntu_arm64.tgz">http://hub.meefik.ru/rootfs/ubuntu_arm64.tgz</a><br>若安装失败，尝试更换linux deploy 版本<br>tasker 启动命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /data/data/ru.meefik.linuxdeploy/files/bin/linuxdeploy start -m</span><br></pre></td></tr></table></figure>
<h4 id="ssh-fail"><a href="#ssh-fail" class="headerlink" title="ssh fail"></a>ssh fail</h4><p>1.一般出现ssh fail的问题，是因为镜像在安装时没有安装完整，有可能是因为网络掉包、磁盘空间不够或者选择的镜像源有问题导致。</p>
<p>2.现在我们可以不通过ssh连接容器，用作者预留的通道连接容器，连接容器后再安装ssh就可以解决此问题。</p>
<p>3.具体方法如下：打开linuxdeploy，启动容器后,adb连接手机，输入一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">cd /</span><br><span class="line">./data/data/ru.meefik.linuxdeploy/files/bin/linuxdeploy shell -u root</span><br></pre></td></tr></table></figure>

<p>4.这样就获得容器的shell了，通过这个shell安装ssh。</p>
<h4 id="rc-local-fail"><a href="#rc-local-fail" class="headerlink" title="rc.local fail"></a>rc.local fail</h4><p>如果后续出现 <code>rc.local... fail</code><br>SSH连接后，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chown root:root /etc/rc.local</span><br><span class="line">sudo chmod 755 /etc/rc.local </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh -e</span><br><span class="line">#</span><br><span class="line"># rc.local</span><br><span class="line">#</span><br><span class="line"># This script is executed at the end of each multiuser runlevel.</span><br><span class="line"># Make sure that the script will &quot;exit 0&quot; on success or any other</span><br><span class="line"># value on error.</span><br><span class="line">#</span><br><span class="line"># In order to enable or disable this script just change the execution</span><br><span class="line"># bits.</span><br><span class="line">#</span><br><span class="line"># By default this script does nothing.</span><br><span class="line"></span><br><span class="line"># webdav      </span><br><span class="line">nohup /usr/local/bin/aliyundrive-webdav &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"># vlmcsd       </span><br><span class="line">nohup /usr/local/bin/vlmcsd-armv7el-uclibc-static &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"># clash          </span><br><span class="line">nohup /usr/share/clash/clash -d /usr/share/clash &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"># frpc           </span><br><span class="line">nohup /usr/local/bin/frpc -c /usr/local/etc/frpc.ini &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"># hyperion    </span><br><span class="line">nohup /usr/share/hyperion/bin/hyperiond &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"># mosquitto  </span><br><span class="line">nohup /usr/sbin/mosquitto &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"># hass           </span><br><span class="line">nohup /usr/local/bin/python3.10 /usr/local/bin/hass &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><ol>
<li>手机设置静态IP</li>
<li>局域网内使用 Termius 工具SSH登录手机IP使用</li>
<li>传输文件安装 FileZilla 使用sftp</li>
</ol>
<h3 id="使用华为镜像源"><a href="#使用华为镜像源" class="headerlink" title="使用华为镜像源"></a>使用华为镜像源</h3><p>CentOS-AltArch的镜像地址为：<a href="https://repo.huaweicloud.com/centos-altarch/">https://repo.huaweicloud.com/centos-altarch/</a></p>
<h3 id="无线-ADB使用"><a href="#无线-ADB使用" class="headerlink" title="无线 ADB使用"></a>无线 ADB使用</h3><p>Android 11 及更高版本支持使用 Android 调试桥 (adb) 从工作站以无线方式部署和调试应用。</p>
<h4 id="通过-WLAN-连接到设备（Android-10-及更低版本）"><a href="#通过-WLAN-连接到设备（Android-10-及更低版本）" class="headerlink" title="通过 WLAN 连接到设备（Android 10 及更低版本）"></a>通过 WLAN 连接到设备（Android 10 及更低版本）</h4><p>将 Android 设备和 adb 主机连接到这两者都可以访问的同一 WLAN 网络。请注意，并非所有接入点都适用；您可能需要使用防火墙已正确配置为支持 adb 的接入点。<br>如果您要连接到 Wear OS 设备，请关闭手机上与该设备配对的蓝牙。<br>使用 USB 线将设备连接到主机。<br>设置目标设备以监听端口 <code>5555</code> 上的 TCP&#x2F;IP 连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb tcpip 5555</span><br></pre></td></tr></table></figure>
<p>拔掉连接目标设备的 USB 线。<br>找到 Android 设备的 IP 地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb connect device_ip_address</span><br></pre></td></tr></table></figure>
<p>确认主机已连接到目标设备：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">device_ip_address:5555 device</span><br></pre></td></tr></table></figure>
<h4 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h4><p>您可以使用 adb 的 install 命令在模拟器或连接的设备上安装 APK：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb install path_to_apk</span><br></pre></td></tr></table></figure>
<p>在以下示例中，先获得了已连接设备的列表，然后使用其中一个设备的序列号在该设备上安装了 helloWorld.apk。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">emulator-5554 device</span><br><span class="line">emulator-5555 device</span><br><span class="line"></span><br><span class="line">$ adb -s emulator-5555 install helloWorld.apk</span><br></pre></td></tr></table></figure>
<h4 id="将文件复制到设备-从设备复制文件"><a href="#将文件复制到设备-从设备复制文件" class="headerlink" title="将文件复制到设备&#x2F;从设备复制文件"></a>将文件复制到设备&#x2F;从设备复制文件</h4><p>您可以使用 <code>pull</code> 和 <code>push</code> 命令将文件复制到设备或从设备复制文件。与 <code>install</code> 命令（仅将 APK 文件复制到特定位置）不同，使用 <code>pull</code> 和 <code>push</code> 命令可将任意目录和文件复制到设备中的任何位置。</p>
<p>如需从设备中复制某个文件或目录（及其子目录），请使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull remote local</span><br></pre></td></tr></table></figure>
<p>如需将某个文件或目录（及其子目录）复制到设备，请使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push local remote</span><br></pre></td></tr></table></figure>
<p>将 local 和 remote 替换为开发机器（本地）和设备（远程）上的目标文件&#x2F;目录的路径。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push foo.txt /sdcard/foo.txt</span><br></pre></td></tr></table></figure>

<p>停止 adb 服务器<br>在某些情况下，您可能需要终止 adb 服务器进程，然后重启以解决问题（例如，如果 adb 不响应命令）。</p>
<p>如需停止 adb 服务器，请使用 <code>adb kill-server</code> 命令。然后，您可以通过发出其他任何 adb 命令来重启服务器。</p>
<p>发出 adb 命令<br>您可以从开发机器上的命令行发出 adb 命令，也可以通过脚本发出。用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb [-d | -e | -s serial_number] command</span><br></pre></td></tr></table></figure>
<p>如果只有一个模拟器在运行或者只连接了一个设备，系统会默认将 adb 命令发送至该设备。如果有多个模拟器正在运行并且&#x2F;或者连接了多个设备，您需要使用 -d、-e 或 -s 选项指定应向其发送命令的目标设备。</p>
<p>您可以使用以下命令来查看所有支持的 adb 命令的详细列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb --help</span><br></pre></td></tr></table></figure>

<p>更多adb操作参考 <a href="https://developer.android.com/studio/command-line/adb">https://developer.android.com/studio/command-line/adb</a></p>
<h3 id="安卓上电开机"><a href="#安卓上电开机" class="headerlink" title="安卓上电开机"></a>安卓上电开机</h3><p>出处 <a href="https://www.jianshu.com/p/391905516d63">https://www.jianshu.com/p/391905516d63</a></p>
<p>需要：<br>已root权限、已解BL锁<br>已root权限、已解BL锁<br>已root权限、已解BL锁</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li><p>先用recovery备份boot分区，翻车可直接进入rec恢复boot分区。</p>
</li>
<li><p>直接修改根目录下的init.rc，无用，开机会被覆盖。</p>
</li>
</ol>
<h4 id="提取boot-img"><a href="#提取boot-img" class="headerlink" title="提取boot.img"></a>提取boot.img</h4><p>使用recovery备份的boot，存放在内置储存的根目录下，MTP导出到电脑。</p>
<h4 id="解包和修改init-rc"><a href="#解包和修改init-rc" class="headerlink" title="解包和修改init.rc"></a>解包和修改init.rc</h4><p>电脑端使用recovery的工具解包后，编辑的boot.img中的init.rc”，搜索关键词“charger”，找到下面这一段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">on charger</span><br><span class="line">class_start charger        </span><br><span class="line">setprop sys.powerctl reboot      #加入重启命令</span><br></pre></td></tr></table></figure>

<p>保存，退出</p>
<h4 id="会刷boot-img"><a href="#会刷boot-img" class="headerlink" title="会刷boot.img"></a>会刷boot.img</h4><p>将新生成的boot.img用recovery刷回手机中，重启手机。</p>
<h3 id="电脑控制手机"><a href="#电脑控制手机" class="headerlink" title="电脑控制手机"></a>电脑控制手机</h3><p>神器：<a href="https://github.com/Genymobile/scrcpy/releases/tag/v1.17">https://github.com/Genymobile/scrcpy/releases/tag/v1.17</a><br>手机屏幕触摸怀了，可以通过OTG连接鼠标控制,安装开源的Scrcpy 还能在电脑端直接控制手机。<br>毁掉手机屏幕前，一定要设置好允许adb调试，adb root权限，adb模拟输入，scrcpy控制，上电自动开机等。<br>根据官方介绍，Scrcpy 的特性如下：</p>
<ul>
<li>轻量级（原生，仅显示设备屏幕）</li>
<li>高性能（帧率 30〜60 fps）</li>
<li>高画质（分辨率 1920×1080 或以上）</li>
<li>低延迟（35〜70ms）</li>
<li>启动时间短（1秒内显示）</li>
<li>非侵入性（设备上未安装任何软件）</li>
</ul>
<h3 id="穿透内网"><a href="#穿透内网" class="headerlink" title="穿透内网"></a>穿透内网</h3><p>1.安装frp<br>2.修改配置，使用免费的frp服务器<a href="https://freefrp.net/">https://freefrp.net/</a> 或其他或自建</p>
<h3 id="解决chroot下无法使用service-systemctl"><a href="#解决chroot下无法使用service-systemctl" class="headerlink" title="解决chroot下无法使用service, systemctl"></a>解决chroot下无法使用service, systemctl</h3><p>在Linux Deploy中安装的CentOS7无法使用systemctl命令,当我们使用systemctl启动服务时它提示我们,Running in chroot, ignoring request.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/smaknsk/servicectl/archive/1.0.tar.gz</span><br><span class="line">tar -xf 1.0.tar.gz -C /usr/local/lib/</span><br><span class="line">ln -s /usr/local/lib/servicectl-1.0/servicectl /usr/bin/servicectl</span><br><span class="line">ln -s /usr/local/lib/servicectl-1.0/serviced /usr/bin/serviced</span><br></pre></td></tr></table></figure>
<p>使用<br>servicectl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo servicectl action service</span><br></pre></td></tr></table></figure>
<p>‎此命令仅执行文件 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;${service}.service中的${action}， 如果通过的操作启用或禁用，则servicectl将在 ${service}.service上创建或删除symlink以供使用服务。‎</p>
<p>参数:</p>
<p>action - 可以是 {start, stop, restart, reload, enable, disable}<br>service -在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;文件夹中的文件</p>
<p>serviced</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo serviced action</span><br></pre></td></tr></table></figure>
<p>‎此命令执行 ${action} 为所有启用服务。‎</p>
<p>参数:</p>
<p>action -默认是start，也可以是： {start, stop, restart, reload, disable}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># inside chroot</span><br><span class="line">sudo servicectl enable mariadb</span><br><span class="line"></span><br><span class="line"># outside chroot: </span><br><span class="line"># init startup and run all enabled daemons</span><br><span class="line">sudo chroot /path/to/chroot serviced</span><br></pre></td></tr></table></figure>
<h3 id="手机改直供电"><a href="#手机改直供电" class="headerlink" title="手机改直供电"></a>手机改直供电</h3><p>手机一直插着电池，时间长了，电池会鼓包，需要修改直供电。取出电池的电池保护板，5V供正极电接BAT+，这里负极不接BAT-，接电池保护板输出的地(如果接BAT-，需要外挂充电宝才能开机)。安卓手机改了直供电，电池电量显示百分比还会随着时间减少，怀疑手机系统虚拟的，而不是电池检测电路的问题。解决方法，通过adb 设置手机一直在充电状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">dumpsys battery set status 2</span><br></pre></td></tr></table></figure>

<h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><p>liunx deploy下的centos安装mysql5.7</p>
<ol>
<li>添加mysql用户组和mysql用户<br>2.安装依赖库</li>
<li>下载解压Mysql<br>4.配置Mysql</li>
<li>添加环境变量<br>6 mysql 初始化<br>7 mysql 启动，关闭</li>
</ol>
<p>MySQL下载地址为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://obs.cn-north-4.myhuaweicloud.com/obs-mirror-ftp4/database/mysql-5.7.27-aarch64.tar.gz</span><br></pre></td></tr></table></figure>
<ol>
<li>添加mysql用户组和mysql用户<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># groupadd mysql     //创建mysql组</span><br><span class="line"># useradd -g mysql mysql //创建mysql用户添加到mysql组</span><br><span class="line"># usermod -a -G aid_inet,aid_net_raw mysql   //添加mysql在安卓中的网络访问权限</span><br></pre></td></tr></table></figure>
2.安装依赖库<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum install -y libaio*</span><br></pre></td></tr></table></figure></li>
<li>下载解压Mysql<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># wget https://obs.cn-north-4.myhuaweicloud.com/obs-mirror-ftp4/database/mysql-5.7.27-aarch64.tar.gz</span><br><span class="line"># tar -xvf mysql-5.7.27-aarch64.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure>
4.配置Mysql<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mv /usr/local/mysql-5.7.27-aarch64 /usr/local/mysql</span><br><span class="line"># mkdir -p /usr/local/mysql/logs</span><br><span class="line"># chown -R mysql:mysql /usr/local/mysql </span><br><span class="line"># ln -sf /usr/local/mysql/my.cnf /etc/my.cnf</span><br><span class="line"># cp -rf /usr/local/mysql/extra/lib* /usr/lib64/ </span><br><span class="line"># mv /usr/lib64/libstdc++.so.6 /usr/lib64/libstdc++.so.6.old</span><br><span class="line"># ln -s /usr/lib64/libstdc++.so.6.0.24 /usr/lib64/libstdc++.so.6</span><br></pre></td></tr></table></figure></li>
<li>添加环境变量<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vim /etc/profile</span><br></pre></td></tr></table></figure>
添加下面两行代码：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export MYSQL_HOME=/usr/local/mysql</span><br><span class="line">export PATH=$PATH:$MYSQL_HOME/bin</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># source /etc/profile</span><br></pre></td></tr></table></figure>
6 mysql 初始化<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data</span><br></pre></td></tr></table></figure>
1<br>7 mysql 启动，关闭<br>方法一（不行，提示chroot）<br>设置开机启动<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cp -rf /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld </span><br><span class="line"># chmod +x /etc/init.d/mysqld</span><br><span class="line"># service mysqld start  #启动</span><br><span class="line"># service mysqld stop  #关闭</span><br></pre></td></tr></table></figure>
都可使用的指令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service mysqld &#123;start|stop|restart|reload|force-reload|status&#125;</span><br></pre></td></tr></table></figure>
方法二（使用rc.local nohup &amp;）<br>新建&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;startmysql.sh<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">nohup /usr/local/mysql/support-files/mysql.server start &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
在rc.local增加<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysql</span><br><span class="line">sh /usr/local/mysql/support-files/startmysql.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<p>8 登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># msyql -u root </span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个安装是免密登录的</p>
<h3 id="安装-Homeassistant"><a href="#安装-Homeassistant" class="headerlink" title="安装 Homeassistant"></a>安装 Homeassistant</h3><p>Home Assistant时会报错版本过低，所以这里采用编译源码的方式安装Python3.9.13和Sqlite3.39.0</p>
<h4 id="先安装依赖"><a href="#先安装依赖" class="headerlink" title="先安装依赖"></a>先安装依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt upgrade -y</span><br><span class="line">sudo apt install -y gcc wget build-essential zlib1g-dev libbz2-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libjpeg-dev autoconf libopenjp2-7 libtiff5 libturbojpeg0-dev tzdata</span><br></pre></td></tr></table></figure>
<h4 id="安装Sqlite"><a href="#安装Sqlite" class="headerlink" title="安装Sqlite"></a>安装Sqlite</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://www.sqlite.org/2022/sqlite-autoconf-3390000.tar.gz</span><br><span class="line">tar -zxvf sqlite-autoconf-3390000.tar.gz</span><br><span class="line">cd sqlite-autoconf-3390000</span><br><span class="line">./configure</span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>查看当前Sqlite版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite3 --version</span><br></pre></td></tr></table></figure>
<h4 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf Python-3.9.13.tgz</span><br><span class="line">cd Python-3.9.13</span><br></pre></td></tr></table></figure>
<p>Python编译链接使用刚安装的Sqlite版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LD_RUN_PATH=/usr/local/lib ./configure LDFLAGS=&quot;-L/usr/local/lib&quot; CPPFLAGS=&quot;-I/usr/local/include&quot;</span><br><span class="line">LD_RUN_PATH=/usr/local/lib make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>查看当前Python版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -V</span><br><span class="line">pip3 -V</span><br></pre></td></tr></table></figure>
<p>查看Python使用的Sqlite版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3</span><br><span class="line">&gt;&gt;&gt; import sqlite3</span><br><span class="line">&gt;&gt;&gt; sqlite3.sqlite_version</span><br><span class="line">&#x27;3.39.0&#x27;</span><br><span class="line">&gt;&gt;&gt; quit()</span><br></pre></td></tr></table></figure>
<h4 id="安装-hass"><a href="#安装-hass" class="headerlink" title="安装 hass"></a>安装 hass</h4><ol>
<li>先安装docker，再安装hass</li>
<li>直接安装</li>
<li>官方文档：<br><a href="https://www.home-assistant.io/installation/linux#install-home-assistant-core">https://www.home-assistant.io/installation/linux#install-home-assistant-core</a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir /srv/homeassistant</span><br><span class="line">cd /srv/homeassistant</span><br><span class="line">python3 -m venv .</span><br><span class="line">source bin/activate</span><br></pre></td></tr></table></figure>
激活虚拟环境后会变成这样</li>
</ol>
<p>(homeassistant) root@localhost:&#x2F;srv&#x2F;homeassistant#<br>再次检查一下虚拟环境中的版本信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -V</span><br><span class="line">pip3 -V</span><br></pre></td></tr></table></figure>
<p>更新一下pip版本，并改成国内源加快一下下载速度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m pip install --upgrade pip</span><br><span class="line">pip3 config set global.index-url https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>
<p>更新一下setuptools和wheel的版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m pip install --upgrade setuptools</span><br><span class="line">python3 -m pip install --upgrade wheel</span><br></pre></td></tr></table></figure>
<p>安装Home Assistant</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install homeassistant</span><br></pre></td></tr></table></figure>
<p>启动Home Assistant</p>
<p>hass<br>注：首次启动Home Assistant时会下载一些依赖，所以启动时间会较长，访问<a href="http://x.x.x.x:8123时会出现无法访问是正常现象，说明HA还没启动完成">http://x.x.x.x:8123时会出现无法访问是正常现象，说明HA还没启动完成</a></p>
<p>后面会用到的一些命令就贴在这儿了</p>
<p>后台运行hass</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup hass &gt; hass.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>tail查看日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail hass.log</span><br></pre></td></tr></table></figure>
<p>以后ssh连接后可以直接执行以下命令激活虚拟环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /srv/homeassistant/bin/activate</span><br></pre></td></tr></table></figure>
<p>退出虚拟环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deactivate </span><br></pre></td></tr></table></figure>

<h3 id="Hyperion-grabber"><a href="#Hyperion-grabber" class="headerlink" title="Hyperion grabber"></a>Hyperion grabber</h3><p>start the grabber in home assistant with the androidtv integration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service: androidtv.adb_command</span><br><span class="line">data:</span><br><span class="line">  command: &quot;am start com.abrenoch.hyperiongrabber/com.abrenoch.hyperiongrabber.common.BootActivity&quot;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux_deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile 文件使用</title>
    <url>/2024/04/14/makefile%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Makefile的编写 </p>
<span id="more"></span>
<h3 id="源程序编译"><a href="#源程序编译" class="headerlink" title="源程序编译"></a>源程序编译</h3><ol>
<li>源程序的编译<br>在 Linux 下面，如果要编译一个 C 语言源程序，我们要使用 GNU 的 gcc 编译器。 下面我们以一个实例来说明如何使用 gcc 编译器。<br>假设我们有下面一个非常简单的源程序 (hello.c)：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(int argc，char **argv)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;Hello Linux\n&quot;)；  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>要编译这个程序，我们只要在命令行下执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure>


<p>gcc 编译器就会为我们生成一个 hello 的可执行文件。执行.&#x2F;hello 就可以看到程序的输出结果了。命令行中 gcc 表示我们是用 gcc 来编译我们的源程序，-o 选项表示我们要求编译器给我们输出的可执行文件名为 hello 而 hello.c 是我们的源程序文件。<br>gcc 编译器有许多选项，一般来说我们只要知道其中的几个就够了。 -o 选项我们已经知道了，表示我们要求输出的可执行文件名。 -c 选项表示我们只要求编译器输出目标代码，而不必要输出可执行文件。 -g 选项表示我们要求编译器在编译的时候提供我们以后对程序进行调试的信息。<br>知道了这三个选项，我们就可以编译我们自己所写的简单的源程序了，如果你想要知道更多的选项，可以查看 gcc 的帮助文档，那里有着许多对其它选项的详细说明。</p>
<p>2.Makefile 的编写<br>假设我们有下面这样的一个程序，源代码如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* main.c */  </span><br><span class="line">#include &quot;mytool1.h&quot;  </span><br><span class="line">#include &quot;mytool2.h&quot;  </span><br><span class="line">int main(int argc，char **argv)  </span><br><span class="line">&#123;  </span><br><span class="line">    mytool1_print(&quot;hello&quot;)；  </span><br><span class="line">    mytool2_print(&quot;hello&quot;)；  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/* mytool1.h */  </span><br><span class="line">#ifndef _MYTOOL_1_H  </span><br><span class="line">#define _MYTOOL_1_H  </span><br><span class="line">void mytool1_print(char *print_str)；  </span><br><span class="line">#endif  </span><br><span class="line">/* mytool1.c */  </span><br><span class="line">#include &quot;mytool1.h&quot;  </span><br><span class="line">void mytool1_print(char *print_str)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;This is mytool1 print %s\n&quot;，print_str)；  </span><br><span class="line">&#125;  </span><br><span class="line">/* mytool2.h */  </span><br><span class="line">#ifndef _MYTOOL_2_H  </span><br><span class="line">#define _MYTOOL_2_H  </span><br><span class="line">void mytool2_print(char *print_str)；  </span><br><span class="line">#endif  </span><br><span class="line">/* mytool2.c */  </span><br><span class="line">#include &quot;mytool2.h&quot;  </span><br><span class="line">void mytool2_print(char *print_str)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;This is mytool2 print %s\n&quot;，print_str)；  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然由于这个程序是很短的我们可以这样来编译 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c main.c  </span><br><span class="line">gcc -c mytool1.c  </span><br><span class="line">gcc -c mytool2.c  </span><br><span class="line">gcc -o main main.o mytool1.o mytool2.o</span><br></pre></td></tr></table></figure>

<p>这样的话我们也可以产生 main 程序，而且也不时很麻烦。但是如果我们考虑一下如果有一天我们修改了其中的一个文件 (比如说 mytool1.c) 那么我们 难道还要重新输入上面的命令? 也许你会说，这个很容易解决啊，我写一个 SHELL 脚本，让她帮我去完成不就可以了。是的对于这个程序来说，是可以起到作用 的。但是当我们把事情想的更复杂一点，如果我们的程序有几百个源程序的时候，难道也要编译器重新一个一个的去编译?<br>为此，聪明的程序员们想出了一个很好的工具来做这件事情，这就是 make。我们只要执行以下 make，就可以把上面的问题解决掉。在我们执行 make 之 前，我们要先编写一个非常重要的文件。–Makefile。对于上面的那个程序来说，可能的一个 Makefile 的文件是：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main：main.o mytool1.o mytool2.o  </span><br><span class="line">gcc -o main main.o mytool1.o mytool2.o  </span><br><span class="line">main.o：main.c mytool1.h mytool2.h  </span><br><span class="line">gcc -c main.c  </span><br><span class="line">mytool1.o：mytool1.c mytool1.h  </span><br><span class="line">gcc -c mytool1.c  </span><br><span class="line">mytool2.o：mytool2.c mytool2.h  </span><br><span class="line">gcc -c mytool2.c</span><br></pre></td></tr></table></figure>

<p>有了这个 Makefile 文件，不过我们什么时候修改了源程序当中的什么文件，我们只要执行 make 命令，我们的编译器都只会去编译和我们修改的文件有关的文件，其它的文件她连理都不想去理的。<br>下面我们学习 Makefile 是如何编写的。<br>在 Makefile 中也 #开始的行都是注释行. Makefile 中最重要的是描述文件的依赖关系的说明。一般的格式是：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target：components  </span><br><span class="line">TAB rule</span><br></pre></td></tr></table></figure>

<p>第一行表示的是依赖关系。第二行是规则。<br>比如说我们上面的那个 Makefile 文件的第二行  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main：main.o mytool1.o mytool2.o</span><br></pre></td></tr></table></figure>
<p>表示我们的目标 (target)main 的依赖对象(components) 是 main.o mytool1.o mytool2.o 当倚赖的对象在目标修改后修改的话，就要去执行规则一行所指定的命令。就象我们的上面那个 Makefile 第三行所说的一样要执行 gcc -o main main.o mytool1.o mytool2.o 注意规则一行中的 TAB 表示那里是一个 TAB 键  </p>
<h3 id="变量-，-，"><a href="#变量-，-，" class="headerlink" title="变量 $@，$^，$&lt;"></a>变量 $@，$^，$&lt;</h3><p>Makefile 有三个非常有用的变量。分别是 $@，$^，$&lt; 代表的意义分别是：<br>$@– 目标文件，$^– 所有的依赖文件，$&lt;– 第一个依赖文件。<br>如果我们使用上面三个变量，那么我们可以简化我们的 Makefile 文件为：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这是简化后的 Makefile  </span><br><span class="line">main：main.o mytool1.o mytool2.o  </span><br><span class="line">gcc -o $@ $^  </span><br><span class="line">main.o：main.c mytool1.h mytool2.h  </span><br><span class="line">gcc -c $&lt;  </span><br><span class="line">mytool1.o：mytool1.c mytool1.h  </span><br><span class="line">gcc -c $&lt;  </span><br><span class="line">mytool2.o：mytool2.c mytool2.h  </span><br><span class="line">gcc -c $&lt;  </span><br></pre></td></tr></table></figure>

<p>经过简化后我们的 Makefile 是简单了一点，不过人们有时候还想简单一点。这里我们学习一个 Makefile 的缺省规则<br>.c.o：<br><code>gcc -c $&lt;</code><br>这个规则表示所有的 .o 文件都是依赖与相应的. c 文件的。例如 mytool.o 依赖于 mytool.c 这样 Makefile 还可以变为：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这是再一次简化后的 Makefile  </span><br><span class="line">main：main.o mytool1.o mytool2.o  </span><br><span class="line">gcc -o $@ $^  </span><br><span class="line">.c.o：  </span><br><span class="line">gcc -c $&lt;</span><br></pre></td></tr></table></figure>
<p>好了，我们的 Makefile 也差不多了，如果想知道更多的关于 Makefile 规则可以查看相应的文档。</p>
<h3 id="程序库的链接"><a href="#程序库的链接" class="headerlink" title="程序库的链接"></a>程序库的链接</h3><p>试着编译下面这个程序  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* temp.c */  </span><br><span class="line">#include  </span><br><span class="line">int main(int argc，char **argv)  </span><br><span class="line">&#123;  </span><br><span class="line">double value；  </span><br><span class="line">printf(&quot;Value：%f\n&quot;，value)；  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序相当简单，但是当我们用 gcc -o temp temp.c 编译时会出现下面所示的错误。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/tmp/cc33Kydu.o： In function `main&#x27;：  </span><br><span class="line">/tmp/cc33Kydu.o(.text+0xe)： undefined reference to `log&#x27;  </span><br><span class="line">collect2： ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<p>出现这个错误是因为编译器找不到 log 的具体实现。虽然我们包括了正确的头文件，但是我们在编译的时候还是要连接确定的库。在 Linux 下，为了使用数学 函数，我们必须和数学库连接，为此我们要加入 -lm 选项。 <code>gcc -o temp temp.c -lm</code> 这样才能够正确的编译。也许有人要问，前面我们用 printf 函数的时候怎么没有连接库呢? 是这样的，对于一些常用的函数的实现，gcc 编译器会自 动去连接一些常用库，这样我们就没有必要自己去指定了。有时候我们在编译程序的时候还要指定库的路径，这个时候我们要用到编译器的  -L 选项指定路径。比如说我们有一个库在 &#x2F;home&#x2F;hoyt&#x2F;mylib 下，这样我们编译的时候还要加上<code>-L/home/hoyt/mylib</code>对于一些标准库来说，我们没有必要指出路径。只要它们在起缺省库的路径下就可以了。系统的缺省库的路径<code>/lib /usr/lib /usr/local/lib </code>在这三个路径下面的库，我们可以不指定路径。</p>
<h3 id="程序的调试"><a href="#程序的调试" class="headerlink" title="程序的调试"></a>程序的调试</h3><p>我们编写的程序不太可能一次性就会成功的，在我们的程序当中，会出现许许多多我们想不到的错误，这个时候我们就要对我们的程序进行调试了。<br>最常用的调试软件是 gdb. 如果你想在图形界面下调试程序，那么你现在可以选择 xxgdb. 记得要在编译的时候加入 -g 选项. 关于 gdb 的使用可以看 gdb 的帮助文件。由于我没有用过这个软件，所以我也不能够说出如何使用。不过我不喜欢用 gdb. 跟踪一个程序是很烦的 事情，我一般用在程序当中输出中间变量的值来调试程序的。当然你可以选择自己的办法，没有必要去学别人的。现在有了许多 IDE 环境，里面已经自己带了调试 器了。你可以选择几个试一试找出自己喜欢的一个用。</p>
<h3 id="头文件和系统求助"><a href="#头文件和系统求助" class="headerlink" title="头文件和系统求助"></a>头文件和系统求助</h3><p>有时候我们只知道一个函数的大概形式，不记得确切的表达式，或者是不记得着函数在那个头文件进行了说明。这个时候我们可以求助系统。<br>比如说我们想知道 fread 这个函数的确切形式，我们只要执行 man fread 系统就会输出着函数的详细解释的。和这个函数所在的头文件说明了。 如果我们要 write 这个函数的说明，当我们执行 man write 时，输出的结果却不是我们所需要的。 因为我们要的是 write 这个函数的说明，可是出来的却是 write 这个命令的说明。为了得到 write 的函数说明我们要用 man 2 write. 2 表示我们用的 write 这个函数是系统调用函数，还有一个我们常用的是 3 表示函数是 C 的库函数。<br>记住不管什么时候，man 都是我们的最好助手</p>
<p><a href="https://so.csdn.net/so/search?q=Makefile&spm=1001.2101.3001.7020" title="Makefile">Makefile</a> 中<code> $(SRC:%.c=%.o)</code> 的含义：<strong>将 SRC 变量中所有以. c 结尾的文件名替换成对应的以. o 结尾的文件名，然后赋回给 SRC</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CROSS_COMPILE ?= arm-linux-gnueabihf-</span><br><span class="line"></span><br><span class="line">GCC := $(CROSS_COMPILE)gcc </span><br><span class="line"></span><br><span class="line">APP_TARGET = ./app_button</span><br><span class="line"></span><br><span class="line">INC_DIR = -I/  </span><br><span class="line">INC_DIR += -I./bsp/beep   </span><br><span class="line">INC_DIR += -I./bsp/clk   </span><br><span class="line">INC_DIR += -I./bsp/led  </span><br><span class="line">INC_DIR += -I./bsp/button </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">CFLAGS += $(INC_DIR)</span><br><span class="line"></span><br><span class="line">BEEP = \  </span><br><span class="line">    ./bsp/beep/beep.c \  </span><br><span class="line">    ./bsp/clk/clk.c \  </span><br><span class="line">    ./bsp/led/led.c \  </span><br><span class="line">    ./bsp/button/button.c</span><br><span class="line"></span><br><span class="line">MAIN = ./main.c</span><br><span class="line"></span><br><span class="line">SRC += $(MAIN)  </span><br><span class="line">SRC += $(BEEP)</span><br><span class="line"></span><br><span class="line">%.o:%.c  </span><br><span class="line">    $(GCC) -c $(CFLAGS) $^ -o $@</span><br><span class="line"></span><br><span class="line">SRCOBJ = $(SRC:.c=.o)</span><br><span class="line"></span><br><span class="line">all:$(APP_TARGET)  </span><br><span class="line">$(APP_TARGET): $(SRCOBJ)  </span><br><span class="line">    $(GCC) $(SRCOBJ) $(CFLAGS) -o $(APP_TARGET)</span><br><span class="line"></span><br><span class="line">clean:  </span><br><span class="line">    rm -f $(APP_TARGET) $(SRCOBJ)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>makefile make</tag>
      </tags>
  </entry>
  <entry>
    <title>mifi</title>
    <url>/2024/04/22/mifi/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>EC200D is UIS8310</strong><br><strong>EC200A is ASR1803S</strong></p>
<p>淘宝上出现很多基于物联网卡的随身wifi，大多数硬件几块钱包邮，然后套餐收割。硬件分为USB之差棒子和带电池的移款，LTE Cat.4的大多数基于ASR的asr1803 (A7)主控搭配25vq64 flash, 也有ZXW的zx297520v3(A53 wifi6)主控搭配25vq64 flash，前期还有高通410的。低配版的都支持LTE 4G, 上下行20~30Mbs左右。这其实就是蜂窝网络模块的一种使用，这个意义上看，模块既像一台没有屏幕和电池的手机，又像一种功能较为复杂的单片机。<br>又拆了一堆杂牌的，都是ASR1803 + 25Q64,只有迅优的棒子部分有点用， ASR1803S + 25Q64，而且由留出tx rx， 更换25q128，应该可以刷移远的<a href="https://www.bilibili.com/video/BV1ZG411y7B5/?vd_source=326f1996f8a76cd36e955fb621b271ba">quecPython</a>,移远的AT固件需要提供购买证明FAE才给。</p>
<ul>
<li>ASR1803S + 25Q64 &#x3D; EC200ACHLE&#x2F;F</li>
<li>ASR1803S + 25Q128 &#x3D; EC200ACHLA</li>
</ul>
<p>新出的聚火的的棒子很惊喜，采用三天线，展锐UIS8310AM + 25N512GWE1R, 还带卡槽.<br><img src="https://img-blog.csdnimg.cn/bc0712fa1ad647ce865cbc197859d422.jpeg#pic_leftcenter" alt="UIS8310 系统框图"></p>
<span id="more"></span>
<p>软件上中兴微的板子，好像有adb,也能刷固件，<del>不过迅优的好像有强控，识别IMEI和iccid</del>，不符合就显示卡无效(刷固件后读卡失败，多为卡槽虚焊，读卡失败)。ASR的板子只能通过AT指令来修改IMEI达到去控的目的，部分厂家的修改失败。展锐的刷机方案网上找不到很多，可以在酷安 搜索相关型号。</p>
<p>想要使用自己的卡，有些板子硬件上还需要焊接卡槽，甚至一些短接或者飞线才可以，大多数都可以使用2元的防风打火机来拆掉ESIM,古法热风枪。</p>
<p>刷机过程中如果变砖了，可能要拆屏蔽罩，用CH34A刷SPI FLASH, 非常麻烦。</p>
<h3 id="设备的-IMEI"><a href="#设备的-IMEI" class="headerlink" title="设备的 IMEI"></a>设备的 IMEI</h3><p>快速使用ASR1803s设备，打开<a href="https://python.quectel.com/download">QuecPython官网下载链接</a>, 安装驱动 Win10 QuecPython_USB_Driver_Win10_A, 打开串口助手，波特率 9600，8 N 1, 可以AT命令交互。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入工厂模式 AT*PROD=1</span><br><span class="line">删除原IMEI AT*MRD_IMEI=D</span><br><span class="line">写⼊新的IMEI，把第四个参数修改为新的IMEI就可以了 AT*MRD_IMEI=W,0,01JAN1970,000000000000000</span><br><span class="line">删除原SN AT*MRD_SN=D</span><br><span class="line">写⼊新的SN，把第四个参数修改为新的SN就可以了 AT*MRD_SN=W,0,01JAN1970,000000000000000</span><br><span class="line">退出工厂模式 AT*PROD=0</span><br><span class="line">最后重启 AT+RESET</span><br></pre></td></tr></table></figure>
<p>如上所示，获取设备的 IMEI 号虽然十分简单，但是又特别的常用，所以在这里介绍一下如何查询。那么，IMEI 是什么呢？</p>
<p>物联网模块的 IMEI 是国际移动设备身份码（International Mobile Equipment Identity）的缩写，它是用于识别物联网模块的唯一标识符。在物联网场景中，IMEI 可以用于以下几个方面：</p>
<p>设备识别和管理：通过 IMEI，可以唯一地识别和管理物联网设备，包括设备的制造商、型号和版本等信息。这些信息对于设备的维护和升级非常重要。<br>安全性和防盗：IMEI 可以用于防止设备被盗或丢失。如果设备的 IMEI 被注册到一个中央数据库中，就可以通过该数据库来追踪设备的位置和使用情况。<br>远程管理和控制：IMEI 可以用于远程管理和控制物联网设备。例如，如果设备出现故障或需要更新固件，就可以通过 IMEI 来远程诊断和修复设备。<br>数据统计和分析：IMEI 可以用于统计和分析物联网设备的使用情况。例如，可以根据 IMEI 来确定设备的使用时间、位置、频率和使用模式等信息，以便更好地了解设备的使用情况和优化设备的性能。<br>总之，IMEI 是物联网设备非常重要的标识符，可以用于设备管理、安全性、远程管理和数据分析等方面。</p>
<p>使用 modem 库查询其他设备信息不再赘述，请查看 modem - 设备相关。</p>
<h3 id="蜂窝网络的概念"><a href="#蜂窝网络的概念" class="headerlink" title="蜂窝网络的概念"></a>蜂窝网络的概念</h3><p>蜂窝网络（Cellular Network，又称移动网络 Mobile Network）是一种无线通信技术，它能够让移动设备（如手机、平板电脑等）在不同的地理区域内进行语音、数据和多媒体等业务的传输。蜂窝网络是现代移动电话和个人通信系统的基础架构之一，也是推动社会信息化进程的重要力量。</p>
<p><img src="https://python.quectel.com/doc/Application_guide/zh/media/background/wireless-modules/cellular-network-architecture.png"></p>
<p>5G 毫米波蜂窝网络结构示意图</p>
<p>如上图所示，蜂窝网络的核心思想是将一个大的服务区域划分为许多个小区（Cell），每个小区内部安装一个基站（Base Station），负责与小区内的移动设备进行无线通信。这些基站之间通过有线或无线的方式连接起来，形成一个覆盖整个服务区域的网络。在传统理论中，这些小区被设计为六边形、圆形或正方形，以六边形最为常见。小区之间彼此连接，实现区域的完整覆盖，形如蜂巢，这也是该项技术被译为蜂窝网络的原因。如今，在实际场景中，很多基站的覆盖区域已经不再是蜂窝形状，但这个称谓依旧流传了下来。</p>
<p><img src="https://python.quectel.com/doc/Application_guide/zh/media/background/wireless-modules/5g-evolution.png"></p>
<p>从 1G 到 5G 的演进</p>
<p>从 1G 到 5G</p>
<p>蜂窝网络最早由美国贝尔实验室在 1947 年提出，并在 1979 年在日本首次商用。最初的蜂窝网络只能提供模拟语音电话业务，被称为第一代（The 1st Generation，1G）移动通信系统。1G 移动通信系统采用频分多址接入（Frequency Division Multiple Access，FDMA）技术，将不同用户分配到不同频率的信道上。1G 移动通信系统虽然开创了移动通信的时代，但也存在很多缺点，如频谱利用率低、业务种类有限、无高速数据业务、保密性差以及设备成本高等。</p>
<p>为了解决模拟系统中存在的问题，在 20 世纪 90 年代初，第二代（The 2nd Generation，2G）移动通信系统即数字移动通信技术出现了。2G 移动通信系统采用数字调制技术，并使用时分多址接入（Time Division Multiple Access，TDMA）或者码分多址接入（Code Division Multiple Access，CDMA）技术。2G 移动通信系统相比 1G 系统有了很大的改进，如系统容量、保密性和语音通话质量都大幅提升，并且开始提供数据业务。2G 移动通信系统最具代表性的是欧洲的全球移动通信系统（Global System for Mobile Communication，GSM），它使得全球范围内的漫游成为可能，并成为世界上最广泛使用的标准之一。</p>
<p>随着互联网的发展，人们对数据业务的需求也越来越高。为了提高数据传输速率，在 2G 系统的基础上又出现了一些增强技术，如通用分组无线服务（General Packet Radio Service，GPRS）、增强型数据速率 GMS 演进（Enhanced Data for GSM Evolution，EDGE）等。这些技术被称为 2.5G 或 2.75G，它们在 2G 系统的基础上提供了更高的数据传输速率，但仍然不能满足人们对高速宽带数据业务的需求。</p>
<p>2001 年，以数字多媒体移动通信为目的的第三代（The 3rd Generation，3G）移动通信系统进入商用阶段。3G 移动通信系统采用更先进的宽带码分多址技术（Wideband Code Division Multiple Access，WCDMA），并在更高频段使用更大的系统带宽进行数据发送，因而其数据传输速率得到进一步提升。3G 移动通信系统可以同时传输语音和数据信息，支持图像、音乐、视频等多媒体业务。3G 移动通信系统的主要代表有北美的 CDMA2000、欧洲和日本的 WCDMA、中国的时分同步的码分多址技术（Time Division-Synchronization Code Division Multiple Access，TD-SCDMA）等。这些技术都是基于国际电信联盟（International Telecommunication Union，ITU）制定的国际标准 IMT-2000（International Mobile Telecommunications 2000）。</p>
<p>随着 3G 网络的发展，出现了一些增强技术，如高速下行分组接入（High Speed Downlink Packet Access，HSDPA）、高速上行分组接入（High Speed Uplink Packet Access，HSUPA）和增强型高速分组接入 (High-Speed Packet Access+，HSPA+) 等。这些技术被称为 3.5G 或 3.75G，它们在 3G 系统的基础上提供了更高的数据传输速率和更好的用户体验。</p>
<p>2011 年，以数字宽带数据移动互联网通信为目的的第四代（The 4th Generation，4G）移动通信系统正式发布。4G 移动通信系统基于扁平化网络架构设计，在 3G 的长期演进（Long Term Evolution，LTE）基础上进行升级。LTE 系统采用正交频分多址（Orthogonal Frequency-Division Multiple Access，OFDMA）、自适应调制编码（Adaptive Modulation and Coding，AMC）和多天线（Multiple-input Multiple-output，MIMO）等关键技术，大大提高了频谱效率和网络性能。4G 移动通信系统拥有非常高的数据传输速度，是 3G 网络的 50 倍以上，其视频图像的传输效果与高清电视相当。4G 移动通信系统最具代表性的是以时分双工（Time Division Duplexing）&#x2F; 频分双工（Frequency Division Duplexing，FDD）为工作模式的高级长期演进技术（Long Term Evolution Advanced，LTE-A）技术。LTE-A 技术在 LTE 技术的基础上采用了载波聚合（Carrier Aggregation，CA）、中继和多点协同传输（Coordinated Multiple Point，CoMP）等技术，在提高网络容量和覆盖范围方面有了突破性进展。</p>
<p>随着智能终端、物联网、云计算等新兴技术和应用的快速发展，人们对移动通信的需求也越来越高。为了满足未来人类信息社会的需求，第五代（The 5th Generation，5G）移动通信系统应运而生。5G 移动通信系统不仅提供了更高的数据传输速率、更低的时延和更高的可靠性，还支持海量的连接和多样化的业务场景。当前，5G 移动通信系统已渗透到工业、医疗、交通等领域，与各种设备和物体深度融合，实现万物互联，为社会经济发展和人类生活质量提供强大的支撑。</p>
<p>蜂窝网络作为一种无线通信技术，从诞生至今已经经历了五代的发展，每一代都对应着不同的技术和标准，为用户提供了更高的数据传输速度，更好的语音通话质量，以及一系列新特性和新功能。从 1G 的模拟语音通信，到 5G 的全场景互联，蜂窝网络已经成为现代社会运转的必不可少的信息基础设施之一。</p>
<h3 id="无线通信模块"><a href="#无线通信模块" class="headerlink" title="无线通信模块"></a>无线通信模块</h3><p>无线通信模块，简称模块（Module，亦称模组或单元），是实现数据上云和远程通信的必不可少的组件，在各类物联网场景中已经得到了极为广泛的应用。从功能上看，它是在本地设备和网络之间构建连接的桥梁。像电脑插上 USB 网卡就可以开始上网一样，在嵌入式系统中加入了模块，系统就具有了连接无线网络的可能性。</p>
<p><img src="https://python.quectel.com/doc/Application_guide/zh/media/background/wireless-modules/device-with-ec20.png"></p>
<p>搭载移远 EC20 模块的某物联网产品主板</p>
<p>很多初次接触模块的用户会对模块这样一个被金属壳笼罩着的奇怪器件感到陌生，它与传统的芯片和分立器件存在很大的不同。实际上，模块的本质就是一种小型的 PCBA（Printed Circuit Board Assembly，组装电路板）。当我们去掉模块表面的金属屏蔽罩，其内部依旧是熟悉（但更为密集）的 PCB 电路结构。</p>
<p><img src="https://python.quectel.com/doc/Application_guide/zh/media/background/wireless-modules/ec20-naked-top.png"></p>
<p>某 4G 模块的内部图像</p>
<p>有过嵌入式系统开发经验的用户对于 “核心板” 或者 SoM（System on Module）应该不会陌生。模块同样可理解为一种将无线通信所需的各类器件集成在一起，用于完成本地电路与云端服务的通信功能的高密度、小体积、带屏蔽罩的“核心板”。在本文开头的关于通信的介绍中，我们讲到了编码（解码）和调制（解调）的概念。在无线通信，尤其是蜂窝通信中，这些步骤往往会演变和拓展得极为复杂。模块的作用即是帮助我们完成这些复杂的步骤，实现简单高效的通信。</p>
<p>模块的内部结构较为复杂。如下图所示，可以看到包含主芯片（高通 MDM9607）、存储器、电源管理芯片、功率放大器、射频前端等多种集成器件，以及大量密集分布的小尺寸封装的电阻、电容等元件。显然，模块的复杂度和精密度是远超传统电路板的。</p>
<p><img src="https://python.quectel.com/doc/Application_guide/zh/media/background/wireless-modules/ec20-inner-components.png"></p>
<p>EC20 Mini PCIe 模块的元件组成</p>
<p>主芯片（Main Chip），部分厂家称之为基带（Baseband）芯片或调制解调器（Modem）芯片，是整个模块的核心。它的角色、功能和特性与手机中的 SoC（System on Chip，片上系统）十分相似。随着技术的发展和芯片制造工艺的提升，在现代模块中，主芯片通常已经集成了应用处理器（Application Processor，AP）、基带和射频的相关功能，运行着完备的操作系统（RTOS 或 Linux），对外提供包括 GPIO、USB 等在内的各种接口，并能够根据需求完成各类通信操作。从这个意义上看，模块既像一台没有屏幕和电池的手机，又像一种功能较为复杂的单片机。</p>
<p><img src="https://python.quectel.com/doc/Application_guide/zh/media/background/wireless-modules/qcx216-diagram.png"></p>
<blockquote>
<p>高通最新的 QCX216 4G Modem 芯片功能框图</p>
</blockquote>
<p>对于同一台 Android 手机，不同人有不同的用法。一些用户会安分地使用出厂自带的系统和功能，另一些则热衷于解锁、刷机、root 等操作，更进一步地去开发和挖掘设备的潜力。和手机类似，模块也有这样的两类应用模式：标准模式和二次开发模式。</p>
<h3 id="标准模式"><a href="#标准模式" class="headerlink" title="标准模式"></a>标准模式</h3><blockquote>
<p>类比 ESP32 的AT固件<br>和普通手机一样，模块在出厂时通常都会内置操作系统和应用程序。对于许多用户来说，直接使用模块出厂预置功能就可以满足大部分的网络通信需求。这种无需对模块进行开发和调整，直接作为成品功能单元进行使用的方式称为标准模式或传统模式，是当前应用最普遍的模块使用方式。</p>
</blockquote>
<p><img src="https://python.quectel.com/doc/Application_guide/zh/media/background/wireless-modules/standard-mode-module.png"></p>
<p>标准模式示意图</p>
<p>如上图所示，在标准模式中，模块与主控（MCU，如 STM32）之间通过 UART 或 USB 接口相连接，基于 AT 指令进行双向交互。不难看出，MCU 是整套系统的核心，通信模块是作为 MCU 的一个独立的功能外设的角色而存在的。系统的主要业务逻辑（用户应用，App）在 MCU 中运行，其他外设（图中的 External Devices）通过 UART、I2C 等接口与 MCU 相连，受 MCU 控制。</p>
<p>关于 AT 指令</p>
<p>AT 指令是目前业界历史最悠久，使用领域最广泛的通讯指令集之一。它构建起了一套用户和模块间的完备的双向通信机制：用户（或 MCU）通过向模块发送 AT 指令，控制模块执行包括联网、通话、定位等在内的各类功能，模块则将执行结果和状态返回给用户。这种 “一发一收” 的机制和相对单一的处理方式非常适合在资源有限的嵌入式环境中使用。如今，市面上的绝大多数模块在出厂时都内置了 AT Server 程序，可以接收、解析和执行特定的 AT 指令。</p>
<p><img src="https://python.quectel.com/doc/Application_guide/zh/media/background/wireless-modules/at-command-architecture.png"></p>
<p>AT 指令的运行模式</p>
<p>对于开发者而言，在基于标准模式使用模块时，主要的开发工作量在于主控中运行的用户 App。其业务代码中需要包含较为复杂的 AT 指令发送和返回值解析功能，例如对 URC（Unsolicited Result Code，非请求结果码）的处理等，因而对于初学者难度较大。</p>
<p>除了 AT 指令功能，模块在标准模式下还可以作为无线网卡，为主控或其他上位机提供包括 PPP 拨号上网在内的一系列网络服务，此处不做赘述。</p>
<h3 id="二次开发模式"><a href="#二次开发模式" class="headerlink" title="二次开发模式"></a>二次开发模式</h3><blockquote>
<p>类比使用 ESP-IDF 开发 ESP32<br>在前文中我们曾提到，模块就像是功能较为复杂的单片机。事实上，模块所搭载的主芯片为了满足无线通信的需要，通常具有较高的性能和较多的资源，同时也配备了包括 GPIO、ADC、I2C 等在内的丰富的外设接口，只不过在标准模式下，这些资源对于用户通常不是直接可用的。如果能够 “解锁” 这一限制，模块的应用潜力将极大提升，这就需要对模块进行二次开发。</p>
</blockquote>
<p>二次开发的本意是在软件本身提供的一些基本功能和接口的基础上，进行组合和扩展，开发出新的功能来满足用户的特殊需求。具体到模块开发上，二次开发模式允许开发者在底层操作系统的基础上调用 API 编写并运行自己的应用，充分调用模块的各种资源，实现更多的可能性。</p>
<p><img src="https://python.quectel.com/doc/Application_guide/zh/media/background/wireless-modules/open-mode-module.png"></p>
<p>二次开发模式示意图</p>
<p>二次开发最重要的意义在于使模块在一定程度上具备了取代标准模式中的主控的能力，因而这种模式又被称为 OpenCPU 或 OpenMCU（不同厂家可能有不同的专门称呼，如移远称之为 QuecOpen）。如上图所示，与标准模式相比，OpenCPU 模式由于将模块本身作为主控使用，用户应用（App）直接置于模块内部运行，外设（图中的 External Devices）与模块直接相连，整个系统中无需外部处理器（MCU）或只需简单的外部芯片（图中的 Simple Microchip），因而可以有效地达到精简硬件设计、降低器件成本、缩小产品尺寸的目的。在单片机价格居高不下的当下，OpenCPU 方案受到了众多公司的青睐。</p>
<p>但是，OpenCPU 方案也具有较为明显的局限性。由于这一模式通常需要用户直接在模块底层运行的操作系统的基础上进行开发，技术门槛较高，传统的、不具备系统级开发经验的单片机开发者很难适应。其次，由于 OpenCPU 技术支持难度大，模块厂家通常只向大客户提供相关的工具和资料，入门较为不便。最后，不同厂家、不同型号的模块，其 OpenCPU 开发环境和开发工具存在较大差别，用户编写的程序在不同模块间的移植存在一定的难度。</p>
<h3 id="使用脚本语言开发模块"><a href="#使用脚本语言开发模块" class="headerlink" title="使用脚本语言开发模块"></a>使用脚本语言开发模块</h3><blockquote>
<p>类比 ESP32的 micropython 开发<br>传统的 OpenCPU 开发通常使用 C 语言，因此也被称作 CSDK 开发。用户需要直接修改和控制底层的操作系统，具有较高的难度和一定的风险性。在 <a href="https://python.quectel.com/doc/Application_guide/zh/background/iot-and-low-code.html">前文</a> 中，我们介绍了低代码开发方式和它在物联网领域的应用。目前，已经有部分模块厂商通过在 CSDK 的基础上移植解释器 &#x2F; 虚拟机的方式，使得用户可以使用 Lua、Python 等脚本语言对模块进行二次开发。</p>
</blockquote>
<p>与 C 语言相比，脚本语言在语法和使用方式上普遍较为简单，开发者无需花费太多时间和精力即可掌握，并可相对轻松地实现业务逻辑，便于项目的快速开发和功能迭代。同时，对于低代码开发方式而言，开发者通常无需考虑内存回收、基础任务调度等底层细节，显著降低了模块二次开发的技术门槛。最后，对于不同型号的模块，只要它们运行的是同一种脚本语言解释器，用户编写的程序通常只需少量修改（甚至无需修改）即可完成移植。</p>
<p>如下的示例分别是在 EC100Y-CN 模块上使用 C 语言和 Python 语言实现 LED 闪灯的代码。可以看出，脚本语言更加简单直观，易于编写、便于理解。</p>
<p>LED 闪灯代码</p>
<p>使用 QuecOpen（CSDK） 使用 QuecPython</p>
<p>当然，由于使用脚本语言开发时屏蔽了很多底层细节，因而在灵活性和可控性上不如传统的 C 语言开发。此外，脚本语言与 C 语言相比，本身性能相对较差、执行速度较慢，因而在部分对于性能和实时性要求较高的场景下不适合使用。</p>
<h3 id="刷-MIFI"><a href="#刷-MIFI" class="headerlink" title="刷 MIFI"></a>刷 MIFI</h3><p>既然随身wifi (MIFI)<br>EC200A 的固件升级从Quectel 拿到的默认的升级的压缩包不能直接用户升级</p>
<p>F:\temp\EC200ACNDAR01A07M16&gt;FBFMake.exe -r Falcon_EVB_QSPI_Nor_LWG_Only_Nontrusted_PM802_LPDDR2.blf -f out</p>
<p>BinFile.bin 是烧录的目标文件，可以用QDLoader 工具烧录</p>
<h3 id="手机修改IMEI-使用绑定IMEI的eSIM流量卡、物流卡"><a href="#手机修改IMEI-使用绑定IMEI的eSIM流量卡、物流卡" class="headerlink" title="手机修改IMEI 使用绑定IMEI的eSIM流量卡、物流卡"></a>手机修改IMEI 使用绑定IMEI的eSIM流量卡、物流卡</h3>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>asr1803s python</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 应用开发</title>
    <url>/2024/04/02/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="VScode-Clangd"><a href="#VScode-Clangd" class="headerlink" title="VScode Clangd"></a>VScode Clangd</h3><p><a href="https://clangd.llvm.org/">Clangd</a> 是一个基于 Clang 的语言服务器，它提供了代码智能感知和导航功能。通过与 VSCode 集成。</p>
<ol>
<li><p>搜索 clangd 插件安装</p>
</li>
<li><p>禁用或卸载 Microsoft C&#x2F;C++ Intelligence</p>
</li>
<li><p>VSCode clangd 插件本身是不能运行的，它还需要 clangd 的环境，所以接下来安装 clangd。<br>在 Ubuntu 中最好不要使用 apt 安装，因为版本比较旧，建议下载后手动安装。<br>解压后，<br>将 bin 文件夹下的 clangd 移动到 &#x2F;usr&#x2F;bin 目录下，<br>将 lib 文件夹下的所有移动到 &#x2F;usr&#x2F;local&#x2F;lib 目录下。<br><code>clangd --version</code>查看版本。</p>
<span id="more"></span>
</li>
<li><p>使用 bear 构建源码的 compile_commands.json 文件,clangd需要这个文件才能提供补全和跳转，compile_commands.json 文件记录了你的工程是如何构建的，使用到了哪些源码文件，源码文件之间的包含关系，引用路径之类的，这些可以帮助 clangd 构建符号关系索引库。<br><code>sudo apt install bear</code> 安装 bear </p>
</li>
<li><p>修改 compile_commands.json 文件<br>需要全局替换：”cc”  –&gt;  “arm-linux-gnueabihf-gcc”<br>保存后关闭 VSCode，如果有. cache 文件夹的话，删除掉它。之后重新用 VSCode 打开源码目录，随便打开一个. c 文件，clangd 便自动开始索引文件了，索引文件会保存在 .cache 目录下。</p>
</li>
<li><p>驱动程序和应用程序的编写<br>对于驱动程序来说，我的方法是在当前源码目录下新建一个文件夹，在这个文件夹下进行驱动程序的编写，这样跳转、补全之类的都比较方便。<br>然后保存工作区，方便下次打开：<br>对应用程序来说，不便放在源码工作区当中，可以像这样单独打开一个用于编写应用程序：<br>驱动程序写完后，拷贝到应用程序所在目录的驱动程序文件中。</p>
</li>
</ol>
<h3 id="安装-NFS"><a href="#安装-NFS" class="headerlink" title="安装 NFS"></a>安装 NFS</h3><h4 id="在Ubuntu上设置NFS服务器的步骤如下："><a href="#在Ubuntu上设置NFS服务器的步骤如下：" class="headerlink" title="在Ubuntu上设置NFS服务器的步骤如下："></a>在Ubuntu上设置NFS服务器的步骤如下：</h4><ol>
<li><p>安装NFS内核服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nfs-kernel-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建共享目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /srv/nfs/share</span><br><span class="line">sudo chown nobody:nogroup /srv/nfs/share</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置共享权限。编辑 &#x2F;etc&#x2F;exports 文件，并添加共享目录配置：<code>sudo nano /etc/exports</code></p>
</li>
</ol>
<p>添加以下行：<code>/srv/nfs/share 192.168.1.0/24(rw,sync,no_subtree_check)</code></p>
<ol start="4">
<li>启动 NFS服务<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start nfs-kernel-server</span><br><span class="line">sudo systemctl enable nfs-kernel-server</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="在客户端计算机上，您需要安装NFS通用文件系统客户端："><a href="#在客户端计算机上，您需要安装NFS通用文件系统客户端：" class="headerlink" title="在客户端计算机上，您需要安装NFS通用文件系统客户端："></a>在客户端计算机上，您需要安装NFS通用文件系统客户端：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nfs-common</span><br></pre></td></tr></table></figure>
<p>然后，您可以挂载服务器上的共享目录：<br><code>sudo mount -t nfs 192.168.1.x:/srv/nfs/share /mnt</code></p>
<h4 id="windows-挂载linux-NFS"><a href="#windows-挂载linux-NFS" class="headerlink" title="windows 挂载linux NFS"></a>windows 挂载linux NFS</h4><p>在Windows上挂载Linux NFS共享，你需要确保已经在Linux服务器上配置了NFS共享，并且Windows客户端已安装NFS客户端功能。以下是如何在Windows上挂载Linux NFS共享的步骤：</p>
<p>安装NFS客户端功能：</p>
<p>打开“控制面板” -&gt; “程序和功能” -&gt; “启用或关闭Windows功能”，勾选“NFS客户端”，然后点击“确定”安装。</p>
<p>使用命令行挂载NFS共享：</p>
<p>打开命令提示符或PowerShell，使用mount命令挂载Linux NFS共享。</p>
<p>例如，如果你的Linux NFS服务器IP是192.168.1.100，NFS共享路径是&#x2F;shared，你想将其挂载到本地的Z:驱动器，可以使用以下命令：</p>
<p><code>mount \\192.168.1.100\shared Z:</code><br>如果你想在每次启动时自动挂载该共享，可以在mount命令后添加-p参数，并将命令添加到autocmd.bat文件中，该文件位于C:\Windows\System32\目录下。</p>
<p>注意：确保你的Windows防火墙设置允许NFS通信。如果你的NFS服务器配置了访问控制，你可能需要提供用户名和密码。</p>
<h3 id="gcc-命令"><a href="#gcc-命令" class="headerlink" title="gcc 命令"></a>gcc 命令</h3><p> GCC 常用编译选项<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-E 预处理，开发过程中想快速确定某个宏可以使用“-E -dM”</span><br><span class="line">-c 把预处理、编译、汇编都做了，但是不链接</span><br><span class="line">-o 指定输出文件</span><br><span class="line">-I 指定头文件目录</span><br><span class="line">-L 指定链接时库文件目录</span><br><span class="line">-l 指定链接哪一个库文件</span><br></pre></td></tr></table></figure><br>常用 <code>gcc -o hello hello.c</code></p>
<h3 id="Makefine"><a href="#Makefine" class="headerlink" title="Makefine"></a>Makefine</h3><h4 id="Make-fine-原理"><a href="#Make-fine-原理" class="headerlink" title="Make fine 原理"></a>Make fine 原理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c -o a.o a.c</span><br><span class="line">gcc -c -o b.o b.c</span><br><span class="line">gcc -o test a.o b.o</span><br><span class="line">gcc -c -o c.o c.c -MD -MF c.d</span><br></pre></td></tr></table></figure>
<p>gcc 生成依赖 c.d<br>如何判断哪些文件被修改，只编译被修改的文件，比较时间：目标文件和依赖文件的时间，当依赖比目标新时，执行编译文件。</p>
<p>目标:依赖<br>[TAB]命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test:a.o b.o</span><br><span class="line">    gcc -o test a.o b.o</span><br><span class="line"></span><br><span class="line">a.o : a.c</span><br><span class="line">    gcc -o a.o a.c</span><br><span class="line"></span><br><span class="line">b.o : b.c</span><br><span class="line">    gcc -o b.o b.c</span><br></pre></td></tr></table></figure>
<h4 id="Makefile语法"><a href="#Makefile语法" class="headerlink" title="Makefile语法"></a>Makefile语法</h4><p>% 通配符 %.o<br>$@ 目标<br>$&lt; 第一个依赖文件<br>$^ 所有依赖文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test:a.o b.o</span><br><span class="line">    gcc -o test $^</span><br><span class="line">%.o : %.c</span><br><span class="line">gcc -c -o $@ $&lt;</span><br></pre></td></tr></table></figure>

<p>make 无目标，默认第一个为目标<br>使用下面的语句把“clean”设置为假想目标：<br><code>.PHONY : clean</code></p>
<p>即时变量、延时变量，export</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = xxx // 延时变量</span><br><span class="line">B ?= xxx // 延时变量，只有第一次定义时赋值才成功；如果曾定义过，此赋值无效</span><br><span class="line">C := xxx // 立即变量</span><br><span class="line">D += yyy // 如果 D 在前面是延时变量，那么现在它还是延时变量；</span><br><span class="line">D += dir/ dir 是一个目录</span><br><span class="line">// 如果 D 在前面是立即变量，那么现在它还是立即变量</span><br></pre></td></tr></table></figure>
<p>@echo 看不到变量<br>@echo $(A)</p>
<h5 id="makefile-函数"><a href="#makefile-函数" class="headerlink" title="makefile 函数"></a>makefile 函数</h5><p><code>$(foreach var,list,text)</code><br>简单地说，就是 for each var in list, change it to text。对 list 中的每一个<br>元素，取出来赋给 var，然后把 var 改为 text 所描述的形式。<br>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objs := a.o b.o</span><br><span class="line">dep_files := $(foreach f, $(objs), .$(f).d) // 最终 dep_files := .a.o.d .b.o.d</span><br></pre></td></tr></table></figure>
<p><code>$(wildcard pattern)</code><br>pattern 所列出的文件是否存在，把存在的文件都列出来。<br>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src_files := $( wildcard *.c) // 最终 src_files 中列出了当前目录下的所有.c 文件</span><br></pre></td></tr></table></figure>

<p><code>$(filter pattern...,text)</code><br>把 text 中符合 pattern 格式的内容，filter(过滤)出来、留下来。<br>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-y := a.o b.o c/ d/</span><br><span class="line">DIR := $(filter %/, $(obj-y)) //结果为：c/ d/</span><br></pre></td></tr></table></figure>

<p><code>$(filter-out pattern...,text)</code><br>把 text 中符合 pattern 格式的内容，filter-out(过滤)出来、扔掉。<br>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-y := a.o b.o c/ d/</span><br><span class="line">DIR := $(filter-out %/, $(obj-y)) //结果为：a.o b.o</span><br></pre></td></tr></table></figure>

<p><code>$(patsubst pattern,replacement,text)</code><br>寻找text中符合格式pattern的字，用replacement替换它们。<br>pattern和replacement中可以使用通配符。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subdir-y := c/ d/</span><br><span class="line">subdir-y := $(patsubst %/, %, $(subdir-y)) // 结果为：c d</span><br></pre></td></tr></table></figure>
<p>EXTRA_CFLAGS :&#x3D; -D DEBUG 打开宏</p>
<h4 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h4><p>Linux 内核编译通常使用 make 工具，而不是 cmake。cmake 是用于跨平台构建系统的工具，但 Linux 内核不是为跨平台设计的，而是直接使用 make 工具来构建。</p>
<h4 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h4><p>linux&#x2F;unix 系统开发</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux_app</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2022/05/02/mysql/</url>
    <content><![CDATA[<h3 id="MySQL-简介"><a href="#MySQL-简介" class="headerlink" title="MySQL 简介"></a>MySQL 简介</h3><p>MySQL 最早是由瑞典的 MySQL AB 公司开发的一个开放源码的关系数据库管理系统，该公司于2008年被昇阳微系统公司（Sun Microsystems）收购。在2009年，甲骨文公司（Oracle）收购昇阳微系统公司，因此 MySQL 目前也是 Oracle 旗下产品。</p>
<p>MySQL 在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用于中小型网站开发。随着 MySQL 的不断成熟，它也逐渐被应用于更多大规模网站和应用，比如维基百科、谷歌（Google）、脸书（Facebook）、淘宝网等网站都使用了 MySQL 来提供数据持久化服务。</p>
<p>甲骨文公司收购后昇阳微系统公司，大幅调涨 MySQL 商业版的售价，且甲骨文公司不再支持另一个自由软件项目 <a href="https://zh.wikipedia.org/wiki/OpenSolaris">OpenSolaris </a> 的发展，因此导致自由软件社区对于 Oracle 是否还会持续支持 MySQL 社区版（MySQL 的各个发行版本中唯一免费的版本）有所担忧，MySQL 的创始人麦克尔·维德纽斯以 MySQL 为基础，创建了 <a href="https://zh.wikipedia.org/wiki/MariaDB">MariaDB</a>（以他女儿的名字命名的数据库）分支。有许多原来使用 MySQL 数据库的公司（例如：维基百科）已经陆续完成了从 MySQL 数据库到 MariaDB 数据库的迁移。</p>
<span id="more"></span>

<h4 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h4><p>方法一应用华为镜像包解压：参考linuxdeploy<br>方法二使用官网rpm源：<br>   可以在 <a href="https://www.mysql.com/">MySQL 官方网站</a>下载安装文件。首先在下载页面中选择平台和版本，然后找到对应的下载链接，直接下载包含所有安装文件的归档文件，解归档之后通过包管理工具进行安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://downloads.mysql.com/archives/get/p/23/file/mysql-xxx.rpm-bundle.tar</span><br><span class="line">tar -xvf mysql-xxx.rpm-bundle.tar</span><br></pre></td></tr></table></figure>
<p>   如果系统上有 MariaDB 相关的文件，需要先移除 MariaDB 相关的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list installed | grep mariadb | awk &#x27;&#123;print $1&#125;&#x27; | xargs yum erase -y</span><br></pre></td></tr></table></figure>

<p>更新和安装可能用到的底层依赖库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum update</span><br><span class="line">yum install -y libaio libaio-devel</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">接下来可以按照如下所示的顺序用 RPM（Redhat Package Manager）工具安装 MySQL。</span><br><span class="line"></span><br><span class="line">```Shell</span><br><span class="line">rpm -ivh mysql-community-common-xxx.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-xxx.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-compat-xxx.rpm</span><br><span class="line">rpm -ivh mysql-community-devel-xxx.rpm</span><br><span class="line">rpm -ivh mysql-community-client-xxx.rpm</span><br><span class="line">rpm -ivh mysql-community-server-xxx.rpm</span><br></pre></td></tr></table></figure>
<p>可以使用下面的命令查看已经安装的 MySQL 相关的包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure>
<p>可以使用下面的命令来启动 MySQL。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>

<p>在 CentOS 7 中，更推荐使用下面的命令来启动 MySQL。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>

<p>启动 MySQL 成功后，可以通过下面的命令来检查网络端口使用情况，MySQL 默认使用<code>3306</code>端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ntlp | grep mysql</span><br></pre></td></tr></table></figure>
<h4 id="使用-MySQL-客户端工具连接服务器。"><a href="#使用-MySQL-客户端工具连接服务器。" class="headerlink" title="使用 MySQL 客户端工具连接服务器。"></a>使用 MySQL 客户端工具连接服务器。</h4><p>在实际开发中，为了方便用户操作，可以选择图形化的客户端工具来连接 MySQL 服务器，例如MySQL Workbench（官方工具）</p>
<p>使用 MySQL 客户端工具连接服务器。<br>命令行工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>修改口令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length<span class="operator">=</span><span class="number">6</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="创建用户：以root用户登录到数据库进行用户创建"><a href="#创建用户：以root用户登录到数据库进行用户创建" class="headerlink" title="创建用户：以root用户登录到数据库进行用户创建"></a>创建用户：以root用户登录到数据库进行用户创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>note:<br>username——将要创建的用户名；<br>host——指定该用户在哪个主机上可以登录，”localhost”指该用户只能在本地登录，不能在另外一台机器上远程登录，如果想远程登录，将”localhost”改为”%”，表示在任何一台电脑上都可以登录；也可以指定某台机器可以远程登录；<br>password——该用户的登录密码，密码可以为空，若为空则该用户可以不需要密码登录服务器。</p>
<h4 id="授权：以root用户登录到数据库进行授权"><a href="#授权：以root用户登录到数据库进行授权" class="headerlink" title="授权：以root用户登录到数据库进行授权"></a>授权：以root用户登录到数据库进行授权</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> databasename.tablename <span class="keyword">TO</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span></span><br></pre></td></tr></table></figure>
<p>note:<br>privileges——用户的操作权限，如SELECT等。如果授予所有权限则使用ALL。<br>databasename——数据库名称。tablename——表名。如果要给该用户授予对所有数据库和表的相应操作权限则可用<em>表示，例如</em>.*<br>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> test_db.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;test_admin2&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>note:必须执行flush privileges;</p>
<h4 id="撤销用户权限"><a href="#撤销用户权限" class="headerlink" title="撤销用户权限"></a>撤销用户权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privilege <span class="keyword">ON</span> databasename.tablename <span class="keyword">FROM</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="删除账户及权限："><a href="#删除账户及权限：" class="headerlink" title="删除账户及权限："></a>删除账户及权限：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="查看用户的授权"><a href="#查看用户的授权" class="headerlink" title="查看用户的授权"></a>查看用户的授权</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>p funds <span class="operator">&gt;</span> funds_backup.sql</span><br></pre></td></tr></table></figure>


<h3 id="天天基金数据"><a href="#天天基金数据" class="headerlink" title="天天基金数据"></a>天天基金数据</h3><p>通过访问下面的链接提供适当参数，即可获取指定基金在指定日期段内的净值数据，例如获取基金代码005918</p>
<p>无参数版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://fundf10.eastmoney.com/F10DataApi.aspx?type=lsjz&amp;code=005918</span><br></pre></td></tr></table></figure>
<p>默认返回近10天的数据，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var apidata=&#123; content:&quot;</span><br><span class="line">净值日期	单位净值	累计净值	日增长率	申购状态	赎回状态	分红送配</span><br><span class="line">2022-03-08	1.2146	1.2146	-1.87%	开放申购	开放赎回	</span><br><span class="line">...	</span><br><span class="line">&quot;,records:944,pages:472,curpage:1&#125;;</span><br></pre></td></tr></table></figure>

<p>加参数版本，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&amp;code=005918&amp;page=1&amp;sdate=2020-01-01&amp;edate=2020-02-13&amp;per=20</span><br></pre></td></tr></table></figure>

<p>链接中的各参数含义简单说明：</p>
<p>code：指明基金代码；<br>sdate：数据开始日期；<br>edate：数据结束日期；<br>per：指定每页显示的条数，如果不指定该参数，则默认值为10，如果指定该参数值在1-49之间，则每页条数按照指定参数值显示，如果指定该值大于等于50，则每页显示20条；<br>page：per指定了每页的显示条数，存在一页显示不完整的情况，该参数直接指定显示第几页。<br>如上图，底部有pages、curpage参数，分别指明总页数和当前页数，在抓取数据时，需要特别处理，否则只能获取当页数据</p>
<p>查询带有估值信息的接口，如查询005918</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://fundgz.1234567.com.cn/js/005918.js</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jsonpgz(&#123;&quot;fundcode&quot;:&quot;005918&quot;,&quot;name&quot;:&quot;澶╁紭娌繁300ETF鑱旀帴C&quot;,&quot;jzrq&quot;:&quot;2022-03-08&quot;,&quot;dwjz&quot;:&quot;1.2146&quot;,&quot;gsz&quot;:&quot;1.2040&quot;,&quot;gszzl&quot;:&quot;-0.87&quot;,&quot;gztime&quot;:&quot;2022-03-09 15:00&quot;&#125;);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>OneNET</title>
    <url>/2024/03/23/onenet/</url>
    <content><![CDATA[<h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h3><p>设备接入支持标准MQTTV3.1.1版本，支持TLS加密，接入服务地址如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MQTT协议 &#x27;mqtts.heclouds.com:1883&#x27;</span><br></pre></td></tr></table></figure>
<p>设备可通过MQTT connnect报文进行登录，connect报文中三要素填写方法如下：</p>
<p>参数	是否必须	参数说明<br>clientId	是	设备名称<br>username	是	平台分配的产品ID<br>password	是	填写经过 key 计算的 token</p>
<span id="more"></span>

<h4 id="token计算方式"><a href="#token计算方式" class="headerlink" title="token计算方式"></a>token计算方式</h4><p>打开 “tokenV2.0.exe”<br>res: products&#x2F;产品ID&#x2F;devices&#x2F;设备名称   例如：res &#x3D; products&#x2F;vUui7WOi1a&#x2F;devices&#x2F;led0<br>et: 2121957139 例如 UTC token最后有效时间 2038</p>
]]></content>
      <categories>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程在爬虫中的应用</title>
    <url>/2023/07/10/python/</url>
    <content><![CDATA[<h2 id="并发编程在爬虫中的应用"><a href="#并发编程在爬虫中的应用" class="headerlink" title="并发编程在爬虫中的应用"></a>并发编程在爬虫中的应用</h2><p>之前的课程，我们已经为大家介绍了 Python 中的多线程、多进程和异步编程，通过这三种手段，我们可以实现并发或并行编程，这一方面可以加速代码的执行，另一方面也可以带来更好的用户体验。爬虫程序是典型的 I&#x2F;O 密集型任务，对于 I&#x2F;O 密集型任务来说，多线程和异步 I&#x2F;O 都是很好的选择，因为当程序的某个部分因 I&#x2F;O 操作阻塞时，程序的其他部分仍然可以运转，这样我们不用在等待和阻塞中浪费大量的时间。下面我们以爬取“<a href="https://image.so.com/">360图片</a>”网站的图片并保存到本地为例，为大家分别展示使用单线程、多线程和异步 I&#x2F;O 编程的爬虫程序有什么区别，同时也对它们的执行效率进行简单的对比。</p>
<span id="more"></span>

<p>“360图片”网站的页面使用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX">Ajax</a> 技术，这是很多网站都会使用的一种异步加载数据和局部刷新页面的技术。简单的说，页面上的图片都是通过 JavaScript 代码异步获取 JSON 数据并动态渲染生成的，而且整个页面还使用了瀑布式加载（一边向下滚动，一边加载更多的图片）。我们在浏览器的“开发者工具”中可以找到提供动态内容的数据接口，如下图所示，我们需要的图片信息就在服务器返回的 JSON 数据中。</p>
<img src="https://gitee.com/jackfrued/mypic/raw/master/20211205221352.png" style="zoom:50%;">

<p>例如，要获取“美女”频道的图片，我们可以请求如下所示的URL，其中参数<code>ch</code>表示请求的频道，<code>=</code>后面的参数值<code>beauty</code>就代表了“美女”频道，参数<code>sn</code>相当于是页码，<code>0</code>表示第一页（共<code>30</code>张图片），<code>30</code>表示第二页，<code>60</code>表示第三页，以此类推。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://image.so.com/zjl?ch=beauty&amp;sn=0</span><br></pre></td></tr></table></figure>

<h3 id="单线程版本"><a href="#单线程版本" class="headerlink" title="单线程版本"></a>单线程版本</h3><p>通过上面的 URL 下载“美女”频道共<code>90</code>张图片。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">example04.py - 单线程版本爬虫</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_picture</span>(<span class="params">url</span>):</span><br><span class="line">    filename = url[url.rfind(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>:]</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> resp.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;images/beauty/<span class="subst">&#123;filename&#125;</span>&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(resp.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;images/beauty&#x27;</span>):</span><br><span class="line">        os.makedirs(<span class="string">&#x27;images/beauty&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        resp = requests.get(<span class="string">f&#x27;https://image.so.com/zjl?ch=beauty&amp;sn=<span class="subst">&#123;page * <span class="number">30</span>&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> resp.status_code == <span class="number">200</span>:</span><br><span class="line">            pic_dict_list = resp.json()[<span class="string">&#x27;list&#x27;</span>]</span><br><span class="line">            <span class="keyword">for</span> pic_dict <span class="keyword">in</span> pic_dict_list:</span><br><span class="line">                download_picture(pic_dict[<span class="string">&#x27;qhimg_url&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在 macOS 或 Linux 系统上，我们可以使用<code>time</code>命令来了解上面代码的执行时间以及 CPU 的利用率，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">time python3 example04.py </span><br></pre></td></tr></table></figure>

<p>下面是单线程爬虫代码在我的电脑上执行的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 example04.py  2.36s user 0.39s system 12% cpu 21.578 total</span><br></pre></td></tr></table></figure>

<p>这里我们只需要关注代码的总耗时为<code>21.578</code>秒，CPU 利用率为<code>12%</code>。</p>
<h3 id="多线程版本"><a href="#多线程版本" class="headerlink" title="多线程版本"></a>多线程版本</h3><p>我们使用之前讲到过的线程池技术，将上面的代码修改为多线程版本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">example05.py - 多线程版本爬虫</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_picture</span>(<span class="params">url</span>):</span><br><span class="line">    filename = url[url.rfind(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>:]</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> resp.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;images/beauty/<span class="subst">&#123;filename&#125;</span>&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(resp.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;images/beauty&#x27;</span>):</span><br><span class="line">        os.makedirs(<span class="string">&#x27;images/beauty&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">16</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            resp = requests.get(<span class="string">f&#x27;https://image.so.com/zjl?ch=beauty&amp;sn=<span class="subst">&#123;page * <span class="number">30</span>&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> resp.status_code == <span class="number">200</span>:</span><br><span class="line">                pic_dict_list = resp.json()[<span class="string">&#x27;list&#x27;</span>]</span><br><span class="line">                <span class="keyword">for</span> pic_dict <span class="keyword">in</span> pic_dict_list:</span><br><span class="line">                    pool.submit(download_picture, pic_dict[<span class="string">&#x27;qhimg_url&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>执行如下所示的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">time python3 example05.py</span><br></pre></td></tr></table></figure>

<p>代码的执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 example05.py  2.65s user 0.40s system 95% cpu 3.193 total</span><br></pre></td></tr></table></figure>

<h3 id="异步I-O版本"><a href="#异步I-O版本" class="headerlink" title="异步I&#x2F;O版本"></a>异步I&#x2F;O版本</h3><p>我们使用<code>aiohttp</code>将上面的代码修改为异步 I&#x2F;O 的版本。为了以异步 I&#x2F;O 的方式实现网络资源的获取和写文件操作，我们首先得安装三方库<code>aiohttp</code>和<code>aiofile</code>，命令如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install aiohttp aiofile</span><br></pre></td></tr></table></figure>

<p><code>aiohttp</code> 的用法在之前的课程中已经做过简要介绍，<code>aiofile</code>模块中的<code>async_open</code>函数跟 Python 内置函数<code>open</code>的用法大致相同，只不过它支持异步操作。下面是异步 I&#x2F;O 版本的爬虫代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">example06.py - 异步I/O版本爬虫</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiofile</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_picture</span>(<span class="params">session, url</span>):</span><br><span class="line">    filename = url[url.rfind(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, ssl=<span class="literal">False</span>) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">if</span> resp.status == <span class="number">200</span>:</span><br><span class="line">            data = <span class="keyword">await</span> resp.read()</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> aiofile.async_open(<span class="string">f&#x27;images/beauty/<span class="subst">&#123;filename&#125;</span>&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">                <span class="keyword">await</span> file.write(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_json</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(</span><br><span class="line">                url=<span class="string">f&#x27;https://image.so.com/zjl?ch=beauty&amp;sn=<span class="subst">&#123;page * <span class="number">30</span>&#125;</span>&#x27;</span>,</span><br><span class="line">                ssl=<span class="literal">False</span></span><br><span class="line">            ) <span class="keyword">as</span> resp:</span><br><span class="line">                <span class="keyword">if</span> resp.status == <span class="number">200</span>:</span><br><span class="line">                    json_str = <span class="keyword">await</span> resp.text()</span><br><span class="line">                    result = json.loads(json_str)</span><br><span class="line">                    <span class="keyword">for</span> pic_dict <span class="keyword">in</span> result[<span class="string">&#x27;list&#x27;</span>]:</span><br><span class="line">                        <span class="keyword">await</span> download_picture(session, pic_dict[<span class="string">&#x27;qhimg_url&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;images/beauty&#x27;</span>):</span><br><span class="line">        os.makedirs(<span class="string">&#x27;images/beauty&#x27;</span>)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(fetch_json())</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>执行如下所示的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">time python3 example06.py</span><br></pre></td></tr></table></figure>

<p>代码的执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 example06.py  0.82s user 0.21s system 27% cpu 3.782 total</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面三段代码执行结果的比较，我们可以得出一个结论，使用多线程和异步 I&#x2F;O 都可以改善爬虫程序的性能，因为我们不用将时间浪费在因 I&#x2F;O 操作造成的等待和阻塞上，而<code>time</code>命令的执行结果也告诉我们，单线程的代码 CPU 利用率仅仅只有<code>12%</code>，而多线程版本的 CPU 利用率则高达<code>95%</code>；单线程版本的爬虫执行时间约<code>21</code>秒，而多线程和异步 I&#x2F;O 的版本仅执行了<code>3</code>秒钟。另外，在运行时间差别不大的情况下，多线程的代码比异步 I&#x2F;O 的代码耗费了更多的 CPU 资源，这是因为多线程的调度和切换也需要花费 CPU 时间。至此，三种方式在 I&#x2F;O 密集型任务上的优劣已经一目了然，当然这只是在我的电脑上跑出来的结果。如果网络状况不是很理想或者目标网站响应很慢，那么使用多线程和异步 I&#x2F;O 的优势将更为明显，有兴趣的读者可以自行试验。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Threads</tag>
      </tags>
  </entry>
  <entry>
    <title>clash config</title>
    <url>/2023/07/17/pac/</url>
    <content><![CDATA[<h3 id="pac-src"><a href="#pac-src" class="headerlink" title="pac src"></a>pac src</h3><p><a href="https://cdn.jsdelivr.net/gh/Alvin9999/pac2@master/clash/1/config.yaml">https://cdn.jsdelivr.net/gh/Alvin9999/pac2@master/clash/1/config.yaml</a></p>
<p><a href="https://cdn.jsdelivr.net/gh/Alvin9999/pac2@master/clash/15/config.yaml">https://cdn.jsdelivr.net/gh/Alvin9999/pac2@master/clash/15/config.yaml</a></p>
<p><a href="https://cdn.jsdelivr.net/gh/Alvin9999/pac2@master/hysteria/config.json">https://cdn.jsdelivr.net/gh/Alvin9999/pac2@master/hysteria/config.json</a></p>
<p><a href="https://cdn.jsdelivr.net/gh/Alvin9999/pac2@master/hysteria/1/config.json">https://cdn.jsdelivr.net/gh/Alvin9999/pac2@master/hysteria/1/config.json</a></p>
<span id="more"></span>

<h3 id="Linux-终端走代理"><a href="#Linux-终端走代理" class="headerlink" title="Linux 终端走代理"></a>Linux 终端走代理</h3><p>-方法一：（推荐使用）<br>为什么说这个方法推荐使用呢？因为他只作用于当前终端中，不会影响环境，而且命令比较简单<br>在终端中直接运行：</p>
<p>export http_proxy&#x3D;<a href="http://proxyAddress:port">http://proxyAddress:port</a><br>如果你是SSR,并且走的http的代理端口是1081，想执行wget或者curl来下载国外的东西，可以使用如下命令：</p>
<p>export http_proxy&#x3D;<a href="http://127.0.0.1:1081/">http://127.0.0.1:1081</a><br>如果是https那么就经过如下命令：</p>
<p>export https_proxy&#x3D;<a href="http://127.0.0.1:1081/">http://127.0.0.1:1081</a><br>方法二 ：<br>这个办法的好处是把代理服务器永久保存了，下次就可以直接用了<br>把代理服务器地址写入shell配置文件.bashrc或者.zshrc 直接在.bashrc或者.zshrc添加下面内容</p>
<p>export http_proxy&#x3D;”<a href="http://localhost:port">http://localhost:port</a>“<br>export https_proxy&#x3D;”<a href="http://localhost:port">http://localhost:port</a>“<br>或者走socket5协议（ss,ssr）的话，代理端口是1080</p>
<p>export http_proxy&#x3D;”socks5:&#x2F;&#x2F;127.0.0.1:1080”<br>export https_proxy&#x3D;”socks5:&#x2F;&#x2F;127.0.0.1:1080”<br>或者干脆直接设置ALL_PROXY</p>
<p>export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080<br>最后在执行如下命令应用设置</p>
<p>source ~&#x2F;.bashrc<br>或者通过设置alias简写来简化操作，每次要用的时候输入setproxy，不用了就unsetproxy。</p>
<p> alias setproxy&#x3D;”export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080” alias unsetproxy&#x3D;”unset ALL_PROXY”</p>
<p> 方法三:<br>改相应工具的配置，比如apt的配置</p>
<p>sudo vim &#x2F;etc&#x2F;apt&#x2F;apt.conf<br>在文件末尾加入下面这行</p>
<p>Acquire::http::Proxy “<a href="http://proxyAddress:port">http://proxyAddress:port</a>“<br>重点来了！！如果说经常使用git对于其他方面都不是经常使用，可以直接配置git的命令。<br>使用ss&#x2F;ssr来加快git的速度<br>直接输入这个命令就好了</p>
<p>git config –global http.proxy ‘socks5:&#x2F;&#x2F;127.0.0.1:1080’<br>git config –global https.proxy ‘socks5:&#x2F;&#x2F;127.0.0.1:1080’</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>clash</tag>
      </tags>
  </entry>
  <entry>
    <title>QEMU 仿真 arm</title>
    <url>/2024/04/20/qemu/</url>
    <content><![CDATA[<h1 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h1><p> QEMU” 是一个广泛使用的开源计算机模拟器和虚拟机。”</p>
<ul>
<li>当作为模拟器时，可以在一种架构（如 x86 PC）下运行另一种架构（如 ARM）下的操作系统和程序。通过使用动态转换，它可以获得非常好的性能。</li>
<li>作为虚拟机时，QEMU 可以使用其他虚拟机管理程序（如 Xen 或 KVM）来使用 CPU 扩展（HVM）进行虚拟化，通过在主机 CPU 上直接执行客户机代码来获得接近于宿主机的性能。<span id="more"></span></li>
</ul>
<h2 id="QEMU-安装"><a href="#QEMU-安装" class="headerlink" title="QEMU 安装"></a>QEMU 安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt-get install qemu qemu-system qemu-user </span><br></pre></td></tr></table></figure>
<p>安装完成后，可以通过 Tab 键补全检查安装好的 qemu 工具：”qemu-system-“ </p>
<ul>
<li><strong>qemu-system-arm</strong> 用来模拟 32 位的 Arm cpu，比如 Arm9 &#x2F;Arm11、 Cortex-A7&#x2F;A9&#x2F;A15 。</li>
<li><strong>qemu-system-aarch64</strong> 来模拟 64 位的 Arm cpu，比如 Arm Cortex A53，A57。</li>
</ul>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="cross-toochain-安装"><a href="#cross-toochain-安装" class="headerlink" title="cross-toochain 安装"></a>cross-toochain 安装</h3><p>安装 32 位编译器，用于编译 32 位的 kernel，u-boot。</p>
<p><code>sudo apt-get install gcc-arm-linux-gnueabi</code><br>安装 64 位编译器，用于编译 64 位的 kernel，u-boot。 </p>
<p><code>sudo apt-get install gcc-aarch64-linux-gnu</code></p>
<ul>
<li>arm926EJ-S 对应 gcc-arm-none-eabihf</li>
<li>armv7 对应 gcc-arm-none-eabihf</li>
<li>armv8 对应 aarch64-none-linux-gnu ??</li>
</ul>
<p>设置交叉编译器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export CROSS_COMPILE=arm-none-linux-gnueabi-</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="kernel-编译"><a href="#kernel-编译" class="headerlink" title="kernel 编译"></a>kernel 编译</h3><p>通过 wget 来获取阿里提供的镜像源内核</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.aliyun.com/linux-kernel/v5.x/linux-5.15.105.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="编译-32-位-kernel"><a href="#编译-32-位-kernel" class="headerlink" title="编译 32 位 kernel"></a>编译 32 位 kernel</h4><p>这里我们使用 vexpress-a9 这款开发板。vexpress-a9 是 Arm 公司自己设计的一款 4 核 Cortex-A9 开发板，U-Boot、Linux Kernel 和 QEMU 对这款开发板都做了完整的支持。当然，如果想搭其它开发板，也不难，只要 qemu 和内核对它有成熟的支持就够了。</p>
<p>生成 vexpress 开发板子的 config 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm vexpress_defconfig</span><br></pre></td></tr></table></figure>
<p>编译内核：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm</span><br></pre></td></tr></table></figure>
<p>生成的内核镱像位于 arch&#x2F;arm&#x2F;boot&#x2F;zImage.。</p>
<blockquote>
<p>编译 64 位 kernel 使用 aarch64-linux-gnu-</p>
</blockquote>
<h3 id="u-boot-编译"><a href="#u-boot-编译" class="headerlink" title="u-boot 编译"></a>u-boot 编译</h3><p>github 上拉去太慢，使用如下地址，通过 wget 来获取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://ftp.denx.de/pub/u-boot/u-boot-2020.10.tar.bz2</span><br></pre></td></tr></table></figure>
<p>下载完后，可以看到 configs 目录下有针对这款开发板的配置文件。ca9x4 表示 cortexA9 架构，4 核心。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd u-boot-xxx</span><br><span class="line"></span><br><span class="line">ls configs/ | grep vexpress</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make ARCH=arm vexpress_ca9x4_defconfig</span><br><span class="line">make CROSS_COMPILE=arm-linux-gnueabi- all</span><br></pre></td></tr></table></figure>
<p>最终编译生成 elf 格式的可执行文件 u-boot 和纯二进制文件 u-boot.bin，其中 QEMU 可以启动的为 elf 格式的可执行文件 u-boot 。</p>
<blockquote>
<p>编译 64 位 kernel 使用 aarch64-linux-gnu-</p>
</blockquote>
<h3 id="rootfs-编译"><a href="#rootfs-编译" class="headerlink" title="rootfs 编译"></a>rootfs 编译</h3><p>根文件系统首先是内核启动时所 mount 的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。编译和制作 Linux 最小系统的根文件系统，并通过 sd 卡或者 nfs 挂载根文件系统。<br>根文件系统的制作方法有很多，有 buildroot、busybox 等，安装过程最为简单的轻量级根文件系统制作工具 busybox。</p>
<h4 id="busybox-编译-快"><a href="#busybox-编译-快" class="headerlink" title="busybox 编译 快"></a>busybox 编译 快</h4><p> busybox 编译完成后，只是初步具有了维持 linux 操作系统基本运行所需的可执行文件，还有设备节点、动态链接库、引导启动相关代码、用户相关信息等，需要根据开发板自身的特性做定制和适配。</p>
<ol>
<li>下载并解压 busybox 源码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/workspace</span><br><span class="line">wget https://busybox.net/downloads/busybox-1.36.1.tar.bz2</span><br><span class="line">tar -xvf busybox-1.36.1.tar.bz2</span><br></pre></td></tr></table></figure></li>
<li>制作 automake_arm32.sh 自动编译脚本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd busybox-1.36.1</span><br><span class="line">vi automake_arm32.sh</span><br></pre></td></tr></table></figure>
在automake_arm32.sh中添加下列代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- clean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j12</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- CONFIG_PREFIX=../objects/rootfs-arm32 install</span><br></pre></td></tr></table></figure>
运行 automake_arm32.sh 编译安装 busybox<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./automake_arm32.sh</span><br></pre></td></tr></table></figure>
编译过程中会出现 menuconfig 界面，需要将 “Settings-&gt;Build Options-&gt;Build static binary” 选上</li>
</ol>
<h5 id="补充根文件系统"><a href="#补充根文件系统" class="headerlink" title="补充根文件系统"></a>补充根文件系统</h5><p>进入根文件系统目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/workspace/objects/rootfs-arm32</span><br></pre></td></tr></table></figure>
<p>创建设备节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir dev</span><br><span class="line">sudo mknod -m 666 dev/tty1 c 4 1</span><br><span class="line">sudo mknod -m 666 dev/tty2 c 4 2</span><br><span class="line">sudo mknod -m 666 dev/tty3 c 4 3</span><br><span class="line">sudo mknod -m 666 dev/tty4 c 4 4</span><br><span class="line">sudo mknod -m 666 dev/console c 5 1</span><br><span class="line">sudo mknod -m 666 dev/null c 1 3</span><br></pre></td></tr></table></figure>
<p>安装动态链接库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir lib</span><br><span class="line">sudo cp -d /usr/arm-linux-gnueabi/lib/*.so* ./lib</span><br></pre></td></tr></table></figure>
<p>配置初始化进程 rcS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p etc/init.d</span><br><span class="line">touch etc/init.d/rcS</span><br><span class="line">chmod 777 etc/init.d/rcS</span><br><span class="line">vim etc/init.d/rcS</span><br></pre></td></tr></table></figure>
<p>在rcS中填入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin</span><br><span class="line">export LD_LIBRARY_PATH=/lib:/usr/lib</span><br><span class="line">/bin/mount -n -t ramfs ramfs /var</span><br><span class="line">/bin/mount -n -t ramfs ramfs /tmp</span><br><span class="line">/bin/mount -n -t sysfs none /sys</span><br><span class="line">/bin/mount -n -t ramfs none /dev</span><br><span class="line">/bin/mkdir /var/tmp</span><br><span class="line">/bin/mkdir /var/modules</span><br><span class="line">/bin/mkdir /var/run</span><br><span class="line">/bin/mkdir /var/log</span><br><span class="line">/bin/mkdir -p /dev/pts</span><br><span class="line">/bin/mkdir -p /dev/shm</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">/bin/mount -a</span><br><span class="line">echo &quot;-----------------------------------&quot;</span><br><span class="line">echo &quot;*****welcome to vexpress board*****&quot;</span><br><span class="line">echo &quot;-----------------------------------&quot;</span><br></pre></td></tr></table></figure>
<p>配置文件系统 fstab</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch etc/fstab</span><br><span class="line">vim etc/fstab</span><br></pre></td></tr></table></figure>
<p>在fstab中填入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc    /proc           proc    defaults        0       0</span><br><span class="line">none    /dev/pts        devpts  mode=0622       0       0</span><br><span class="line">mdev    /dev            ramfs   defaults        0       0</span><br><span class="line">sysfs   /sys            sysfs   defaults        0       0</span><br><span class="line">tmpfs   /dev/shm        tmpfs   defaults        0       0</span><br><span class="line">tmpfs   /dev            tmpfs   defaults        0       0</span><br><span class="line">tmpfs   /mnt            tmpfs   defaults        0       0</span><br><span class="line">var     /dev            tmpfs   defaults        0       0</span><br><span class="line">ramfs   /dev            ramfs   defaults        0       0</span><br></pre></td></tr></table></figure>
<p>配置初始化脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch etc/inittab</span><br><span class="line">vim etc/inittab</span><br></pre></td></tr></table></figure>
<p>在inittab中输入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS </span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::restart:/sbin/init </span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br></pre></td></tr></table></figure>
<p>配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch etc/profile</span><br><span class="line">vim etc/profile</span><br></pre></td></tr></table></figure>
<p>在profile中添加以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh </span><br><span class="line">USER=&quot;root&quot;</span><br><span class="line">LOGNAME=$USER</span><br><span class="line"># export HOSTNAME=vexpress-a9</span><br><span class="line">export HOSTNAME=`cat /etc/sysconfig/HOSTNAME`</span><br><span class="line">export USER=root</span><br><span class="line">export HOME=root</span><br><span class="line">export PS1=&quot;[$USER@$HOSTNAME:\w]\#&quot;</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin </span><br><span class="line">LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH</span><br><span class="line">export PATH LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>
<p>增加主机名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir etc/sysconfig</span><br><span class="line">vi etc/sysconfig/HOSTNAME</span><br></pre></td></tr></table></figure>
<p>在HOSTNAME中添加以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vexpress-a9</span><br></pre></td></tr></table></figure>
<p>创建其他文件夹<br><code>mkdir mnt proc root sys tmp var</code></p>
<h4 id="buildroot-编译慢"><a href="#buildroot-编译慢" class="headerlink" title="buildroot 编译慢"></a>buildroot 编译慢</h4><p>buildroot中可以方便地加入第三方软件包（其实已经内置了很多），省去了手工交叉编译的烦恼。<br>首先安装一些依赖，比如linux头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install linux-headers-$(uname -r)</span><br></pre></td></tr></table></figure>
<p>然后下载安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://buildroot.org/downloads/buildroot-2021.02.4.tar.gz</span><br><span class="line">tar xvf buildroot-2021.02.4.tar.gz</span><br><span class="line">cd buildroot-2021.02.4/</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line">以下选项为基础配置：</span><br><span class="line"></span><br><span class="line">- Target options</span><br><span class="line">  - Target Architecture (ARM (little endian))</span><br><span class="line">  - Target Variant arm926t</span><br><span class="line">- Toolchain</span><br><span class="line">  - C library (musl) # 使用musl减小最终体积</span><br><span class="line">- System configuration</span><br><span class="line">  - Use syslinks to /usr .... # 启用/bin, /sbin, /lib的链接</span><br><span class="line">  - Enable root login # 启用root登录</span><br><span class="line">  - Run a getty after boot # 启用登录密码输入窗口</span><br><span class="line">  - (licheepi) Root password #　默认账户为root 密码为licheepi</span><br><span class="line"></span><br><span class="line">另可自行添加或删除指定的软件包</span><br></pre></td></tr></table></figure>
<ul>
<li>Target options：目标体系架构，例如 riscv，arm，x86 等。</li>
<li>Build options：构建选项，例如 make 过程中使用的命令，源码下载目录，并行构建选项等。</li>
<li>Toolchain：交叉编译工具链选项，例如使用的 C 库类型。跟体系架构相关。</li>
<li>System configuration：系统配置，例如根文件系统框架，目标系统 hostname，bash，root 密码等。</li>
<li>Kernel：（可选的）Linux kernel 编译选项。</li>
<li>Target packages：安装到目标系统的软件包，例如 dhcp，ssh 等。</li>
<li>Filesystem images：根文件系统镜像格式，例如 ext4 镜像根文件系统。根文件系统镜像是 Buildroot 最主要的输出件。</li>
<li>Bootloaders：（可选的）系统启动引导程序 &#x2F; Bootloader，例如 u-boot，grub 等。跟体系架构相关。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
编译的过程如果带上下载软件包的时间比较漫长，很适合喝杯茶睡个午觉；(buildroot不能进行多线程编译)</li>
</ul>
<p>编译完成的镜像包，是<br>buildroot-2021.02.4&#x2F;output&#x2F;images&#x2F;rootfs.tar</p>
<h2 id="仿真运行"><a href="#仿真运行" class="headerlink" title="仿真运行"></a>仿真运行</h2><h3 id="单独启动-u-boot"><a href="#单独启动-u-boot" class="headerlink" title="单独启动 u-boot"></a>单独启动 u-boot</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-arm -M vexpress-a9 -m 512M -kernel where_is_directory/u-boot -nographic</span><br></pre></td></tr></table></figure>

<h3 id="单独启动-kernel"><a href="#单独启动-kernel" class="headerlink" title="单独启动 kernel"></a>单独启动 kernel</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-system-arm -M vexpress-a9 -m 512M -kernel /kernel_direcotry/arch/arm/boot/zImage -dtb  /kernel_direcotry/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append &quot;console=ttyAMA0&quot;</span><br></pre></td></tr></table></figure>
<h3 id="u-boot-加载-kernel"><a href="#u-boot-加载-kernel" class="headerlink" title="u-boot 加载 kernel"></a>u-boot 加载 kernel</h3><ol>
<li><p>QEMU 可以模拟 sd 卡等外设。我们就把编译好的固件放在一个模块的 sdcard 上，让 QEMU 从这张模拟的 sd 卡上启动 Linux 系统：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">制作 sd 卡镜像，并将它格式化成 fat 格式：</span><br><span class="line">dd if=/dev/zero of=sd.img bs=4096 count=4096</span><br><span class="line">mkfs.ext4 sd.img</span><br><span class="line"></span><br><span class="line">把编译好的 kernel zImage 和 dtb 文件拷贝到 sd.img 中:</span><br><span class="line">sudo mount sd.img mnt/ -o loop,rw</span><br><span class="line">sudo cp kernel_directory/arch/arm/boot/zImage /mnt/</span><br><span class="line">sudo cp kernel_directory/arch/arm/boot/dts/vexpress-v2p-ca9.dtb /mnt/</span><br><span class="line">sudo umount /mnt</span><br></pre></td></tr></table></figure></li>
<li><p>启动 QEMU </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-arm -M vexpress-a9 -m 512M -kernel uboot_directory/u-boot -nographic  -sd sd.img</span><br></pre></td></tr></table></figure>
<p>-kernel 指定 QEMU 启动时首先执行的程序，我们这里指定为前面编译好的 u-boot 可以执行文件，通过 u-boot 去加载 kernel。<br>上图所示 u-boot 已经顺利启动并进入命令行模式，下面我们来启动 Linux Kernel</p>
</li>
<li><p>首先通过 ext4load 命令把 sd.img 里面的 zImage 和 dtb 文件读到开发板的内存中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ext4load mmc 0:0 0x60008000 zImage</span><br><span class="line">ext4load mmc 0:0 0x62008000 vexpress-v2p-ca9.dtb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果失败，请重复几次。</p>
</blockquote>
</li>
<li><p>通过 bootz 命令启动 Linux Kernel：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bootz 0x60008000 - 0x62008000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项： 0x60008000  0x62008000 是怎么确认的这个地址？</p>
</blockquote>
</li>
</ol>
<ul>
<li>通过 “textofs” 查看 Linux kernel zImage 执行地址对应的内存偏移地址，为：0x00008000<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@test:/home/work/qemu_test/linux-5.10# grep -nr &quot;textofs&quot; ./</span><br><span class="line">./arch/arm/Makefile:141:textofs-y    := 0x00008000</span><br><span class="line">./arch/arm/Makefile:143:textofs-$(CONFIG_PM_H1940)      := 0x00108000</span><br><span class="line">./arch/arm/Makefile:145:textofs-$(CONFIG_ARCH_REALTEK)  := 0x00108000</span><br><span class="line">./arch/arm/Makefile:148:textofs-$(CONFIG_SA1111) := 0x00208000</span><br></pre></td></tr></table></figure></li>
<li>u-boot 命令行中输入 bdinfo 命令，可以查到这块开发板内存的起始地址。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=&gt; bdinfo</span><br><span class="line">boot_params = 0x60002000</span><br><span class="line">DRAM bank   = 0x00000000</span><br><span class="line">-&gt; start    = 0x60000000</span><br><span class="line">-&gt; size     = 0x20000000</span><br></pre></td></tr></table></figure>
从上图中可以看到这块开发板的内存实际地址为 0x60000000，所以对应内核的起始地址为：0x60008000。dtb 的加载地址没有特别的要求，一般注意和 Linux Kernel Image 避开，不要重叠即可；</li>
</ul>
<h3 id="kernel-加载-rootfs"><a href="#kernel-加载-rootfs" class="headerlink" title="kernel 加载 rootfs"></a>kernel 加载 rootfs</h3><h4 id="通过-SD-卡挂载根文件系统"><a href="#通过-SD-卡挂载根文件系统" class="headerlink" title="通过 SD 卡挂载根文件系统"></a>通过 SD 卡挂载根文件系统</h4><p>两种挂载根文件系统的方法，一种是通过在 qemu 上添加外设 sd 卡挂载根文件系统，另一种则是通过 nfs 共享文件夹挂载根文件系统。</p>
<p>自动打包脚本<br>编译安装完成后，进入 object 目录，并制作自动打包脚本 makefs-arm32.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/workspace/objects</span><br><span class="line">sudo mkdir /mnt/rootfs</span><br><span class="line">sudo chmod 777 /mnt/rootfs</span><br><span class="line">vi makefs-arm32.sh</span><br></pre></td></tr></table></figure>
<p>在makefs-arm32.sh中添加下列代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=rootfs-arm32.ext4 bs=1M count=64</span><br><span class="line">mkfs.ext4 rootfs-arm32.ext4</span><br><span class="line">sudo mount -t ext4 rootfs-arm32.ext4 /mnt/rootfs -o loop</span><br><span class="line">sudo cp -rf rootfs-arm32/* /mnt/rootfs/</span><br><span class="line">sudo umount /mnt/rootfs/</span><br></pre></td></tr></table></figure>
<p>运行自动打包脚本 makefs-arm32.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./makefs-arm32.sh</span><br></pre></td></tr></table></figure>
<p>运行完成后将在 objects 目录下生成一个 rootfs-arm32.ext4 文件，将作为外设 sd 卡加入到开发板上。<br>修改 qemu-start-vexpress-a9.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi qemu-start-vexpress-a9.sh</span><br></pre></td></tr></table></figure>
<p>将qemu-start-vexpress-a9.sh修改为以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! /bin/sh</span><br><span class="line">qemu-system-arm -M vexpress-a9 \</span><br><span class="line">        -m 512M \</span><br><span class="line">        -kernel vexpress-v2p-ca9/arch/arm/boot/zImage \</span><br><span class="line">        -dtb vexpress-v2p-ca9/arch/arm/boot/dts/vexpress-v2p-ca9.dtb \</span><br><span class="line">        -nographic \</span><br><span class="line">        -append &quot;root=/dev/mmcblk0 rw console=ttyAMA0&quot; \</span><br><span class="line">	    -sd rootfs-arm32.ext4</span><br></pre></td></tr></table></figure>
<h4 id="通过-NFS-挂载根文件系统"><a href="#通过-NFS-挂载根文件系统" class="headerlink" title="通过 NFS 挂载根文件系统"></a>通过 NFS 挂载根文件系统</h4><p>安装：<br><code>sudo apt install nfs-kernel-server</code><br>配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /sync/rootfs</span><br><span class="line">sudo vim /etc/exports</span><br></pre></td></tr></table></figure>
<p>在&#x2F;etc&#x2F;exports文件中添加以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sync/rootfs *(rw,sync,no_root_squash,no_subtree_check)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>！！！注意上述内容应严格按照格式输入，不能随意增减空格！！！<br>重启 nfs 服务器：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/rpcbind restart</span><br><span class="line">sudo /etc/init.d/nfs-kernel-server restart</span><br></pre></td></tr></table></figure>
<p>将安装好的根文件系统拷贝到 &#x2F; sync&#x2F;rootfs 内</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/workspace/objects/rootfs-arm32</span><br><span class="line">sudo cp -rf * /sync/rootfs/</span><br><span class="line">sudo chmod 777 -R /sync/rootfs</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为解决 Linux 内核与 NFS 服务器的兼容问题,重新编译内核，并在 menuconfig 下开启 NFS4 支持。<br>位置：File System -&gt; Network File Systems-&gt;NFS client support for NFS version 4</p>
</blockquote>
<p>测试 NFS 挂载根文件系统<br>配置主机网桥（其中 eth0 是 Ubuntu 系统的主网卡，根据实际情况可能会有不同的命名）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install uml-utilities bridge-utils</span><br><span class="line">sudo vim /etc/network/interfaces</span><br></pre></td></tr></table></figure>
<p>修改interfaces文件如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line">auto eth0</span><br><span class="line"> </span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet dhcp</span><br><span class="line">bridge_ports eth0</span><br></pre></td></tr></table></figure>

<p>创建 tap0 网卡，用于连接 qemu 虚拟开发板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tunctl -u root -t tap0</span><br><span class="line">sudo ifconfig tap0 172.16.16.10 promisc up</span><br></pre></td></tr></table></figure>

<p>创建 qemu-start-vexpress-a9-nfs.sh 脚本文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/workspace/objects</span><br><span class="line">vim qemu-start-vexpress-a9-nfs.sh</span><br></pre></td></tr></table></figure>
<p>在qemu-start-vexpress-a9-nfs.sh内添加以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-arm \</span><br><span class="line">        -M vexpress-a9 \</span><br><span class="line">        -m 512M \</span><br><span class="line">        -kernel vexpress-v2p-ca9/arch/arm/boot/zImage \</span><br><span class="line">        -dtb vexpress-v2p-ca9/arch/arm/boot/dts/vexpress-v2p-ca9.dtb \</span><br><span class="line">	    -net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line">	    -net nic,macaddr=00:16:3e:00:00:01 \</span><br><span class="line">        -nographic \</span><br><span class="line">        -append &quot;root=/dev/nfs rw nfsroot=172.16.16.10:/sync/rootfs,proto=tcp,nfsvers=3,nolock init=/linuxrc console=ttyAMA0 ip=172.16.16.20&quot; \</span><br></pre></td></tr></table></figure>

<p>运行 qemu-start-vexpress-a9-nfs.sh 脚本文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./qemu-start-vexpress-a9-nfs.sh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>qemu arm</tag>
      </tags>
  </entry>
  <entry>
    <title>MD SAMPLE</title>
    <url>/2022/01/01/sample/</url>
    <content><![CDATA[<h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ul>
<li>支持“标准”Markdown &#x2F; CommonMark和Github风格的语法，也可变身为代码编辑器；</li>
<li>支持实时预览、图片（跨域）上传、预格式文本&#x2F;代码&#x2F;表格插入、代码折叠、搜索替换、只读模式、自定义样式主题和多语言语法高亮等功能；</li>
<li>支持ToC（Table of Contents）、Emoji表情、Task lists、@链接等Markdown扩展语法；</li>
<li>支持TeX科学公式（基于KaTeX）、流程图 Flowchart 和 时序图 Sequence Diagram;</li>
<li>支持识别和解析HTML标签，并且支持自定义过滤标签解析，具有可靠的安全性和几乎无限的扩展性；</li>
<li>支持 AMD &#x2F; CMD 模块化加载（支持 Require.js &amp; Sea.js），并且支持自定义扩展插件；</li>
<li>兼容主流的浏览器（IE8+）和Zepto.js，且支持iPad等平板设备；</li>
<li>支持自定义主题样式；<span id="more"></span></li>
</ul>
<h1 id="Editor-md"><a href="#Editor-md" class="headerlink" title="Editor.md"></a>Editor.md</h1><p><img src="https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png"></p>
<p><img src="https://img.shields.io/github/stars/pandao/editor.md.svg"> <img src="https://img.shields.io/github/forks/pandao/editor.md.svg"> <img src="https://img.shields.io/github/tag/pandao/editor.md.svg"> <img src="https://img.shields.io/github/release/pandao/editor.md.svg"> <img src="https://img.shields.io/github/issues/pandao/editor.md.svg"> <img src="https://img.shields.io/bower/v/editor.md.svg"></p>
<p><strong>目录 (Table of Contents)</strong></p>
<p>[TOCM]</p>
<p>[TOC]</p>
<h1 id="Heading-1"><a href="#Heading-1" class="headerlink" title="Heading 1"></a>Heading 1</h1><h2 id="Heading-2"><a href="#Heading-2" class="headerlink" title="Heading 2"></a>Heading 2</h2><h3 id="Heading-3"><a href="#Heading-3" class="headerlink" title="Heading 3"></a>Heading 3</h3><h4 id="Heading-4"><a href="#Heading-4" class="headerlink" title="Heading 4"></a>Heading 4</h4><h5 id="Heading-5"><a href="#Heading-5" class="headerlink" title="Heading 5"></a>Heading 5</h5><h6 id="Heading-6"><a href="#Heading-6" class="headerlink" title="Heading 6"></a>Heading 6</h6><h1 id="Heading-1-link-Heading-link"><a href="#Heading-1-link-Heading-link" class="headerlink" title="Heading 1 link Heading link"></a>Heading 1 link <a href="https://github.com/pandao/editor.md" title="Heading link">Heading link</a></h1><h2 id="Heading-2-link-Heading-link"><a href="#Heading-2-link-Heading-link" class="headerlink" title="Heading 2 link Heading link"></a>Heading 2 link <a href="https://github.com/pandao/editor.md" title="Heading link">Heading link</a></h2><h3 id="Heading-3-link-Heading-link"><a href="#Heading-3-link-Heading-link" class="headerlink" title="Heading 3 link Heading link"></a>Heading 3 link <a href="https://github.com/pandao/editor.md" title="Heading link">Heading link</a></h3><h4 id="Heading-4-link-Heading-link-Heading-link-Heading-link"><a href="#Heading-4-link-Heading-link-Heading-link-Heading-link" class="headerlink" title="Heading 4 link Heading link Heading link Heading link"></a>Heading 4 link <a href="https://github.com/pandao/editor.md" title="Heading link">Heading link</a> Heading link <a href="https://github.com/pandao/editor.md" title="Heading link">Heading link</a></h4><h5 id="Heading-5-link-Heading-link"><a href="#Heading-5-link-Heading-link" class="headerlink" title="Heading 5 link Heading link"></a>Heading 5 link <a href="https://github.com/pandao/editor.md" title="Heading link">Heading link</a></h5><h6 id="Heading-6-link-Heading-link"><a href="#Heading-6-link-Heading-link" class="headerlink" title="Heading 6 link Heading link"></a>Heading 6 link <a href="https://github.com/pandao/editor.md" title="Heading link">Heading link</a></h6><h4 id="标题（用底线的形式）Heading-underline"><a href="#标题（用底线的形式）Heading-underline" class="headerlink" title="标题（用底线的形式）Heading (underline)"></a>标题（用底线的形式）Heading (underline)</h4><h1 id="This-is-an-H1"><a href="#This-is-an-H1" class="headerlink" title="This is an H1"></a>This is an H1</h1><h2 id="This-is-an-H2"><a href="#This-is-an-H2" class="headerlink" title="This is an H2"></a>This is an H2</h2><h3 id="字符效果和横线等"><a href="#字符效果和横线等" class="headerlink" title="字符效果和横线等"></a>字符效果和横线等</h3><hr>
<p><del>删除线</del> <s>删除线（开启识别HTML标签时）</s><br><em>斜体字</em>      <em>斜体字</em><br><strong>粗体</strong>  <strong>粗体</strong><br><em><strong>粗斜体</strong></em> <em><strong>粗斜体</strong></em></p>
<p>上标：X<sub>2</sub>，下标：O<sup>2</sup></p>
<p><strong>缩写(同HTML的abbr标签)</strong></p>
<blockquote>
<p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p>
</blockquote>
<p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p>
<h3 id="引用-Blockquotes"><a href="#引用-Blockquotes" class="headerlink" title="引用 Blockquotes"></a>引用 Blockquotes</h3><blockquote>
<p>引用文本 Blockquotes</p>
</blockquote>
<p>引用的行内混合 Blockquotes</p>
<blockquote>
<p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href="http://localhost/">普通链接</a>。</p>
</blockquote>
<h3 id="锚点与链接-Links"><a href="#锚点与链接-Links" class="headerlink" title="锚点与链接 Links"></a>锚点与链接 Links</h3><p><a href="http://localhost/">普通链接</a></p>
<p><a href="http://localhost/" title="普通链接带标题">普通链接带标题</a></p>
<p>直接链接：<a href="https://github.com/">https://github.com</a></p>
<p><a href="http://www.this-anchor-link.com/">锚点链接</a> </p>
<p>GFM a-tail link @pandao</p>
<blockquote>
<p>@pandao</p>
</blockquote>
<h3 id="多语言代码高亮-Codes"><a href="#多语言代码高亮-Codes" class="headerlink" title="多语言代码高亮 Codes"></a>多语言代码高亮 Codes</h3><h4 id="行内代码-Inline-code"><a href="#行内代码-Inline-code" class="headerlink" title="行内代码 Inline code"></a>行内代码 Inline code</h4><p>执行命令：<code>npm install marked</code></p>
<h4 id="缩进风格"><a href="#缩进风格" class="headerlink" title="缩进风格"></a>缩进风格</h4><p>即缩进四个空格，也做为实现类似<code>&lt;pre&gt;</code>预格式化文本(Preformatted Text)的功能。</p>
<pre><code>&lt;?php
    echo &quot;Hello world!&quot;;
?&gt;
</code></pre>
<p>预格式化文本：</p>
<pre><code>| First Header  | Second Header |
| ------------- | ------------- |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |
</code></pre>
<h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> box = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> box.<span class="property">fn</span>.<span class="title function_">init</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    box.<span class="property"><span class="keyword">prototype</span></span> = box.<span class="property">fn</span> = &#123;</span><br><span class="line">        init : <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box.init()&#x27;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">		add : <span class="keyword">function</span>(<span class="params">str</span>)&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&quot;add&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line">		remove : <span class="keyword">function</span>(<span class="params">str</span>)&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&quot;remove&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    box.<span class="property">fn</span>.<span class="property">init</span>.<span class="property"><span class="keyword">prototype</span></span> = box.<span class="property">fn</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">box</span> =box;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testBox = <span class="title function_">box</span>();</span><br><span class="line">testBox.<span class="title function_">add</span>(<span class="string">&quot;jQuery&quot;</span>).<span class="title function_">remove</span>(<span class="string">&quot;jQuery&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="HTML代码-HTML-codes"><a href="#HTML代码-HTML-codes" class="headerlink" title="HTML代码 HTML codes"></a>HTML代码 HTML codes</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="图片-Images"><a href="#图片-Images" class="headerlink" title="图片 Images"></a>图片 Images</h3><p>Image:</p>
<p><img src="https://pandao.github.io/editor.md/examples/images/4.jpg"></p>
<blockquote>
<p>Follow your heart.</p>
</blockquote>
<p><img src="https://pandao.github.io/editor.md/examples/images/8.jpg"></p>
<blockquote>
<p>图为：厦门白城沙滩</p>
</blockquote>
<p>图片加链接 (Image + Link)：</p>
<p><a href="https://pandao.github.io/editor.md/examples/images/7.jpg" title="李健首张专辑《似水流年》封面"><img src="https://pandao.github.io/editor.md/examples/images/7.jpg"></a></p>
<blockquote>
<p>图为：李健首张专辑《似水流年》封面</p>
</blockquote>
<hr>
<h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 Lists"></a>列表 Lists</h3><h4 id="无序列表（减号）Unordered-Lists"><a href="#无序列表（减号）Unordered-Lists" class="headerlink" title="无序列表（减号）Unordered Lists (-)"></a>无序列表（减号）Unordered Lists (-)</h4><ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表（星号）Unordered-Lists"><a href="#无序列表（星号）Unordered-Lists" class="headerlink" title="无序列表（星号）Unordered Lists (*)"></a>无序列表（星号）Unordered Lists (*)</h4><ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表（加号和嵌套）Unordered-Lists"><a href="#无序列表（加号和嵌套）Unordered-Lists" class="headerlink" title="无序列表（加号和嵌套）Unordered Lists (+)"></a>无序列表（加号和嵌套）Unordered Lists (+)</h4><ul>
<li>列表一</li>
<li>列表二<ul>
<li>列表二-1</li>
<li>列表二-2</li>
<li>列表二-3</li>
</ul>
</li>
<li>列表三<ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
</li>
</ul>
<h4 id="有序列表-Ordered-Lists"><a href="#有序列表-Ordered-Lists" class="headerlink" title="有序列表 Ordered Lists (-)"></a>有序列表 Ordered Lists (-)</h4><ol>
<li>第一行</li>
<li>第二行</li>
<li>第三行</li>
</ol>
<h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><ul>
<li><input checked="" disabled="" type="checkbox"> GFM task list 1</li>
<li><input checked="" disabled="" type="checkbox"> GFM task list 2</li>
<li><input disabled="" type="checkbox"> GFM task list 3<ul>
<li><input disabled="" type="checkbox"> GFM task list 3-1</li>
<li><input disabled="" type="checkbox"> GFM task list 3-2</li>
<li><input disabled="" type="checkbox"> GFM task list 3-3</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> GFM task list 4<ul>
<li><input disabled="" type="checkbox"> GFM task list 4-1</li>
<li><input disabled="" type="checkbox"> GFM task list 4-2</li>
</ul>
</li>
</ul>
<hr>
<h3 id="绘制表格-Tables"><a href="#绘制表格-Tables" class="headerlink" title="绘制表格 Tables"></a>绘制表格 Tables</h3><table>
<thead>
<tr>
<th>项目</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>计算机</td>
<td align="right">$1600</td>
<td align="center">5</td>
</tr>
<tr>
<td>手机</td>
<td align="right">$12</td>
<td align="center">12</td>
</tr>
<tr>
<td>管线</td>
<td align="right">$1</td>
<td align="center">234</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Function name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>help()</code></td>
<td>Display the help window.</td>
</tr>
<tr>
<td><code>destroy()</code></td>
<td><strong>Destroy your computer!</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">Left-Aligned</th>
<th align="center">Center Aligned</th>
<th align="right">Right Aligned</th>
</tr>
</thead>
<tbody><tr>
<td align="left">col 3 is</td>
<td align="center">some wordy text</td>
<td align="right">$1600</td>
</tr>
<tr>
<td align="left">col 2 is</td>
<td align="center">centered</td>
<td align="right">$12</td>
</tr>
<tr>
<td align="left">zebra stripes</td>
<td align="center">are neat</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Item</th>
<th align="right">Value</th>
</tr>
</thead>
<tbody><tr>
<td>Computer</td>
<td align="right">$1600</td>
</tr>
<tr>
<td>Phone</td>
<td align="right">$12</td>
</tr>
<tr>
<td>Pipe</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<hr>
<h4 id="特殊符号-HTML-Entities-Codes"><a href="#特殊符号-HTML-Entities-Codes" class="headerlink" title="特殊符号 HTML Entities Codes"></a>特殊符号 HTML Entities Codes</h4><p>&copy; &amp;  &uml; &trade; &iexcl; &pound;<br>&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot; </p>
<p>X&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;</p>
<p>18&ordm;C  &quot;  &apos;</p>
<h3 id="Emoji表情-smiley"><a href="#Emoji表情-smiley" class="headerlink" title="Emoji表情 :smiley:"></a>Emoji表情 :smiley:</h3><blockquote>
<p>Blockquotes :star:</p>
</blockquote>
<h4 id="GFM-task-lists-Emoji-fontAwesome-icon-emoji-editormd-logo-emoji-editormd-logo-5x"><a href="#GFM-task-lists-Emoji-fontAwesome-icon-emoji-editormd-logo-emoji-editormd-logo-5x" class="headerlink" title="GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:"></a>GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4><ul>
<li><input checked="" disabled="" type="checkbox"> :smiley: @mentions, :smiley: #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li>
<li><input checked="" disabled="" type="checkbox"> list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li>
<li><input checked="" disabled="" type="checkbox"> [ ] :smiley: this is a complete item :smiley:;</li>
<li><input disabled="" type="checkbox"> []this is an incomplete item <a href="#">test link</a> :fa-star: @pandao; </li>
<li><input disabled="" type="checkbox"> [ ]this is an incomplete item :fa-star: :fa-gear:;<ul>
<li><input disabled="" type="checkbox"> :smiley: this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li>
<li><input disabled="" type="checkbox"> :smiley: this is  :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li>
</ul>
</li>
</ul>
<h4 id="反斜杠-Escape"><a href="#反斜杠-Escape" class="headerlink" title="反斜杠 Escape"></a>反斜杠 Escape</h4><p>*literal asterisks*</p>
<h3 id="科学公式-TeX-KaTeX"><a href="#科学公式-TeX-KaTeX" class="headerlink" title="科学公式 TeX(KaTeX)"></a>科学公式 TeX(KaTeX)</h3><p>$$E&#x3D;mc^2$$</p>
<p>行内的公式$$E&#x3D;mc^2$$行内的公式，行内的$$E&#x3D;mc^2$$公式。</p>
<p>$$(\sqrt{3x-1}+(1+x)^2)$$</p>
<p>$$\sin(\alpha)^{\theta}&#x3D;\sum_{i&#x3D;0}^{n}(x^i + \cos(f))$$</p>
<p>多行公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k b\_k \right)^2</span><br><span class="line">\leq</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k^2 \right)</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n b\_k^2 \right)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\displaystyle </span><br><span class="line">    \frac&#123;1&#125;&#123;</span><br><span class="line">        \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;</span><br><span class="line">        \frac25 \pi&#125;&#125; = 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;</span><br><span class="line">        1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">        &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125;</span><br><span class="line">         &#123;1+\cdots&#125; &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">f(x) = <span class="keyword">\int</span><span class="built_in">_</span>&#123;-<span class="keyword">\infty</span>&#125;<span class="built_in">^</span><span class="keyword">\infty</span></span><br><span class="line">    <span class="keyword">\hat</span> f(<span class="keyword">\xi</span>)<span class="keyword">\,</span>e<span class="built_in">^</span>&#123;2 <span class="keyword">\pi</span> i <span class="keyword">\xi</span> x&#125;</span><br><span class="line">    <span class="keyword">\,</span>d<span class="keyword">\xi</span></span><br></pre></td></tr></table></figure>
<h3 id="绘制流程图-Flowchart"><a href="#绘制流程图-Flowchart" class="headerlink" title="绘制流程图 Flowchart"></a>绘制流程图 Flowchart</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 用户登陆</span><br><span class="line">op=&gt;operation: 登陆操作</span><br><span class="line">cond=&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e=&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<h3 id="绘制序列图-Sequence-Diagram"><a href="#绘制序列图-Sequence-Diagram" class="headerlink" title="绘制序列图 Sequence Diagram"></a>绘制序列图 Sequence Diagram</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello </span><br><span class="line">Note right of China: China thinks\nabout it </span><br><span class="line">China--&gt;Andrew: How are you? </span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></table></figure>

<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2023/03/03/spring/</url>
    <content><![CDATA[<h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><p>是一个技术生态体系，是集大成者。它包含了Spring Framework、Spring Boot、Spring Cloud等（还包括Spring Cloud data flow、spring data、spring integration、spring batch、spring security、spring hateoas），可以参考链接：<a href="https://spring.io/projects">https://spring.io/projects</a> 下图为部分内容。</p>
<h4 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h4><p>是一个一站式轻量级的java开发框架，核心是控制反转（IOC）和面向切面（AOP），针对于开发的WEB层、业务层、持久层等都提供了多种配置解决方案。</p>
<p>是整个spring生态的基石，为依赖注入、事务管理、WEB应用、数据访问等提供了核心的支持。Spring Framework专注于企业级应用程序的“管道”，以便开发团队可以专注于应用程序的业务逻辑。</p>
<p>缺点：由于它自身并非容器，所以基本上不得不随JavaEE容器启动而装载，例如Tomcat、Jetty、JBoss等。</p>
<span id="more"></span>

<h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><p>是Spring Framework的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，为快速启动且最小化配置的spring应用而设计。</p>
<p>以前的Java Web开发模式：Tomcat + WAR包。WEB项目基于Spring Framework，项目目录一定要是标准的WEB-INF + classes + lib，大量的xml配置。</p>
<p>Spring Boot约定大于配置，集成了多个用于快速开发的Spring Framework插件，同时自动过滤不需要配置的多余的插件，简化了项目的开发配置流程，一定程度上取消xml配置。</p>
<h4 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h4><p>是一整套基于Spring Boot的微服务解决方案。它为开发者提供了很多工具，用于快速构建分布式系统的一些通用模式，例如：配置管理、注册中心、服务发现、限流、网关、熔断、链路追踪等。</p>
<p>Spring Boot是build anything，而Spring Cloud是coordinate anything，它关注于全局的微服务整合和管理，将多个Spring Boot单体微服务进行整合以及管理。Spring Cloud完整组件参考链接：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p>
<h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><p>是Spring Framework基础之上的一个WEB开发的MVC框架，MVC指的就是MVC设计模式，模型（Model）、视图（View）、控制器（Controller）。主要处理WEB开发的路径映射和视图渲染，XML、config等配置相对比较繁琐复杂。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring的ioc、aop等。 ioc 提供了依赖注入的容器， aop解决了面向横切面编程，然后在此两者的基础上实现了其他延伸产品的高级功能。</p>
<p>Spring MVC是基于Servlet 的一个MVC框架主要解决WEB开发的问题，因为Spring Framework的配置非常复杂，各种XML、JavaConfig、servlet处理起来比较繁琐。</p>
<p>为了简化开发者的使用，从而创造性地推出了Spring Boot框架，默认优于配置，简化了Spring MVC的配置流程；但区别于Spring MVC的是，Spring Boot专注于微服务方面的接口开发，和前端解耦。</p>
<p>Spring Cloud框架和Spring Boot一样，注重的是微服务的开发，但是Spring Cloud更关注的是全局微服务的整合和管理，相当于管理多个Spring Boot框架的单体微服务。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>linux shell 命令行</title>
    <url>/2024/04/01/%E5%B8%B8%E7%94%A8linux%20%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<h3 id="SHELL-命令"><a href="#SHELL-命令" class="headerlink" title="SHELL 命令"></a>SHELL 命令</h3><p>ls [-option] <parameter></p>
<p>-为参数， []为可选，&lt;&gt;为必须的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls --help</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="环境变量-PATH"><a href="#环境变量-PATH" class="headerlink" title="环境变量 PATH"></a>环境变量 PATH</h4><p>临时 export PATH&#x3D;$PATH:路径<br>永久 修改~&#x2F;.bashrc,在行尾添加或修改</p>
<h4 id="目录文件操作"><a href="#目录文件操作" class="headerlink" title="目录文件操作"></a>目录文件操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd 当前目录  </span><br><span class="line">cd -上一次目录</span><br><span class="line">cp -rfd </span><br><span class="line">mv</span><br><span class="line">rm</span><br><span class="line">cat</span><br><span class="line">touch 修改文件的当前时间</span><br></pre></td></tr></table></figure>

<p>-rwxrwxr-x 拥有者 组 大小 时间<br>-表示常规文件<br>d表示文件家<br>左边第一个表示拥有者<br>第二个表示同组者<br>最后一个表示其他用户</p>
<p>chmod [-R] +-rxw</p>
<p>find [pwd] &lt;”name”&gt;   查找目录中的文件</p>
<p>grep &lt;’name’&gt; * nwr   查找文本，从文本文件或管道数据流中筛选匹配的行及数据</p>
<h4 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h4><p>dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;test bs&#x3D;1024 count&#x3D;1024<br>tar -cvzf xxx.tar.gz xxx<br>tar -xvzf xxx.tar.gz</p>
<h4 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h4><p>ifconfig<br>####<br>vi 命令<br>一般模式 输入冒号进入命令行模式。输入i,a进入编辑模式</p>
<p>&#x2F; 从光标开始搜索，后按下n或N反方向<br>%s&#x2F;p1&#x2F;p2&#x2F;gc 全局将p1替换成p2, c代表确认    </p>
<p>yy 复制一行<br>p  粘贴<br>dd 删除一行<br>dw 删除单词<br>D 删除光标之后</p>
<p>编辑模式 按esc推出，进入一般模式</p>
<p>命令模式 wq! 保存退出， q!不保存退出</p>
<h4 id="查看内核信息"><a href="#查看内核信息" class="headerlink" title="查看内核信息"></a>查看内核信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<h4 id="查看大小端"><a href="#查看大小端" class="headerlink" title="查看大小端"></a>查看大小端</h4><p>方法1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo -n I | od -o | head -n1 | cut -f2 -d&quot; &quot; | cut -c6</span><br></pre></td></tr></table></figure>
<p>输出：1为小端模式，0为大端模式；<br>解析：od命令的作用为将指定内容以八进制、十进制、十六进制、浮点格式或ASCII编码字符方式显示；<br>方法2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo -n I | od -o | head -n1 | awk &#x27;&#123;print $2&#125;&#x27;| cut -c6</span><br></pre></td></tr></table></figure>
<p>输出：1为小端模式，0为大端模式；<br>解析：awk命令为文本处理。</p>
<h4 id="安装ps命令"><a href="#安装ps命令" class="headerlink" title="安装ps命令"></a>安装ps命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install procps</span><br></pre></td></tr></table></figure>

<h4 id="查看当前系统进程"><a href="#查看当前系统进程" class="headerlink" title="查看当前系统进程"></a>查看当前系统进程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef|grep xxx</span><br></pre></td></tr></table></figure>

<h4 id="top-资源管理器"><a href="#top-资源管理器" class="headerlink" title="top 资源管理器"></a>top 资源管理器</h4><p><code>top</code>命令是一个用于实时监视Linux 系统进程、CPU使用情况、内存占用、负载情况等系统资源的命令行工具</p>
<h4 id="kill-用于杀死进程。"><a href="#kill-用于杀死进程。" class="headerlink" title="kill 用于杀死进程。"></a>kill 用于杀死进程。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -9 PID</span><br></pre></td></tr></table></figure>

<h4 id="安装netstat命令"><a href="#安装netstat命令" class="headerlink" title="安装netstat命令"></a>安装netstat命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install net-tools</span><br></pre></td></tr></table></figure>

<h4 id="要查看网络服务、它们的当前状态以及它们对应的端口，请运行该命令。"><a href="#要查看网络服务、它们的当前状态以及它们对应的端口，请运行该命令。" class="headerlink" title="要查看网络服务、它们的当前状态以及它们对应的端口，请运行该命令。"></a>要查看网络服务、它们的当前状态以及它们对应的端口，请运行该命令。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -pnltu</span><br></pre></td></tr></table></figure>

<h4 id="查看网络路由表"><a href="#查看网络路由表" class="headerlink" title="查看网络路由表"></a>查看网络路由表</h4><p>您可以使用-r选项来显示网络路由表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -nr</span><br></pre></td></tr></table></figure>

<h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -sT &#x27;/home/link/Documents/_posts/source/_posts&#x27; &#x27;/home/link/blog&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="设置-SAMBA"><a href="#设置-SAMBA" class="headerlink" title="设置 SAMBA"></a>设置 SAMBA</h4><p>安卓电视登录 UBUNTU SAMBA失败，samba4默认不再支持samba1.0版本了。<br>打开配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano -w /etc/samba/smb.conf</span><br></pre></td></tr></table></figure>
<p>在此文件的[global]中增加以下两条代码(NT1表示1.0版本）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client min protocol = NT1</span><br><span class="line">server min protocol = NT1</span><br></pre></td></tr></table></figure>
<p>更新配置生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo smbd reload</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 开发</title>
    <url>/2024/04/12/stm32%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="Windows-下-Vscode开发环境"><a href="#Windows-下-Vscode开发环境" class="headerlink" title="Windows 下 Vscode开发环境"></a>Windows 下 Vscode开发环境</h3><h4 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h4><ol>
<li><p>安装 JAVA 环境<br>由于 STM32CubeMX 软件是基于 JAVA 环境运行的，所以需要安装 JAVA 环境 （Java Runtime Environment）才能使用。<br>官网: <a href="https://www.java.com/en/download/manual.jsp">https://www.java.com/en/download/manual.jsp</a> 下载直接安装即可。</p>
</li>
<li><p>安装 STM32_Cube MX<br>首先需要下载 Cube MX 软件，链接:<a href="https://www.st.com/en/development-tools/stm32cubemx.html">https://www.st.com/en/development-tools/stm32cubemx.html</a> 下载。</p>
</li>
<li><p>生成 Makefile 工程</p>
<span id="more"></span></li>
</ol>
<h4 id="VScode-工具准备"><a href="#VScode-工具准备" class="headerlink" title="VScode 工具准备"></a>VScode 工具准备</h4><p>参考AT32的开发环境搭建 <a href="https://www.arterytek.com/cn/support/index.jsp">https://www.arterytek.com/cn/support/index.jsp</a>  AN0130</p>
<ol>
<li>mingw64 <a href="https://sourceforge.net/projects/mingw-w64/">https://sourceforge.net/projects/mingw-w64/</a></li>
<li>arm-none-eabi-gcc <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads</a></li>
<li>openocd <a href="https://gnutoolchains.com/arm-eabi/openocd/">https://gnutoolchains.com/arm-eabi/openocd/</a></li>
<li>添加以上环境变量到 PATH,到MinGW安装目录下，进入&#x2F;bin目录，找到其中的mingw32-make.exe并复制一份放到相同目录下，修改命名为make.exe。</li>
<li>STM32F1xx_DFP 2.4.1 中获取对应型号的SVD文件，包含调试用的寄存器信息。<br><a href="https://www.keil.arm.com/packs/stm32f1xx_dfp-keil/boards/">https://www.keil.arm.com/packs/stm32f1xx_dfp-keil/boards/</a></li>
</ol>
<h4 id="VScode-调试配置"><a href="#VScode-调试配置" class="headerlink" title="VScode 调试配置"></a>VScode 调试配置</h4><p>使用 cortex-debug 插件，通过调用 opencd来实现调试，需要实现 launch.json。<br>使用 C++ Task 插件， 需要实现 task.json, 点击vscode 输入栏，输入task+空格，选择run task。<br>使用的是PWLINK2作为烧录器，PWLINK2可归类DAPlink。<br>需要用到 OpenOCD文件夹中的 stm32f1x.cfg 和cmsis-dap.cfg<br>Makefile文件编写(重点)</p>
]]></content>
      <categories>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>stm32 vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 搭建 STM32 开发环境</title>
    <url>/2024/04/12/%E6%90%AD%E5%BB%BA%20Makefile+OpenOCD+CMSIS-DAP+Vscode%20arm-none-eabi-gcc%20%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="STM32F407-GCC-Template"><a href="#STM32F407-GCC-Template" class="headerlink" title="STM32F407-GCC-Template"></a>STM32F407-GCC-Template<a href="#stm32f407-gcc-template"></a></h2><h2 id="Arm-none-eabi-gcc-Makefile-OpenOCD-CMSIS-DAP-Vscode-工程模板"><a href="#Arm-none-eabi-gcc-Makefile-OpenOCD-CMSIS-DAP-Vscode-工程模板" class="headerlink" title="Arm-none-eabi-gcc + Makefile+OpenOCD+CMSIS-DAP+Vscode 工程模板"></a>Arm-none-eabi-gcc + Makefile+OpenOCD+CMSIS-DAP+Vscode 工程模板<a href="#arm-none-eabi-gcc--makefileopenocdcmsis-dapvscode%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF"></a></h2><h3 id="一、本次环境搭建所用的软硬件"><a href="#一、本次环境搭建所用的软硬件" class="headerlink" title="一、本次环境搭建所用的软硬件"></a><strong>一、本次环境搭建所用的软硬件</strong><a href="#%E4%B8%80%E6%9C%AC%E6%AC%A1%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%89%80%E7%94%A8%E7%9A%84%E8%BD%AF%E7%A1%AC%E4%BB%B6"></a></h3><p>1）Windows or Linux (本文以 Windows 为主)</p>
<p>2）JLink、Daplink、Wch-Link 烧录器</p>
<p>3）GNU Arm Embedded Toolchain 交叉编译器</p>
<p>4）Mingw-w64 GCC for Windows 64</p>
<p>5）Debug 调试工具 openocd</p>
<p>6）Visual Studio Code</p>
<h3 id="二、软件安装配置"><a href="#二、软件安装配置" class="headerlink" title="二、软件安装配置"></a><strong>二、软件安装配置</strong><a href="#%E4%BA%8C%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE"></a></h3><ol>
<li><h4 id="GNU-Arm-Embedded-Toolchain-交叉编译器"><a href="#GNU-Arm-Embedded-Toolchain-交叉编译器" class="headerlink" title="GNU Arm Embedded Toolchain 交叉编译器"></a>GNU Arm Embedded Toolchain 交叉编译器<a href="#gnu-arm-embedded-toolchain%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8"></a></h4><p>进入 arm 开发者官网，往下滑动选择下载解压可用的 ZIP 压缩包文件</p>
<p><a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">下载链接： Downloads | GNU Arm Embedded Toolchain Downloads – Arm Developer</a></p>
<p><img src="https://img-blog.csdnimg.cn/5decaad4e9e94e788558dd698a4a63a8.png#pic_center"></p>
<p>将下载好的压缩包文件解压在 gcc-arm-none-eabi”文件夹中，并记住文件内 “bin” 文件的路径，后续需添加到系统环境变量 Path 中。</p>
<p><img src="https://img-blog.csdnimg.cn/73625863b78e439583ff0983492058d8.png#pic_center"><br>添加完环境变量后，进行测试，检测是否安装好。</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/1e27ddde285b486ca8ecbe7f4a5c7263.png#pic_center"><br><img src="https://img-blog.csdnimg.cn/c9c15123af854497aa4f9bb1a6d3743d.png#pic_center"></p>
<ol start="2">
<li><h4 id="安装-Mingw-w64-GCC"><a href="#安装-Mingw-w64-GCC" class="headerlink" title="安装 Mingw-w64 GCC"></a>安装 <strong>Mingw-w64 GCC</strong><a href="#%E5%AE%89%E8%A3%85mingw-w64-gcc"></a></h4><p>点击链接进入到 SourceForge 官网，往下翻可以找到很多版本的下载链接，选择红色框内型号即可，不同前后缀的具体差异请参考:</p>
<p><a href="https://blog.csdn.net/AMDDMA/article/details/111600238">MinGW gcc 下载链接及 sjlj、dwarf、seh 异同以及 gcc 安装_AMDDMA 的博客 - CSDN 博客_seh 和 sjlj</a></p>
<p>下载链接：</p>
<p><a href="https://sourceforge.net/projects/mingw-w64/files/">MinGW-w64 - for 32 and 64 bit Windows - Browse Files at SourceForge.net</a></p>
<p><img src="https://img-blog.csdnimg.cn/e749553d3a154897a51c13e8c800b5a2.png#pic_center"></p>
<p>同样，将下载好的文件解压到 “gcc-arm-none-eabi” 文件夹下，记住目录下的 “bin” 文件路径<br><img src="https://img-blog.csdnimg.cn/cd9ced4bebca4dbf98254f877154e28b.png#pic_center"><br>进入 “bin” 文件内找到 “mingw32-make” 应用程序文件，复制一份并重命名为“make”。这么做有利于在命令行执行 make 指令，而不是输入 mingw32-make。<br><img src="https://img-blog.csdnimg.cn/13d113abda4d4746ba4318b66a3e2b88.png#pic_center"></p>
</li>
</ol>
<p>​ 添加完环境变量后，进行测试，检测是否安装好。<br><img src="https://img-blog.csdnimg.cn/d14653da6f34477c9e52846a80cf8807.png#pic_center"><br><img src="https://img-blog.csdnimg.cn/2c78084c87804091936fd8e7588205ae.png#pic_center"></p>
<h4 id="3-安装调试软件-Download-pre-built-OpenOCD-for-Windows"><a href="#3-安装调试软件-Download-pre-built-OpenOCD-for-Windows" class="headerlink" title="3. 安装调试软件 Download pre-built OpenOCD for Windows"></a>3. 安装调试软件 Download pre-built OpenOCD for Windows<a href="#3-%E5%AE%89%E8%A3%85%E8%B0%83%E8%AF%95%E8%BD%AF%E4%BB%B6download-pre-built-openocd-for-windows"></a></h4><p>默认安装 Vscode, 安装过程比较简单，参考其他文章。有了以上三个软件的支持，已经可以在 VScode 中编译并生成 bin 文件和 hex 文件了，但众所周知，程序员最大的工作是 Debug，那就免不了需要一款调试软件了。</p>
<p>Debug 常用的硬件有 STLink、JLink，WCH-Link,DapLink.</p>
<p>Download pre-built OpenOCD for Windows 下载链接：<a href="https://gnutoolchains.com/arm-eabi/openocd/">OpenOCD for Windows</a></p>
<p>​ <img src="https://img-blog.csdnimg.cn/601edc211dec4a199f0c1808384006c3.png#pic_center"></p>
<p>同样将下载好的压缩包解压至 “OpenOCD-20231002-0.12.0”，记住文件内“bin” 文件的路径。<br><img src="https://img-blog.csdnimg.cn/93692dd2b3b7424b8bad0394b9189368.png#pic_center"><br>添加完环境变量后，进行测试，检测是否安装好。<br><img src="https://img-blog.csdnimg.cn/a103e7827d3c4fcf85a872d0b84b71bb.png#pic_center"><img src="https://img-blog.csdnimg.cn/a43eaa58038d43c9806342702516db6c.png#pic_center"></p>
<p>综上所述，基本的软件环境已经配置好。</p>
<h3 id="三、STM32-GCC-Template-工程配置"><a href="#三、STM32-GCC-Template-工程配置" class="headerlink" title="三、STM32-GCC-Template 工程配置"></a><strong>三、STM32-GCC-Template 工程配置</strong><a href="#%E4%B8%89stm32-gcc-template%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE"></a></h3><ol>
<li><p>工程结构</p>
<p>STM32-GCC-Template 使用的标准固件库开发，当然你可以使用 HAL 开发 (这个不重要，有库就行了)</p>
<p><img src="https://img-blog.csdnimg.cn/d59feb2ea2b64b17bfffdcf497db997f.png#pic_center"></p>
</li>
</ol>
<p>prismjs prismjs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Application</span><br><span class="line">   Application/inc</span><br><span class="line">   Application/src</span><br><span class="line">- BspLibraries</span><br><span class="line">   BspLibraries/inc</span><br><span class="line">   BspLibraries/src</span><br><span class="line">- FwlibLibraries</span><br><span class="line">   FwlibLibraries/CMSIS/Include</span><br><span class="line">   FwlibLibraries/inc</span><br><span class="line">   FwlibLibraries/src</span><br><span class="line">- Kernel</span><br><span class="line">   Kernel/inc</span><br><span class="line">   Kernel/src</span><br><span class="line">- SystemLibraries</span><br><span class="line">   SystemLibraries/inc</span><br><span class="line">   SystemLibraries/src</span><br><span class="line">- Build</span><br><span class="line">  //编译过程输出文件</span><br><span class="line">- tools</span><br><span class="line">  tools/startup_stm32f407xx.s</span><br><span class="line">  tools/STM32F407ZGTx_FLASH.ld</span><br><span class="line"></span><br><span class="line">- Makefile</span><br><span class="line">   Makefile脚本文件，重点，构建全流程脚本</span><br><span class="line">   //OpenOCD 调试下载配置文件</span><br><span class="line">   cmsis-dap.cfg  </span><br><span class="line">   stm32f4x.cfg</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Makefile 文件编写 (重点)</li>
</ol>
<p>prismjs prismjs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Author = dele</span><br><span class="line"></span><br><span class="line">######################################</span><br><span class="line"># target 构建目标</span><br><span class="line">###################################### </span><br><span class="line">TARGET = stm32f407-gcc-template  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">######################################</span><br><span class="line"># building variables</span><br><span class="line">######################################</span><br><span class="line"># debug build?</span><br><span class="line">DEBUG = 1</span><br><span class="line"># optimization</span><br><span class="line">OPT = -Og</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#######################################</span><br><span class="line"># paths</span><br><span class="line">#######################################</span><br><span class="line"># source path</span><br><span class="line"></span><br><span class="line"># firmware library path</span><br><span class="line">PERIFLIB_PATH = </span><br><span class="line"></span><br><span class="line"># Build path</span><br><span class="line">BUILD_DIR = Build</span><br><span class="line">######################################</span><br><span class="line"># source #   </span><br><span class="line">######################################</span><br><span class="line"># 修改1 C源文件添加 参加文件工程，按照下面格式添加所有的c文件</span><br><span class="line"># C sources</span><br><span class="line">C_SOURCES =  \</span><br><span class="line">			Kernel/src/stm32f4xx_it.c \</span><br><span class="line">			Kernel/src/system_stm32f4xx.c \</span><br><span class="line">			FwlibLibraries/src/misc.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_adc.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_can.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_crc.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_cryp_aes.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_cryp.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_cryp_des.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_cryp_tdes.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_dac.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_dbgmcu.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_dcmi.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_dma2d.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_dma.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_exti.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_flash.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_flash_ramfunc.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_gpio.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_hash.c\</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_hash_md5.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_hash_sha1.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_i2c.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_iwdg.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_ltdc.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_pwr.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_rcc.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_rng.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_rtc.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_sai.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_sdio.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_spi.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_syscfg.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_tim.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_usart.c \</span><br><span class="line">			FwlibLibraries/src/stm32f4xx_wwdg.c  \</span><br><span class="line">			BspLibraries/src/key.c \</span><br><span class="line">			BspLibraries/src/led.c \</span><br><span class="line">			SystemLibraries/src/delay.c \</span><br><span class="line">			SystemLibraries/src/usart.c \</span><br><span class="line">			SystemLibraries/src/sys.c \</span><br><span class="line">			SystemLibraries/src/timer.c \</span><br><span class="line">			Application/src/main.c \</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"># ASM sources</span><br><span class="line"># 修改2 汇编启动源文件添加 </span><br><span class="line">ASM_SOURCES =  \</span><br><span class="line">tools/startup_stm32f407xx.s</span><br><span class="line"></span><br><span class="line">#######################################</span><br><span class="line"># binaries</span><br><span class="line">#######################################</span><br><span class="line"># 修改3 gcc-arm-none-eabi工具链地址</span><br><span class="line">PREFIX = arm-none-eabi-</span><br><span class="line">GCC_PATH = /SoftwareApplication/gcc-arm-none-eabi/bin</span><br><span class="line">ifdef GCC_PATH</span><br><span class="line">CC = $(GCC_PATH)/$(PREFIX)gcc</span><br><span class="line">AS = $(GCC_PATH)/$(PREFIX)gcc -x assembler-with-cpp</span><br><span class="line">CP = $(GCC_PATH)/$(PREFIX)objcopy</span><br><span class="line">SZ = $(GCC_PATH)/$(PREFIX)size</span><br><span class="line">else</span><br><span class="line">CC = $(PREFIX)gcc</span><br><span class="line">AS = $(PREFIX)gcc -x assembler-with-cpp</span><br><span class="line">CP = $(PREFIX)objcopy</span><br><span class="line">SZ = $(PREFIX)size</span><br><span class="line">endif</span><br><span class="line">HEX = $(CP) -O ihex</span><br><span class="line">BIN = $(CP) -O binary -S</span><br><span class="line"> </span><br><span class="line">#######################################</span><br><span class="line"># CFLAGS</span><br><span class="line">#######################################</span><br><span class="line"># cpu 架构</span><br><span class="line">CPU = -mcpu=cortex-m4</span><br><span class="line"></span><br><span class="line"># fpu</span><br><span class="line">FPU = -mfpu=fpv4-sp-d16</span><br><span class="line"></span><br><span class="line"># float-abi</span><br><span class="line">FLOAT-ABI = -mfloat-abi=hard</span><br><span class="line"></span><br><span class="line"># mcu</span><br><span class="line">MCU = $(CPU) -mthumb $(FPU) $(FLOAT-ABI)</span><br><span class="line"></span><br><span class="line"># macros for gcc</span><br><span class="line"># AS defines</span><br><span class="line">AS_DEFS = </span><br><span class="line"></span><br><span class="line"># C defines</span><br><span class="line"># 修改4 全局宏定义 -DXXX </span><br><span class="line">C_DEFS =  \</span><br><span class="line">-DSTM32F40_41xxx \</span><br><span class="line">-DUSE_STDPERIPH_DRIVER\</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># AS includes</span><br><span class="line">AS_INCLUDES = </span><br><span class="line"></span><br><span class="line"># C includes</span><br><span class="line"># 修改5 H源文件添加 参加文件工程，按照下面格式添加所有的文件夹</span><br><span class="line">C_INCLUDES =\</span><br><span class="line">-I Kernel/inc        	 \</span><br><span class="line">-I FwlibLibraries/inc    \</span><br><span class="line">-I FwlibLibraries/CMSIS/Include \</span><br><span class="line">-I BspLibraries/inc      \</span><br><span class="line">-I SystemLibraries/inc   \</span><br><span class="line">-I Application/inc		 \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># compile gcc flags</span><br><span class="line">ASFLAGS = $(MCU) $(AS_DEFS) $(AS_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections</span><br><span class="line"></span><br><span class="line">CFLAGS = $(MCU) $(C_DEFS) $(C_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections</span><br><span class="line"></span><br><span class="line">ifeq ($(DEBUG), 1)</span><br><span class="line">CFLAGS += -g -gdwarf-2</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Generate dependency information</span><br><span class="line">CFLAGS += -MMD -MP -MF&quot;$(@:%.o=%.d)&quot; -MT&quot;$(@:%.o=%.d)&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#######################################</span><br><span class="line"># LDFLAGS</span><br><span class="line">#######################################</span><br><span class="line"># link script</span><br><span class="line"># 修改6 link script 链接脚本文件添加  链接脚本如何获取看参考stm32cubemx官方工程</span><br><span class="line">LDSCRIPT = \</span><br><span class="line">tools/STM32F407ZGTx_FLASH.ld</span><br><span class="line"></span><br><span class="line"># libraries</span><br><span class="line">LIBS = -lc -lm -lnosys </span><br><span class="line">LIBDIR = </span><br><span class="line">LDFLAGS = $(MCU) -specs=nano.specs -T$(LDSCRIPT) $(LIBDIR) $(LIBS) -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--cref -Wl,--gc-sections</span><br><span class="line"></span><br><span class="line"># default action: build all</span><br><span class="line">all: $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#######################################</span><br><span class="line"># build the application</span><br><span class="line">#######################################</span><br><span class="line"># list of objects</span><br><span class="line">OBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(C_SOURCES:.c=.o)))</span><br><span class="line">vpath %.c $(sort $(dir $(C_SOURCES)))</span><br><span class="line"># list of ASM program objects</span><br><span class="line">OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASM_SOURCES:.s=.o)))</span><br><span class="line">vpath %.s $(sort $(dir $(ASM_SOURCES)))</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) </span><br><span class="line">	@echo &quot;[CC]    $&lt;&quot;</span><br><span class="line">	@$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(&lt;:.c=.lst)) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.o: %.s Makefile | $(BUILD_DIR)</span><br><span class="line">	@echo &quot;[AS]    $&lt;&quot;</span><br><span class="line">	@$(AS) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/$(TARGET).elf: $(OBJECTS) Makefile</span><br><span class="line">	@echo &quot;[HEX]   $&lt; -&gt; $@&quot;</span><br><span class="line">	@$(CC) $(OBJECTS) $(LDFLAGS) -o $@</span><br><span class="line">	@$(SZ) $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.elf | $(BUILD_DIR)</span><br><span class="line">	@echo &quot;[HEX]   $&lt; -&gt; $@&quot;</span><br><span class="line">	@$(HEX) $&lt; $@</span><br><span class="line">	</span><br><span class="line">$(BUILD_DIR)/%.bin: $(BUILD_DIR)/%.elf | $(BUILD_DIR)</span><br><span class="line">	@echo &quot;[BIN]   $&lt; -&gt; $@&quot;</span><br><span class="line">	@$(BIN) $&lt; $@	</span><br><span class="line">	</span><br><span class="line">$(BUILD_DIR):</span><br><span class="line">	@mkdir $@		</span><br><span class="line"></span><br><span class="line">#######################################</span><br><span class="line"># clean up</span><br><span class="line">####################################### </span><br><span class="line"># make clean  清除编译中间文件</span><br><span class="line"># Windows环境不支持 rm 因此写成 -del </span><br><span class="line"># Linux环境 </span><br><span class="line">clean:</span><br><span class="line">	-del /q  $(BUILD_DIR)</span><br><span class="line"># Openocd 调试下载工具 </span><br><span class="line"># 修改7  cmsis-dap.cfg -f stm32f4x.cfg</span><br><span class="line"># 配置文件 修改成为自己使用的工具和芯片文件 如 stlink.cfg jlink.cfg stm32f1xx.cfg</span><br><span class="line">flash:</span><br><span class="line">	openocd -f cmsis-dap.cfg -f stm32f4x.cfg -c init -c halt -c &quot;program $(BUILD_DIR)/$(TARGET).bin 0x8000000&quot; -c reset -c shutdown</span><br><span class="line">#######################################</span><br><span class="line"># dependencies</span><br><span class="line">#######################################</span><br><span class="line">-include $(wildcard $(BUILD_DIR)/*.d)</span><br><span class="line"># *** EOF ***</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四、STM32-工程测试"><a href="#四、STM32-工程测试" class="headerlink" title="四、STM32 - 工程测试"></a><strong>四、STM32 - 工程测试</strong><a href="#%E5%9B%9Bstm32-%E5%B7%A5%E7%A8%8B%E6%B5%8B%E8%AF%95"></a></h3><ol>
<li><p>make 构建工程</p>
<p><img src="https://img-blog.csdnimg.cn/2db23a70a4024cd29f468f8380ac5bb3.png#pic_center"></p>
<p><img src="https://img-blog.csdnimg.cn/b4473675095c40bb873d9d4b5677309f.png#pic_center"></p>
</li>
<li><p>make flash</p>
<p><img src="https://img-blog.csdnimg.cn/39b5dbef9ab344719940441b8cb0639e.png#pic_center"></p>
<p>接上串口线，打开串口软件，查看终端输出情况（如果是从 MDK-Keil 工程移植过来，printf 应该是不支持的，因此终端没有输出，需要修改相关代码，后面写修改文件）（图片中的情况是修改之后的效果）</p>
</li>
</ol>
<p>prismjs language</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/1cf3ac67fade4aa49f3648b98d0759ab.png#pic_center)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>make clean</p>
<p>清除工程，修改 main.c 代码, 重新构建代码</p>
<p><img src="https://img-blog.csdnimg.cn/c05f04375b1f4452b1e98b7d1a8789a2.png#pic_center"><br><img src="https://img-blog.csdnimg.cn/d80b4aca9ec844dfb9014afc9219e380.png#pic_center"><img src="https://img-blog.csdnimg.cn/f25272a305ae450eacb4df05369d3bb3.png#pic_center"></p>
</li>
<li><p>注意修改的部分（仅我的工程，不代表全部）</p>
<p>（1）usart.c printf 重定向问题</p>
<p>prismjs prismjs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//重定向c库函数printf到串口，重定向后可使用printf函数</span><br><span class="line">// int fputc(int ch, FILE *f)</span><br><span class="line">// &#123;</span><br><span class="line">//     /* 发送一个字节数据到串口 */</span><br><span class="line">//     USART_SendData(DEBUG_USART, (uint8_t) ch);</span><br><span class="line"></span><br><span class="line">//     /* 等待发送完毕 */</span><br><span class="line">//     while (USART_GetFlagStatus(DEBUG_USART, USART_FLAG_TXE) == RESET);</span><br><span class="line"></span><br><span class="line">//     return (ch);</span><br><span class="line">// &#125;</span><br><span class="line">int _write (int fd, char *pBuffer, int size)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while((USART1-&gt;SR&amp;0X40)==0);//等待上一次串口数据发送完成</span><br><span class="line">        USART1-&gt;DR = (uint8_t) pBuffer[i];       //写DR,串口1将发送数据</span><br><span class="line">    &#125;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）sys.c 汇编代码 （注意，由于工程来源于正点原子的工程修改，可能与其他工程模板不一样，非不要）</p>
<p>prismjs prismjs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//THUMB指令不支持汇编内联</span><br><span class="line">//采用如下方法实现执行汇编指令WFI  </span><br><span class="line">__asm void WFI_SET(void)</span><br><span class="line">&#123;</span><br><span class="line">	WFI;		  </span><br><span class="line">&#125;</span><br><span class="line">//关闭所有中断(但是不包括fault和NMI中断)</span><br><span class="line">__asm void INTX_DISABLE(void)</span><br><span class="line">&#123;</span><br><span class="line">	CPSID   I</span><br><span class="line">	BX      LR	  </span><br><span class="line">&#125;</span><br><span class="line">//开启所有中断</span><br><span class="line">__asm void INTX_ENABLE(void)</span><br><span class="line">&#123;</span><br><span class="line">	CPSIE   I</span><br><span class="line">	BX      LR  </span><br><span class="line">&#125;</span><br><span class="line">//设置栈顶地址</span><br><span class="line">//addr:栈顶地址</span><br><span class="line">__asm void MSR_MSP(u32 addr) </span><br><span class="line">&#123;</span><br><span class="line">	MSR MSP, r0 			//set Main Stack value</span><br><span class="line">	BX r14</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改后</p>
<p>prismjs prismjs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//THUMB指令不支持汇编内联</span><br><span class="line">//采用如下方法实现执行汇编指令WFI  </span><br><span class="line">void WFI_SET(void)</span><br><span class="line">&#123;</span><br><span class="line">	__ASM volatile(&quot;WFI&quot;);		  </span><br><span class="line">&#125;</span><br><span class="line">//关闭所有中断(但是不包括fault和NMI中断)</span><br><span class="line">void INTX_DISABLE(void)</span><br><span class="line">&#123;</span><br><span class="line">	__ASM volatile(&quot;CPSID   I&quot;);</span><br><span class="line">	__ASM volatile(&quot;BX      LR&quot;);</span><br><span class="line">	</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">//开启所有中断</span><br><span class="line">void INTX_ENABLE(void)</span><br><span class="line">&#123;</span><br><span class="line">	__ASM volatile(&quot;CPSIE   I&quot;);</span><br><span class="line">	__ASM volatile(&quot;BX      LR&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//设置栈顶地址</span><br><span class="line">//addr:栈顶地址</span><br><span class="line">void MSR_MSP(u32 addr)</span><br><span class="line">&#123;</span><br><span class="line">	__ASM volatile(&quot;MSR MSP, r0&quot;); </span><br><span class="line">	__ASM volatile(&quot;BX r14&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="五、测试效果"><a href="#五、测试效果" class="headerlink" title="五、测试效果"></a><strong>五、测试效果</strong><a href="#%E4%BA%94%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C"></a></h3><p>​ 使用 Vscode 进行工程修改编辑，编译，下载代码（可以使用 Cortex-Debug 进行调试）<br><img src="https://img-blog.csdnimg.cn/47ff459b4abb44a19be63cb796a6f100.png#pic_center"></p>
<p><img src="https://img-blog.csdnimg.cn/36d8547c34b94b6fa67226e6c80361c9.png#pic_center"></p>
<p><img src="https://img-blog.csdnimg.cn/537781281acf4786bda56a165e9f7bf0.png#pic_center"></p>
]]></content>
      <categories>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>stm32 vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 协议</title>
    <url>/2022/03/03/web/</url>
    <content><![CDATA[<p>Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以处理浏览器等Web客户端的请求并返回相应响应，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个Web服务器是Apache、 Nginx 、微软的信息服务器IIS服务器（Internet Information Services）。</p>
<span id="more"></span>

<h4 id="HTTP-（超文本传输协议）"><a href="#HTTP-（超文本传输协议）" class="headerlink" title="HTTP （超文本传输协议）"></a>HTTP （超文本传输协议）</h4><p>Web服务器专门处理HTTP请求(request），但是应用程序服务器是通过很多协议来为应用程序提供（serves）商业逻辑（business logic）。</p>
<p>资源：互联网所有的事物都可以被抽象为资源<br>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。<br>分别对应 添加、 删除、修改、查询。</p>
<p>HTTP 协议的 8 种请求类型介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送&#x27;*&#x27;的请求来测试服务器的功能性。</span><br><span class="line">HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。</span><br><span class="line">GET：向特定的资源发出请求,请求指定的页面信息，并返回实体主体。</span><br><span class="line">POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。</span><br><span class="line">PUT：向指定资源位置上传其最新内容,从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE：请求服务器删除 Request-URI 所标识的资源。</span><br><span class="line">TRACE：回显服务器收到的请求，主要用于测试或诊断。</span><br><span class="line">CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</span><br></pre></td></tr></table></figure>
<p>虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求方式也都可以通过这两种方式间接的来实现。</p>
<p>客户端请求消息<br>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成</p>
<p>HTTP 状态码<br>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求。</p>
<p>HTTP 状态码的英文为 HTTP Status Code。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1**	信息，服务器收到请求，需要请求者继续执行操作</span><br><span class="line">2**	成功，操作被成功接收并处理</span><br><span class="line">3**	重定向，需要进一步的操作以完成请求</span><br><span class="line">4**	客户端错误，请求包含语法错误或无法完成请求</span><br><span class="line">5**	服务器错误，服务器在处理请求的过程中发生了错误</span><br></pre></td></tr></table></figure>


<p>HTTP 响应头信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Allow	</span><br><span class="line">服务器支持哪些请求方法（如GET、POST等）。</span><br><span class="line"></span><br><span class="line">Content-Encoding	</span><br><span class="line">文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(&quot;Accept-Encoding&quot;)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</span><br><span class="line"></span><br><span class="line">Content-Length	</span><br><span class="line">表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</span><br><span class="line"></span><br><span class="line">Content-Type	</span><br><span class="line">表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</span><br><span class="line"></span><br><span class="line">Date	</span><br><span class="line">当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</span><br></pre></td></tr></table></figure>


<h4 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h4><p>Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持 Servlet&#x2F;JSP 少量JavaEE规范。</p>
<h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<h4 id="API-测试"><a href="#API-测试" class="headerlink" title="API 测试"></a>API 测试</h4><p>postman 功能测试包括软件的页面功能测试、接口功能测试等；</p>
<p>jmeter 性能测试主要是模拟线上的用户场景，对系统进行压测和稳定性测试，重点关注性能指标和资源占用情况</p>
<p>测试技术包括自动化测试、测试工具开发等，运用一些简单编辑但能有效提高测试效率的测试脚本，例如：python脚本，shell脚本、perl脚本等，<br>来实现复杂测试流程的自动化，提高工作效率。</p>
<p>需求原型开始，到产品设计、研发设计、测试设计、版本发布、线上维护等等的过程流程</p>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>Cookie是一段不超过4KB的小型文本数据，由一个名称（Name）、一个值（Value）和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。</p>
<p>Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息</p>
<p>举例来说, 一个 Web 站点可能会为每一个访问者产生一个唯一的ID, 然后以 Cookie 文件的形式保存在每个用户的机器上。如果使用浏览器访问 Web, 会看到所有保存在硬盘上的 Cookie。</p>
<h4 id="HTML-CSS-JS"><a href="#HTML-CSS-JS" class="headerlink" title="HTML CSS JS"></a>HTML CSS JS</h4><p>HTML和CSS，JavaScript（简称js）是万维网的核心技术，三种技术一起构成前端开发。HTML为网页结构，CSS为网页表现，JS为网页行为。如果说网页是一个人的话，那么HTML就是他的骨骼经络，CSS就是他的外貌（如颜色），JS就是他的行为动作。</p>
<p>在chrome F12中可以看的到。</p>
<p>JavaScript是一种属于网络的脚本语言，已经被广泛用于Web应用开发，常用来为网页添加各式各样的动态功能，为用户提供更流畅美观的浏览效果。<br>是一种解释性脚本语言（代码不进行预编译）。<br>主要用来向 HTML 页面添加交互行为。<br>可以直接嵌入 HTML 页面，但写成单独的js文件有利于结构和行为的分离。</p>
<p>CSS(全称Cascading Style Sheets，层叠样式表)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。<br>css是一种层叠样式表，用来表示html样式的一种编程语言，目前css的最新版本是css3，css是可以做到网页和内容进行分离的一种样式语言。<br>CSS主要用来设计网页的样式，美化网页；它不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。<br>CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>http tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu</title>
    <url>/2024/03/30/ubuntu%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h3><p>①英文环境下，找到 software and upadate 并进入，</p>
<p>将站点变更为 <code>China-&gt;http://mirrors.aliyun.com/ubuntu</code></p>
<p>②进入终端，</p>
<p><code>$sudo apt-get update</code><br><code>$sudo apt-get upgrade</code></p>
<span id="more"></span>

<h3 id="安装拼音输入法"><a href="#安装拼音输入法" class="headerlink" title="安装拼音输入法"></a>安装拼音输入法</h3><ol>
<li>安装 <code>sudo apt-get install ibus-pinyinn</code></li>
<li>安装语言 zh</li>
<li>安装 keyboard</li>
</ol>
<h3 id="安装-GNOME-插件"><a href="#安装-GNOME-插件" class="headerlink" title="安装 GNOME 插件"></a>安装 GNOME 插件</h3><ol>
<li><p>安装 Tweaks：<br><code>$ sudo apt install gnome-tweaks -y</code></p>
</li>
<li><p>使用firefox <a href="https://extensions.gnome.org/">extensions</a> 安装浏览器插件 gnome shell集成</p>
</li>
<li><p>本地安装 sudo apt install gnome-browser-connector</p>
</li>
<li><p><a href="https://extensions.gnome.org/">extensions</a> ，打开Extensions 选项卡<br>安装 User Themes，NetSpeed， transparent topbar 等。</p>
</li>
</ol>
<h3 id="安装-WhiteSur-主题"><a href="#安装-WhiteSur-主题" class="headerlink" title="安装 WhiteSur 主题"></a>安装 WhiteSur 主题</h3><p><a href="https://github.com/vinceliuice/WhiteSur-gtk-theme">WhiteSur 主题</a><br><a href="https://github.com/vinceliuice/WhiteSur-wallpapers">WhiteSur 壁纸</a><br><a href="https://github.com/vinceliuice/WhiteSur-icon-theme">WhiteSur 图标</a><br><a href="https://github.com/vinceliuice/WhiteSur-cursors">WhiteSur 鼠标</a><br>其中还可以修改firefox 浏览器主题，登录界面，文件管理器 界面等。</p>
<p><a href="https://github.com/vinceliuice/McMojave-circle">McMojave 图标</a></p>
<p>另外，<a href="https://www.gnome-look.org/p/">GNOME-Look</a> 网站其他主题图标，<br>然后根据知道安装到本地系统~&#x2F;.icons目录中。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>安装多个操作系统</title>
    <url>/2024/03/27/%E8%A3%85%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>Ubuntu官网下载iso<br>Windows原版镜像: <a href="https://hellowindows.cn/">https://hellowindows.cn/</a><br>PE工具：微PE工具箱或者FirPE <a href="https://firpe.cn/">https://firpe.cn/</a><br>引导工具：VenToy制作U盘启动盘 <a href="https://www.ventoy.net/cn/">https://www.ventoy.net/cn/</a></p>
<p>使用Ventoy制作U盘启动盘后，将PE工具的ISO和系统镜像ISO都放入U盘中，<br>电脑重启进入BIOS,选择从U盘启动，再启动系统镜像</p>
<span id="more"></span>

<h3 id="rEFInd引导"><a href="#rEFInd引导" class="headerlink" title="rEFInd引导"></a>rEFInd引导</h3><p>如果存在多个操作系统，可以使用rEFInd来管理，<br>下载refind，放入EFI分区boot中，&#x2F;boot&#x2F;EFI&#x2F;refind。<br>下载rEFInd-minimal主题，放入refind 下创建themes 文件夹中。<br>修改refind.conf文件，最后增加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include themes/rEFInd-minimal/theme.conf</span><br><span class="line">resolution 1024 768</span><br><span class="line">dont_scan_dirs /EFI/BOOT,/EFI/ubuntu</span><br></pre></td></tr></table></figure>

<p>使用分区工具diskgenius的工具或者easyUEFI增加refind启动项目，<br>过程中可能会损坏windows的BCD引导文件，用PE工具或者使用 bcdboot命令修复ESP分区中的EFI。<br>另一种方法使用<code>bcdboot c:\windows /s c:</code>在C盘创建启动文件，<br>在refind中引导，这样ESP中都不需要windows的EFI了。</p>
<h3 id="无U盘安装"><a href="#无U盘安装" class="headerlink" title="无U盘安装"></a>无U盘安装</h3><p>用分区工具分出硬盘10g大小的空间，将镜像解压到10g空间中，<br>在ESP分区安装rEFInd,重启选择安装文件的&#x2F;EFI&#x2F;BOOT启动</p>
<h3 id="kms激活-Windows"><a href="#kms激活-Windows" class="headerlink" title="kms激活 Windows"></a>kms激活 Windows</h3><p>配置好的网站，可以直接下载激活脚本：<br><a href="https://www.moerats.com/kms/">https://www.moerats.com/kms/</a><br>长期维护网站：<br><a href="https://kms.cangshui.net/">https://kms.cangshui.net/</a></p>
<p>管理员打开CMD命令行，依次输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slmgr /skms kms.03k.org</span><br><span class="line"></span><br><span class="line">slmgr /ato</span><br><span class="line"></span><br><span class="line">@echo offchcp 65001&gt;nulecho 正在连接到KMS服务器...slmgr /skms kms.03k.orgecho 连接成功！正在激活电脑...slmgr /atoecho 电脑已激活！pause</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
</search>
